<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>Ayam: Scripting Interface</TITLE>
 <LINK HREF="ayam-7.html" REL=next>
 <LINK HREF="ayam-5.html" REL=previous>
 <LINK HREF="ayam.html#toc6" REL=contents>
</HEAD>
<BODY>
<script type="text/javascript" src="ll.js"></script>
<A HREF="ayam-7.html">Next</A>
<A HREF="ayam-5.html">Previous</A>
<A HREF="ayam.html#toc6">Contents</A>
<HR>
<H2><A NAME="script"></A> <A NAME="s6">6.</A> <A HREF="ayam.html#toc6">Scripting Interface</A></H2>

<P>The Ayam scripting interface consists of a number of Tcl procedures
and Tcl commands that are also used internally by the application.
For instance, the main menu entry <CODE>"File/New"</CODE> calls the
scripting interface command <CODE>"newScene"</CODE> (among other commands).
Using the Ayam scripting interface means to call these procedures
or commands, possibly in a mix with standard Tcl script code.</P>
<P>Furthermore, using Tcl and its introspection capabilities, the code
Ayam consists of could easily be modified at runtime. This is, however, not
recommended for good reasons (unless intimate knowledge about the Ayam
source code is obtained first).
So watch out for already existing procedures and commands when
implementing your own.
Using procedures and commands not listed in this documentation
is dangerous too. Implementation and interfaces of those
procedures and commands may change in future versions of Ayam without
notice.</P>
<P>In Tcl, all variables, procedures, and commands are case sensitive,
it really is <CODE>"sL"</CODE> and <EM>not</EM> <CODE>"sl"</CODE> and <EM>not</EM>
<CODE>"SL"</CODE>.</P>
<P>The scripting interface may be used directly from the console
of Ayam. One can, of course, also put scripts in Tcl script files,
that may be loaded at any time into Ayam using
the console and the Tcl command <CODE>"source"</CODE>.
Script files can also be made to run on every application startup
automatically using the preference setting
<CODE>"Main/Scripts"</CODE>.
Moreover, on the X11 and Aqua window systems, Ayam is able to execute
script code sent via the Tk <CODE>"send"</CODE> command or the AppleScript
<CODE>"tell"</CODE> command from external applications.</P>
<P>In contrast to other modelling environments, in Ayam there is yet
another way to run scripts. In Ayam, scripts may also be attached
to Script objects and run when the notification mechanism updates
the scene. See also section
<A HREF="ayam-4.html#scriptobj">Script object</A>.
Even normal objects can trigger scripts upon notification using
BNS or ANS tags. See also sections
<A HREF="ayam-4.html#bnstag">Before Notify Script</A> and
<A HREF="ayam-4.html#anstag">After Notify Script</A>.</P>
<P>Note that most of the scripting interface commands listed in this
documentation work in the background, without changing anything to
the Ayam GUI and Ayam view windows, for the sake of execution speed.
To make any changes to the scene visible, the various parts of the GUI
(property GUIs, view windows) need to be updated explicitly
(see also section 
<A HREF="#sciupd">Updating the GUI</A>).<BR>
However, since Ayam 1.13 it is also possible to automatically run GUI
updating commands in the console with every issued command by
using <CODE>&lt;Shift+Return&gt;</CODE>
instead of <CODE>&lt;Return&gt;</CODE>.<BR>
Also note that even though no updates of the GUI take place when using
the scripting interface, all notification processes are carried out
immediately regardless. The scene will be consistent and up to date
when the scripting interface command returns.</P>
<P>Scene changes from the scripting interface can also be recorded in
the undo buffer, but this must be arranged manually too
(see the documentation of the undo
command: 
<A HREF="#scundo">Undo</A>).</P>
<P>From scripts it may be necessary to check whether an error occurred
during the execution of a command. All commands return
<CODE>TCL_OK</CODE> in <EM>any</EM> case, so checking their return value avails
to nothing, but they set the global Tcl variable <CODE>"ay_error"</CODE>
to a value higher than 1 if an error occurred. This variable needs to
be set to zero before and checked after the operation in question
to see whether the operation performed successfully, see the following
example:</P>
<P>
<HR>
<PRE>
proc myProc { } {
  set ::ay_error 0
  copOb
  if { $::ay_error > 1 } {
    ayError 2 "myProc" "Error copying object!"
  }
}
</PRE>
<HR>
</P>

<H2><A NAME="ss6.1">6.1</A> <A HREF="ayam.html#toc6.1">Global Variables and Arrays</A>
</H2>

<P>Several global variables and arrays exist in the Ayam Tcl context, that
may be useful for scripts.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Global Variables</H3>

<P>The global variable <CODE>"ay_error"</CODE> holds the current error state.
See also section 
<A HREF="#scierr">Reporting Errors</A>.</P>
<P>The global variable <CODE>"i"</CODE> is used by all <CODE>"forAll"</CODE>
command variants. See also section
<A HREF="#scifall">Applying Commands to a Number of Objects</A>.</P>
<P>The global variables <CODE>"u"</CODE> and <CODE>"v"</CODE> are set by the
find u/uv actions. See also sections
<A HREF="ayam-3.html#finduac">Finding Points on Curves</A> and
<A HREF="ayam-3.html#finduvac">Finding Points on Surfaces</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ayarray"></A> The Global Array ay</H3>

<P>The global array <CODE>"ay"</CODE> holds application state variables.
Furthermore, the paths to important widgets can be found
(e.g.&nbsp;the tree widget for the object hierarchy or the currently
active view) in this array.
Use <CODE>"parray ay"</CODE> in the console to see what is there.
More documentation to come.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ayprefs"></A> The Global Array ayprefs</H3>

<P>The global array <CODE>"ayprefs"</CODE> holds preferences data.
The <EM>complete</EM> array is saved in the <EM>ayamrc</EM> file upon exit,
so be careful when adding new elements to this array.
See also section 
<A HREF="ayam-8.html#ayamrc">Ayamrc File</A>.
Use <CODE>"parray ayprefs"</CODE> in the console to see what is there.
More documentation to come.</P>
<P>Note that changes to this array on the Tcl side do not immediately
take effect as the data needs first to be transferred to the C context
using the <CODE>"setPrefs"</CODE> command.
See also section 
<A HREF="#sciprefs">Managing Preferences</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="aymark"></A> The Global Array aymark</H3>

<P>The global array <CODE>"aymark"</CODE> holds a copy of the current mark position.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
It is updated whenever the mark is set using e.g.&nbsp;the
set mark action (see section 
<A HREF="ayam-3.html#markac">Setting the Mark</A>).
Manual changes to this array have no effect on the mark.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ayproparr"></A> Property Management and Data Arrays</H3>

<P>For every object type, a corresponding global variable exists,
that contains the property names of this object type as a list.
The variable name is just the object type name followed
by <CODE>_props</CODE> (for properties).
For example for the NCurve object type, this variable is named
<CODE>"NCurve_props"</CODE> and the list it contains looks like this:
<BLOCKQUOTE><CODE>
<PRE>
{ Transformations Attributes Tags NCurveAttr }
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>This list is consulted each time a single object is selected in the tree
view or object list widget and its content is used to populate the properties
listbox widget. See also section 
<A HREF="ayam-2.html#propgui">Properties</A>.
Note that the list can be further manipulated
by <CODE>"NP"</CODE> and <CODE>"RP"</CODE> tags of the selected object.</P>
<P>For every property, a corresponding global array exists, where the
property is managed. For the Transformations property, this array looks
like this:
<HR>
<PRE>
Transformations {
  arr   transfPropData
  sproc setTrafo
  gproc getTrafo
  w     fTrafoAttr
}
</PRE>
<HR>

The first entry, <CODE>"arr"</CODE>, designates the name of the global property
data array (thus, transformation data is stored in an array called
<CODE>"transfPropData"</CODE>).
This array only holds useful data when it has been filled explicitly
by the so called get-property callback.</P>
<P>The entries <CODE>"sproc"</CODE> and <CODE>"gproc"</CODE> designate the set-property and
get-property callbacks (procedures or commands).
Those are called, when the <CODE>"Apply"</CODE> button is used or the
property is selected in the properties listbox respectively.
If sproc or gproc are empty strings (<CODE>""</CODE>), standard callbacks
named <CODE>"setProp"</CODE> or <CODE>"getProp"</CODE> will/should be used to get
or set the property values.
But for the Transformations property, the <CODE>"setTrafo"</CODE> and
<CODE>"getTrafo"</CODE> commands should be used.
The flexibility gained by individual sproc/gproc procedures is used to
sanitize user input, run additional GUI update code or realize dynamic
property GUIs.</P>
<P>The last entry, <CODE>"w"</CODE>, is the name of the main property GUI window.
To get the full, usable, widget path of this window, the current value of the
array entry <CODE>"ay(pca)"</CODE> needs to be prepended:
<CODE>$ay(pca).$Transformations(w)</CODE>.</P>
<P>Note that for many object types the property variable and the
object type specific property management arrays only exist after an
object type specific initialization procedure, derived from the
type name, is called, e.g.&nbsp;<CODE>"init_Box"</CODE>.
Those types are:
ACurve, Bevel, Birail1, Birail2, Box, BPatch, Cap, ConcatNC, ConcatNP,
Cone, Cylinder, Disk, ExtrNC, ExtrNP, Hyperboloid, ICurve, IPatch,
NCircle, OffsetNC, OffsetNP, PatchMesh, Paraboloid, Revolve, RiInc,
RiProc, Script, SDMesh, Select, Sphere, Sweep, Swing, Torus, and Trim.</P>
<P>Since Ayam 1.16, the global property management array may be created
easily using the new scripting interface command <CODE>"addPropertyGUI"</CODE>.
See also section 
<A HREF="#scipgui">Property GUI Management</A>.</P>


<P>The following global arrays and callbacks to get or set the data
exist:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>property</B></TD><TD><B>array</B></TD><TD><B>get-property callback</B></TD><TD><B>set-property callback</B></TD></TR><TR><TD>
Transformations</TD><TD>transfPropData</TD><TD>getTrafo</TD><TD>setTrafo</TD></TR><TR><TD>
Attributes</TD><TD>attrPropData</TD><TD>getAttr</TD><TD>setAttrp</TD></TR><TR><TD>
Material</TD><TD>matPropData</TD><TD>getMat</TD><TD>setMat</TD></TR><TR><TD>
Tags</TD><TD>tagsPropData</TD><TD>getTagsp</TD><TD>setTagsp</TD></TR><TR><TD>
MaterialAttr</TD><TD>MaterialAttrData</TD><TD>""</TD><TD>setMaterialAttrp</TD></TR><TR><TD>
Surface</TD><TD>ay_shader</TD><TD>shader_getSurf</TD><TD>shader_setSurf</TD></TR><TR><TD>
Displacement</TD><TD>ay_shader</TD><TD>shader_getDisp</TD><TD>shader_setDisp</TD></TR><TR><TD>
Interior</TD><TD>ay_shader</TD><TD>shader_getInt</TD><TD>shader_setInt</TD></TR><TR><TD>
Exterior</TD><TD>ay_shader</TD><TD>shader_getExt</TD><TD>shader_setExt</TD></TR><TR><TD>
Light</TD><TD>ay_shader</TD><TD>light_getShader</TD><TD>light_setShader</TD></TR><TR><TD>
LightAttr</TD><TD>LightAttrData</TD><TD>light_getAttr</TD><TD>""</TD></TR><TR><TD>
ViewAttrib</TD><TD>ViewAttribData</TD><TD>""</TD><TD>setViewAttr</TD></TR><TR><TD>
Camera</TD><TD>CameraData</TD><TD>""</TD><TD>setCameraAttr</TD></TR><TR><TD>
NCurveAttr</TD><TD>NCurveAttrData</TD><TD>""</TD><TD>""</TD></TR><TR><TD>
NPatchAttr</TD><TD>NPatchAttrData</TD><TD>""</TD><TD>""</TD></TR><TR><TD>
ICurveAttr</TD><TD>ICurveAttrData</TD><TD>""</TD><TD>""</TD></TR><TR><TD>
NCircleAttr</TD><TD>NCircleAttrData</TD><TD>""</TD><TD>""
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Property Arrays and Callbacks</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Note that this list is pretty much incomplete, however the information
can always be inferred easily using the <CODE>"parray"</CODE> command in the Ayam
console:
<BLOCKQUOTE><CODE>
&raquo;&thinsp;parray NCurveAttr
</CODE></BLOCKQUOTE>

See also section
<A HREF="#sciprop">Manipulating Properties</A>
for more information on how to edit property values from the
scripting interface.</P>



<H2><A NAME="sccomm"></A> <A NAME="ss6.2">6.2</A> <A HREF="ayam.html#toc6.2">Procedures and Commands</A>
</H2>

<P>This section provides documentation on the most important
scripting interface procedures and commands of Ayam sorted
by category.</P>
<P>Note that the <CODE>"help"</CODE> command in the Ayam console can be used
to directly jump to the appropriate sub-section of this part of
the documentation.</P>
<P>All procedures and commands are documented in the following scheme:
<UL>
<LI><B>Synopsis:</B> <CODE>"command param1 param2 [optionalparam1]"</CODE>
(syntax of the command and its parameters),</LI>
<LI><B>Background:</B> does the command run in the background,
<B>Undo:</B> can the result of the command be undone,
<B>Safe:</B> is the command available in the safe interpreter (for Script
objects and notify script tags),
<B>Type:</B> Procedure &ndash; this is actually not a command but a procedure
implemented in Tcl</LI>
<LI><B>Description:</B> detailed description of the command and its
parameters,</LI>
<LI><B>Notes:</B> additional information completing the detailed description,</LI>
<LI><B>Example:</B> <CODE>"command 1 2"</CODE> (example application of the command
with explanation of expected results).</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="schelp"></A> Getting Help on Scripting Interface Commands</H3>

<P>Since Ayam 1.8.2 a scripting interface command named <CODE>"help"</CODE> is available,
that displays the help of scripting interface commands using a web
browser (similar to the <CODE>"Help on Object"</CODE> feature):
<UL>
<LI>Synopsis: <CODE>"help command"</CODE></LI>
<LI>Background: N/A,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Fire up a web browser and display the help for
the designated Ayam scripting interface command or procedure.</LI>
<LI>Example: <CODE>"help help"</CODE> displays the help of the help procedure.</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Managing Objects</H3>

<P>
<A NAME="sccrtob"></A> <A NAME="crtob"></A> 
To create new objects the <CODE>"crtOb"</CODE> command can be used.
<UL>
<LI>Synopsis: <CODE>"crtOb type [args]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: New objects may be created with the command <CODE>"crtOb"</CODE>,
<CODE>"type"</CODE> may be derived from the object type names, as displayed in the
tree view.
The new object will be created and linked to the scene as last object
in the current level, no part of the GUI (object selection widget, property
GUI, views) will be updated. Furthermore, the new object will <EM>not</EM>
be selected.
<P>Depending on the type, further arguments may (or have to) be given;
some object types expect other objects to be selected upon creation.</P>
<P>All arguments consist of a option name part and a value part (i.e.&nbsp;it is
<CODE>"-center 1"</CODE> and <EM>not</EM> <CODE>"-center"</CODE> and also <EM>not</EM>
<CODE>"-center=1"</CODE>).
The option names can be abbreviated. Useful default and fallback
values exist (see below). The arguments can be mixed freely (their
order is not important) and repeated. If arguments are repeated, only the
last set value is used, even if this leads to errors and application of
fallback values later on.</P>

<P>Here is a comprehensive list of available arguments sorted by
object type:</P>




<P>
<UL>
<LI><CODE>"<B>NCurve</B>"</CODE>: NURBS curves accept the following
arguments:
<A NAME="sccrtnc"></A> 
<UL>
<LI><CODE>"-length"</CODE>: length of the new curve, the length defaults to 4.</LI>
<LI><CODE>"-order"</CODE>: order of the new curve, the order defaults to 4.
If a value greater than the length is specified, the order will be made
identical to the length value.</LI>
<LI><CODE>"-kt"</CODE>: the knot type of the new curve, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <CODE>"-kv"</CODE> option below,
the knot type will always be set to 3 &ndash; Custom.
</LI>
<LI><CODE>"-kv"</CODE>: the knot vector of the new curve. The value of this
option is a list of floating point numbers of length curve length plus
curve order, e.g.&nbsp;for a curve with 2 control points and order 2, specify
4 knots: <CODE>"-kv {0.0 0.0 1.0 1.0}"</CODE>. The knot vector defaults to
an automatically created knot vector of the type specified by the
<CODE>"-kt"</CODE> option above.
</LI>
<LI><CODE>"-kn"</CODE>: the knot vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-kv"</CODE> option
above.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 4D euclidean
rational (weight <EM>not</EM> multiplied in) coordinates of the control
points.<BR>
This list may also only specify one point, which is then taken as starting
point and DX/DY/DZ (see below) are used to create the missing control points
automatically.<BR>
To specify a complete control vector, this list should have
length&thinsp;&times;&thinsp;4 elements, e.g.&nbsp;for a curve of length 3,
specify 12 values:
<CODE>"-cv {0.0 0.0 0.0 1.0  1.0 0.0 0.0 1.0  2.0 0.0 0.0 1.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-dx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.
</LI>
<LI><CODE>"-dy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.
</LI>
<LI><CODE>"-dz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
<LI><CODE>"-createmp"</CODE>: The <CODE>"-createmp"</CODE> option toggles creation
of multiple points. The default value is 0.</LI>
</UL>



<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb NCurve"</CODE></B><BR>
creates a curve with length 4, order 4, standard (clamped) NURBS knot
vector, control points at 0 0 0, 0.25 0 0, 0.5 0 0, 0.75 0 0 (all weights 1).</LI>
<LI><B><CODE>"crtOb NCurve -center 1"</CODE></B><BR>
creates a centered curve with length 4, order 4, standard (clamped) NURBS knot
vector, control points at -0.375 0 0, -0.125 0 0, 0.125 0 0, 0.375 0 0
(all weights 1).</LI>
<LI><B><CODE>"crtOb NCurve -length 5 -center 1 -dx 0.5"</CODE></B><BR>
creates a centered curve with length 5, order 4, standard (clamped) NURBS knot
vector, control points at -1 0 0, -0.5 0 0, 0 0 0, 0.5 0 0, 1 0 0
(all weights 1).</LI>
</OL>

<P>In versions of Ayam prior to 1.17, NURBS curves only accepted the
<CODE>"-length"</CODE> argument.</P>
<P>See also section 
<A HREF="ayam-4.html#ncurveobj">NCurve Object</A>.</P>




</LI>
<LI><CODE>"<B>ICurve</B>"</CODE>: Interpolating curves accept the following
arguments:
<A NAME="sccrtic"></A> 
<UL>
<LI><CODE>"-type"</CODE>: the type of the new curve, must be one of
0 &ndash; Open, 1 &ndash; Closed; default is 0.
</LI>
<LI><CODE>"-length"</CODE>: length (number of data points to interpolate)
of the new curve; the length defaults to 4.
</LI>
<LI><CODE>"-order"</CODE>: order of the new curve, the order defaults to 4.
If a value greater than the length is specified, the order will be made
identical to the length value.
</LI>
<LI><CODE>"-pt"</CODE>: the parameter type of the new curve, must be one of
0 &ndash; Chordal, 1 &ndash; Centripetal, 2 &ndash; Uniform; default is 0.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control points. This list may also
only specify one point, which is then taken as starting point and
DX/DY/DZ (see below)
are used to create the missing control points automatically.
To specify a complete
control vector, this list should have curve length&thinsp;&times;&thinsp;3
elements, e.g.&nbsp;for a curve of length 3, specify 9 values:
<CODE>"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-dx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.
</LI>
<LI><CODE>"-dy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.
</LI>
<LI><CODE>"-dz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
<LI><CODE>"-derivs"</CODE>: the value of this option controls whether
user defined end derivatives should be used: 0 &ndash; no, 1 &ndash; yes,
default is 0.
</LI>
<LI><CODE>"-sdlen"</CODE>: the value of this option specifies the
relative length (in relation to the distance of the first and second
control point) of the start derivative, default is 0.125.
</LI>
<LI><CODE>"-sderiv"</CODE>: is the start derivative, specified as
a list of three float values. The derivative is specified relative to the
first control point. The start derivative defaults to an automatically created
derivative of a direction taken from the first two control points
and length specified by the <CODE>"-sdlen"</CODE> option.
</LI>
<LI><CODE>"-edlen"</CODE>: the value of this option specifies the
relative length (in relation to the distance of the second to last and last
control point) of the end derivative, default is 0.125.
</LI>
<LI><CODE>"-ederiv"</CODE>: is the end derivative, specified as
a list of three float values. The derivative is specified relative to the
last control point. The end derivative defaults to an automatically created
derivative of a direction taken from the last two control points
and length specified by the <CODE>"-edlen"</CODE> option.
</LI>
</UL>



<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb ICurve"</CODE></B><BR>
creates a curve with length 4, order 4, data points at
0 0 0, 0.25 0 0, 0.5 0 0, 0.75 0 0.</LI>
<LI><B><CODE>"crtOb ICurve -l 5 -sderiv {0.0 -0.5 0.0} -ederiv {0.0 -0.5 0.0} -derivs 1 -center 1"</CODE></B><BR>
creates a curve with length 5, order 4, data points at
-0.5 0 0, -0.25 0 0, 0 0 0, 0.25 0 0, 0.5 0 0, end derivatives pointing
straight upwards with length 0.5 in their respective end.</LI>
</OL>

<P>In versions of Ayam prior to 1.17, interpolating curves only accepted the
<CODE>"-length"</CODE> argument.</P>
<P>See also section 
<A HREF="ayam-4.html#icurveobj">ICurve Object</A>.</P>




</LI>
<LI><CODE>"<B>ACurve</B>"</CODE>: Approximating curves accept the following
arguments:
<A NAME="sccrtac"></A> 
<UL>
<LI><CODE>"-type"</CODE>: the type of the new curve, must be one of
0 &ndash; Open, 1 &ndash; Closed; default is 0.
</LI>
<LI><CODE>"-length"</CODE>: length (number of data points to approximate)
of the new curve, the length defaults to 4.
</LI>
<LI><CODE>"-alength"</CODE>: number of NURBS control points to use for the
approximating curve, must be smaller than the length above;
this parameter defaults to length-1.
</LI>
<LI><CODE>"-order"</CODE>: order of the new curve, the order defaults to 3.
If a value greater than the output length is specified, the order will be made
identical to the output length value. Currently, only values larger than
2 are supported.
</LI>
<LI><CODE>"-symmetric"</CODE>: toggles creation of symmetric curves,
must be one of 0 &ndash; Asymmetric, 1 &ndash; Symmetric; default is 0.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new curve. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control points. This list may also
only specify one point, which is then taken as starting point and
DX/DY/DZ (see below)
are used to create the missing control points automatically.
To specify a complete
control vector, this list should have curve length&thinsp;&times;&thinsp;3
elements, e.g.&nbsp;for a curve of length 3, specify 9 values:
<CODE>"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new curve. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-dx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension, default is 0.25.
</LI>
<LI><CODE>"-dy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension, default is 0.0.
</LI>
<LI><CODE>"-dz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension, default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new curve will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb ACurve -length 6"</CODE></B><BR>
creates an approximating curve from six data points: 0 0 0, 0.25 0 0, 0.5 0 0,
0.75 0 0, 1 0 0, 1.25 0 0.</LI>
<LI><B><CODE>"crtOb ACurve -l 5 -center 1"</CODE></B><BR>
creates a centered approximating curve from five data points: -0.5 0 0,
-0.25 0 0, 0 0 0, 0.25 0 0, 0.5 0 0.</LI>
</OL>

<P>In versions of Ayam prior to 1.17, approximating curves only accepted the
<CODE>"-length"</CODE> argument.</P>
<P>See also section 
<A HREF="ayam-4.html#acurveobj">ACurve Object</A>.</P>




</LI>
<LI><CODE>"<B>NPatch</B>"</CODE>: NURBS patches accept the following
arguments:
<A NAME="sccrtnp"></A> 
<UL>
<LI><CODE>"-width"</CODE>: width of the new patch, the width defaults to 4.</LI>
<LI><CODE>"-height"</CODE>: height of the new patch, the height defaults to 4.</LI>
<LI><CODE>"-uorder"</CODE>: order of the new patch in U parametric dimension,
the order defaults to 4. If a value greater than the width is specified,
the order will be made identical to the width value.</LI>
<LI><CODE>"-ukt"</CODE>: the U knot type of the new patch, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <CODE>"-ukv"</CODE> option below,
the knot type will always be set to 3 &ndash; Custom.</LI>
<LI><CODE>"-ukv"</CODE>: the U knot vector of the new patch. The value of this
option is a list of floating point numbers of length width plus
patch U order, e.g.&nbsp;for a patch with width 2 and U order 2, specify
4 knots: <CODE>"-ukv {0.0 0.0 1.0 1.0}"</CODE>. The knot vector defaults to
an automatically created knot vector of the type specified by the
<CODE>"-ukt"</CODE> option above.
</LI>
<LI><CODE>"-un"</CODE>: the U knot vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-ukv"</CODE> option
above.
</LI>
<LI><CODE>"-vorder"</CODE>: order of the new patch in V parametric dimension,
the order defaults to 4. If a value greater than the height is specified,
the order will be made identical to the height value.</LI>
<LI><CODE>"-vkt"</CODE>: the V knot type of the new patch, must be one of
0 &ndash; Bezier, 1 &ndash; BSpline, 2 &ndash; NURB, 3 &ndash; Custom,
4 &ndash; Chordal, 5 &ndash; Centripetal.
A knot vector of specified type will automatically be created.
The knot type defaults to 2 &ndash; NURB.
If a custom knot vector is specified using the <CODE>"-vkv"</CODE> option below,
the knot type will always be set to 3 &ndash; Custom.</LI>
<LI><CODE>"-vkv"</CODE>: the V knot vector of the new patch. The value of this
option is a list of floating point numbers of length height plus
patch V order, e.g.&nbsp;for a patch with height 2 and V order 2, specify
4 knots: <CODE>"-vkv {0.0 0.0 1.0 1.0}"</CODE>. The knot vector defaults to
an automatically created knot vector of the type specified by the
<CODE>"-vkt"</CODE> option above.
</LI>
<LI><CODE>"-vn"</CODE>: the V knot vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-vkv"</CODE> option
above.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new patch. The value of this
option is a list of floating point numbers that describe the 4D euclidean
rational (weight <EM>not</EM> multiplied in) coordinates of the control
points.
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.
To specify a complete control vector, this list should have
width&thinsp;&times;&thinsp;height&thinsp;&times;&thinsp;4 elements,
e.g.&nbsp;for a patch of width 2 and height 2, specify 16 values:
<CODE>"-cv {0.0 0.0 0.0 1.0  1.0 0.0 0.0 1.0  2.0 0.0 0.0 1.0  2.0 1.0 0.0 1.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-udx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.
</LI>
<LI><CODE>"-udy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-udz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-vdx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-vdy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.
</LI>
<LI><CODE>"-vdz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
<LI><CODE>"-createmp"</CODE>: The <CODE>"-createmp"</CODE> option toggles creation
of multiple points. The default value is 0.</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb NPatch"</CODE></B><BR>
creates a flat patch with width 4, height 4, uorder 4, vorder 4,
standard (clamped) NURBS knot vectors, control points arranged in a
equidistant grid in the XY-plane from 0 0 0 to 0.75 0.75 0 (all weights 1).</LI>
<LI><B><CODE>"crtOb NPatch -vdy 0 -vdz 0.25"</CODE></B><BR>
creates the same patch as above in the XZ-plane (ground plane).</LI>
<LI><B><CODE>"crtOb NPatch -udy 0.25"</CODE></B><BR>
creates a sheared version of the standard NURBS patch in the XY-plane.</LI>
<LI><B><CODE>"crtOb NPatch -udy 0.25 -vdz 0.25"</CODE></B><BR>
creates a 3D sheared version of the standard NURBS patch.</LI>
<LI><B><CODE>"crtOb NPatch -width 2 -height 2 -center 1 -udx 2 -vdy 2"</CODE></B><BR>
creates a centered patch with width 2, height 2, uorder 2, vorder 2,
standard (clamped) NURBS knot vectors, control points at -1 0 0, 1 0 0,
-1 1 0, 1 1 0 (all weights 1).</LI>
<LI><B><CODE>"crtOb NPatch -width 3 -height 2 -uorder 2 -cv {-1 0 1 1  1 0 1 1  -1 0 0 1  1 0 0 1  -1 1 0 1  1 1 0 1}"</CODE></B><BR>
creates a angular patch in the XZ- and XY-plane (remove <CODE>-uorder 2</CODE> to get
a smooth shape).</LI>
</OL>


<P>In versions of Ayam prior to 1.17, NURBS patches only accepted the
<CODE>"-width"</CODE> and <CODE>"-height"</CODE> argument.</P>
<P>See also section 
<A HREF="ayam-4.html#npatchobj">NPatch Object</A>.</P>





</LI>
<LI><CODE>"<B>IPatch</B>"</CODE>: Interpolating patches accept the following
arguments:
<A NAME="sccrtip"></A> 
<UL>
<LI><CODE>"-width"</CODE>: width of the new patch, the width defaults to 4.</LI>
<LI><CODE>"-height"</CODE>: height of the new patch, the height defaults to 4.</LI>
<LI><CODE>"-uorder"</CODE>: order of the new patch in U parametric dimension,
the order defaults to 4. If a value greater than the width is specified,
the order will be made identical to the width value.
A value of 0 switches off interpolation along U.</LI>
<LI><CODE>"-ukt"</CODE>: the U parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal, 2 &ndash; Uniform.</LI>
<LI><CODE>"-vorder"</CODE>: order of the new patch in V parametric dimension,
the order defaults to 4. If a value greater than the height is specified,
the order will be made identical to the height value.
A value of 0 switches off interpolation along V.</LI>
<LI><CODE>"-vkt"</CODE>: the V parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal, 2 &ndash; Uniform.
</LI>
<LI><CODE>"-deriv_u"</CODE>: the end derivative mode for U, must be one of
0 &ndash; None (default), 1 &ndash; Automatic, or 2 &ndash; Manual.
In manual mode full derivative vectors must be provided via
<CODE>"-ederiv_u"</CODE> <EM>and</EM> <CODE>"-sderiv_u"</CODE>.</LI>
<LI><CODE>"-edlen_u"</CODE>: the length of automatically calculated end
derivatives at end of patch in U (default 0.125).</LI>
<LI><CODE>"-sdlen_u"</CODE>: the length of automatically calculated end
derivatives at start of patch in U (default 0.125).</LI>
<LI><CODE>"-ederiv_u"</CODE>: end derivatives for U at end of patch.
The value of this option is a list of 3&thinsp;&times;&thinsp;height
floating point numbers.
There is no default value.</LI>
<LI><CODE>"-sderiv_u"</CODE>: end derivatives for U at start of patch.
The value of this option is a list of 3&thinsp;&times;&thinsp;height
floating point numbers.
There is no default value.
</LI>
<LI><CODE>"-deriv_v"</CODE>: the end derivative mode for V, must be one of
0 &ndash; None (default), 1 &ndash; Automatic, or 2 &ndash; Manual.
In manual mode full derivative vectors must be provided via
<CODE>"-ederiv_v"</CODE> <EM>and</EM> <CODE>"-sderiv_v"</CODE>.</LI>
<LI><CODE>"-edlen_v"</CODE>: the length of automatically calculated end
derivatives at end of patch in V (default 0.125).</LI>
<LI><CODE>"-sdlen_v"</CODE>: the length of automatically calculated end
derivatives at start of patch in V (default 0.125).</LI>
<LI><CODE>"-ederiv_v"</CODE>: end derivatives for V at end of patch.
The value of this option is a list of 3&thinsp;&times;&thinsp;width
floating point numbers.
There is no default value.</LI>
<LI><CODE>"-sderiv_v"</CODE>: end derivatives for V at start of patch.
The value of this option is a list of 3&thinsp;&times;&thinsp;width
floating point numbers.
There is no default value.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new patch. The value of this
option is a list of floating point numbers that describe the 3D
non rational coordinates of the data points to be interpolated.<BR>
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.<BR>
To specify a complete control vector, this list should have
width&thinsp;&times;&thinsp;height&thinsp;&times;&thinsp;3 elements,
e.g.&nbsp;for a patch of width 2 and height 2, specify 12 values:
<CODE>"-cv {0.0 0.0 0.0  1.0 0.0 0.0  2.0 0.0 0.0  2.0 1.0 0.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-udx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.
</LI>
<LI><CODE>"-udy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-udz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-vdx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-vdy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.
</LI>
<LI><CODE>"-vdz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb IPatch"</CODE></B><BR>
creates a flat patch with width 4, height 4, uorder 4, vorder 4,
chordal parameterisation, data points arranged in a
equidistant grid in the XY-plane from 0 0 0 to 0.75 0.75 0.</LI>
<LI><B><CODE>"crtOb IPatch -vdy 0 -vdz 0.25"</CODE></B><BR>
creates the same patch as above in the XZ-plane (ground plane).</LI>
<LI><B><CODE>"crtOb IPatch -udy 0.25"</CODE></B><BR>
creates a sheared version of the standard IPatch in the XY-plane.</LI>
<LI><B><CODE>"crtOb IPatch -udy 0.25 -vdz 0.25"</CODE></B><BR>
creates a 3D sheared version of the standard IPatch.</LI>
<LI><B><CODE>"crtOb IPatch -width 3 -height 3 -center 1 -udx 2 -vdy 2"</CODE></B><BR>
creates a centered patch with width 3, height 3, uorder 3, and vorder 3.</LI>
</OL>


<P>See also section 
<A HREF="ayam-4.html#ipatchobj">IPatch Object</A>.</P>





</LI>
<LI><CODE>"<B>APatch</B>"</CODE>: Approximating patches accept the following
arguments:
<A NAME="sccrtap"></A> 
<UL>
<LI><CODE>"-mode"</CODE>: the value of this option specifies the approximation
mode, it must be one of 0 - UV, 1 - VU, 2 - U, or 3 - V.</LI>
<LI><CODE>"-width"</CODE>: number of data points in U direction, the width defaults to 4.</LI>
<LI><CODE>"-height"</CODE>: number of data points in V direction, the height defaults to 4.</LI>
<LI><CODE>"-awidth"</CODE>: desired width of the NURBS patch approximating
the data points, defaults to 3.
This value must be &lt;= the width.</LI>
<LI><CODE>"-aheight"</CODE>: desired height of the NURBS patch approximating
the data points, defaults to 3.
This value must be &lt;= the height.</LI>
<LI><CODE>"-uorder"</CODE>: order of the new patch in U parametric dimension,
the order defaults to 3. If a value greater than awidth is specified,
the order will be made identical to the awidth value.</LI>
<LI><CODE>"-ukt"</CODE>: the U parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal.</LI>
<LI><CODE>"-vorder"</CODE>: order of the new patch in V parametric dimension,
the order defaults to 3. If a value greater than aheight is specified,
the order will be made identical to the aheight value.</LI>
<LI><CODE>"-vkt"</CODE>: the V parameterisation type, must be one of
0 &ndash; Chordal (default), 1 &ndash; Centripetal.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new patch. The value of this
option is a list of floating point numbers that describe the 3D
non rational coordinates of the data points to be approximated.<BR>
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.<BR>
To specify a complete control vector, this list should have
width&thinsp;&times;&thinsp;height&thinsp;&times;&thinsp;3 elements,
e.g.&nbsp;for a patch of width 4 and height 4, specify 48 values.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new patch. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-udx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.
</LI>
<LI><CODE>"-udy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-udz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-vdx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-vdy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.
</LI>
<LI><CODE>"-vdz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb APatch"</CODE></B><BR>
creates a flat patch with width 4, height 4, awidth 3, aheight 3, uorder 3,
vorder 3,
chordal parameterisation, data points arranged in a
equidistant grid in the XY-plane from 0 0 0 to 0.75 0.75 0.</LI>
<LI><B><CODE>"crtOb APatch -vdy 0 -vdz 0.25"</CODE></B><BR>
creates the same patch as above in the XZ-plane (ground plane).</LI>
<LI><B><CODE>"crtOb APatch -udy 0.25"</CODE></B><BR>
creates a sheared version of the standard APatch in the XY-plane.</LI>
<LI><B><CODE>"crtOb APatch -udy 0.25 -vdz 0.25"</CODE></B><BR>
creates a 3D sheared version of the standard APatch.</LI>
<LI><B><CODE>"crtOb APatch -width 3 -height 3 -center 1 -udx 2 -vdy 2"</CODE></B><BR>
creates a centered patch with width 3, height 3, uorder 3, and vorder 3.</LI>
</OL>


<P>See also section 
<A HREF="ayam-4.html#apatchobj">APatch Object</A>.</P>




</LI>
<LI><B><CODE>"PatchMesh"</CODE></B>: patch meshes accept the following
arguments:
<A NAME="sccrtpm"></A> 
<UL>
<LI><CODE>"-type"</CODE>: type of the new patch mesh, must be one of
0 &ndash; bilinear or 1 &ndash; bicubic, defaults to 1.
</LI>
<LI><CODE>"-width"</CODE>: width of the new patch, the width defaults to 4.
Valid values for bicubic patch meshes depend on closedness and step size
in the U direction. See also the discussion in
section 
<A HREF="ayam-4.html#pmattr">PatchMeshAttr Property</A>.</LI>
<LI><CODE>"-height"</CODE>: height of the new patch, the height defaults to 4.
Valid values for bicubic patch meshes depend on closedness and step size
in the V direction. See also the discussion in
section 
<A HREF="ayam-4.html#pmattr">PatchMeshAttr Property</A>.
</LI>
<LI><CODE>"-closeu"</CODE>: determines, whether the patch mesh is closed in
U direction; must be either 0 &ndash; open (default) or 1 &ndash; closed.</LI>
<LI><CODE>"-closev"</CODE>: determines, whether the patch mesh is closed in
V direction; must be either 0 &ndash; open (default) or 1 &ndash; closed.
</LI>
<LI><CODE>"-ubt"</CODE>: the U basis type, must be one of
0 &ndash; Bezier (default), 1 &ndash; B-Spline, 2 &ndash; Catmull-Rom,
3 &ndash; Hermite, 4 &ndash; Power, 5 &ndash; Custom.</LI>
<LI><CODE>"-vbt"</CODE>: the V basis type, must be one of
0 &ndash; Bezier (default), 1 &ndash; B-Spline, 2 &ndash; Catmull-Rom,
3 &ndash; Hermite, 4 &ndash; Power, 5 &ndash; Custom.
</LI>
<LI><CODE>"-ubasis"</CODE>: the U basis; must be 16 float values in
column major order. If set, the U basis type will automatically set
to Custom and the step size should be specified (if different from 3).
</LI>
<LI><CODE>"-ubn"</CODE>: the U basis. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-ubasis"</CODE> option
above.
</LI>
<LI><CODE>"-vbasis"</CODE>: the V basis; must be 16 float values in
column major order. If set, the V basis type will automatically set
to Custom and the step size should be specified (if different from 3).
</LI>
<LI><CODE>"-vbn"</CODE>: the V basis. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-vbasis"</CODE> option
above.
</LI>
<LI><CODE>"-ustep"</CODE>: the U basis step size; must be 1, 2, 3, or 4.
Can be omitted for all non custom basis types.</LI>
<LI><CODE>"-vstep"</CODE>: the V basis step size; must be 1, 2, 3, or 4.
Can be omitted for all non custom basis types.
</LI>
<LI><CODE>"-cv"</CODE>: the control vector of the new patch mesh. The value of this
option is a list of floating point numbers that describe the 3D
rational coordinates of the control points.<BR>
This list may also only specify one point, which is then taken as starting
point and UDX/UDY/UDZ and VDX/VDY/VDZ (see below) are used to create the
missing control points automatically.<BR>
To specify a complete control vector, this list should have
width&thinsp;&times;&thinsp;height&thinsp;&times;&thinsp;4 elements,
e.g.&nbsp;for a bilinear patch mesh of width 2 and height 2, specify 16 values:
<CODE>"-cv {0.0 0.0 0.0 1.0  1.0 0.0 0.0 1.0  2.0 0.0 0.0 1.0  2.0 1.0 0.0 1.0}"</CODE>.
</LI>
<LI><CODE>"-cn"</CODE>: the control vector of the new patch mesh. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-udx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a row (U parametric dimension, along width), default is 0.25.
</LI>
<LI><CODE>"-udy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-udz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a row (U parametric dimension, along width), default is 0.0.
</LI>
<LI><CODE>"-vdx"</CODE>: the value of this option specifies the distance
of automatically created control points in the x dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-vdy"</CODE>: the value of this option specifies the distance
of automatically created control points in the y dimension between points
in a column (V parametric dimension, along height), default is 0.25.
</LI>
<LI><CODE>"-vdz"</CODE>: the value of this option specifies the distance
of automatically created control points in the z dimension between points
in a column (V parametric dimension, along height), default is 0.0.
</LI>
<LI><CODE>"-center"</CODE>: If the value of the <CODE>"-center"</CODE> option is 1,
the new patch will be centered. The default value is 0, no centering.
This option is only in effect if no <CODE>"-cv"</CODE> option is specified.
</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb PatchMesh"</CODE></B><BR>
creates a flat bicubic patch mesh of width 4, height 4,
Bezier basis, control points arranged in a
equidistant grid in the XY plane from 0 0 0 to 0.75 0.75 0.</LI>
<LI><B><CODE>"crtOb PatchMesh -vdy 0 -vdz 0.25"</CODE></B><BR>
creates the same patch mesh as above in the XZ plane (ground plane).</LI>
<LI><B><CODE>"crtOb PatchMesh -udy 0.25"</CODE></B><BR>
creates a sheared version of the standard patch mesh in the XY plane.</LI>
<LI><B><CODE>"crtOb PatchMesh -udy 0.25 -vdz 0.25"</CODE></B><BR>
creates a 3D sheared version of the standard patch mesh.</LI>
<LI><B><CODE>"crtOb PatchMesh -type 0 -width 3 -height 3 -center 1 -udx 2 -vdy 2"</CODE></B><BR>
creates a large centered bilinear patch mesh of width 3 and height 3.</LI>
</OL>


<P>See also section 
<A HREF="ayam-4.html#patchmeshobj">PatchMesh Object</A>.</P>



</LI>
<LI><CODE>"<B>PolyMesh</B>"</CODE>: Polygonal meshes accept the following
arguments:
<UL>
<LI><CODE>"-polys"</CODE>: the value of this option specifies the number of
polygons/faces in the mesh. The number of polygons defaults to 0.
</LI>
<LI><CODE>"-loops"</CODE>: the value of this option specifies the number of
loops per polygon. It is therefore a list of positive integer values of a
length equal to the value of the <CODE>"-polys"</CODE> option. The default value
of this option is a list of proper length with all elements set to 1
(only normal polygons, without holes, are specified).
</LI>
<LI><CODE>"-nverts"</CODE>: the value of this option specifies the number of
vertices per loop. It is therefore a list of positive integer
values of a length equal to the sum of all elements of the <CODE>"-loops"</CODE>
option.
The default value of this option is a list of proper length with all
elements set to 3 (only triangles are in the mesh).
</LI>
<LI><CODE>"-iverts"</CODE>: the value of this option specifies all the (zero
based) indices of the vertices of all loops. It is therefore a list of
integer values of a length equal to the sum of all elements of the
<CODE>"-nverts"</CODE> option.
The default value of this option is a list of proper length with the
elements set to a sequence of integers so that the control points are
used in the same order as specified via the <CODE>"-cv"</CODE> option
(0, 1, 2, 3, ...).
</LI>
<LI><CODE>"-cv"</CODE>: the control points of the new mesh. The value of this
option is a list of floating point numbers that describe the 3D
(non rational) coordinates of the control
points. The indices specified via the <CODE>"-iverts"</CODE> option point to
this list. If the <CODE>"-vnormals"</CODE> option is 1, also vertex normals are
specified in this list (directly following the coordinate values of each
control point) and stride is 6, otherwise stride is 3.
This list must have a length of stride by the highest value in
the list provided via the <CODE>"-iverts"</CODE> option.
The default value of this option is an empty list, this implies that this
option must be specified to create a non-empty PolyMesh object.
</LI>
<LI><CODE>"-cn"</CODE>: the control points of the new mesh. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-vnormals"</CODE>: determines whether vertex normals are present.
The default value is 0 &ndash; no vertex normals are present.
</LI>
</UL>

<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb PolyMesh -p 1 -cv {0 0 0  1 0 0  0 1 0}"</CODE></B><BR>
creates a polymesh with a single triangular face.
</LI>
<LI><B><CODE>"crtOb PolyMesh -p 2 -cv {0 0 0  1 0 0  1 1 0  0 1 0} -iv {0 1 2 0 2 3}"</CODE></B><BR>
creates a polymesh with two connected (vertex sharing) triangular faces.
</LI>
<LI><B><CODE>"crtOb PolyMesh -p 3 -cv {0 0 0  1 0 0  1 1 0  0 1 0  1.5 0 0  1.5 1 0} -iv {0 1 2 0 2 3 1 4 5 2} -nv {3 3 4}"</CODE></B><BR>
creates a polymesh with two triangles and one quad all connected
(vertex sharing).
</LI>
<LI><B><CODE>"crtOb PolyMesh -p 1 -loops {2} -cv {0 0 0  1 0 0  0 1 0  .25 .25 0  .5 .25 0  .25 .5 0}"</CODE></B><BR>
creates a polymesh with one triangular face that has a triangular hole.</LI>
</OL>

Notes:<SUP>&nbsp;</SUP><BR>
Besides checking the lengths of arrays, maximum indices, and minimum
number of vertices per loop, there is <EM>no</EM> error checking.
Undetected errors include: degenerated or non-planar polygons,
hole loops geometrically outside or touching the outline loop, disagreeing
loop winding orders between faces, non-manifold meshes, unused control points.
Those errors may be problematic for further processing steps &ndash; some
may even go unnoticed in Ayam and will only be detected later in other
applications.<BR>
See also section 
<A HREF="ayam-4.html#polymeshobj">PolyMesh Object</A>.
<SUP>&nbsp;</SUP><BR>


<UL style="list-style: none; ">
<LI>&nbsp;</LI>
</UL>

</LI>
<LI><CODE>"<B>SDMesh</B>"</CODE>: Subdivision meshes accept the following
arguments:
<UL>
<LI><CODE>"-scheme"</CODE>: the value of this option specifies the subdivision
scheme, it may be set to 0 &ndash; Catmull-Clark or 1 &ndash; Loop only.
Default is 0.
</LI>
<LI><CODE>"-faces"</CODE>: the value of this option specifies the number of
faces in the mesh. The number of faces defaults to 0.
</LI>
<LI><CODE>"-nverts"</CODE>: the value of this option specifies the number of
vertices per face. It is therefore a list of positive integer
values of a length equal to the number of faces.
The default value of this option is a list of proper length with all
elements set to 3 (only triangles are in the mesh).
</LI>
<LI><CODE>"-verts"</CODE>: the value of this option specifies all the (zero
based) indices of the vertices of all faces. It is therefore a list of
integer values of a length equal to the sum of all elements of the
<CODE>"-nverts"</CODE> option.
The default value of this option is a list of proper length with the
elements set to a sequence of integers so that the control points are
used in the same order as specified via the <CODE>"-cv"</CODE> option
(0, 1, 2, 3, ...).
</LI>
<LI><CODE>"-cv"</CODE>: The value of this option is a list of floating point
numbers that describe the 3D (non rational) coordinates of the control
points. The indices specified via the <CODE>"-verts"</CODE> option point to
this list.
This list must have a length of 3 multiplied by the highest value in
the list provided via the <CODE>"-verts"</CODE> option.
The default value of this option is an empty list, this implies that this
option must be specified to create a non-empty SDMesh object.
</LI>
<LI><CODE>"-cn"</CODE>: the control points of the new mesh. The value of
this option is a variable name (with optional array and namespace specifier).
The value of this variable must be compatible to the <CODE>"-cv"</CODE> option
above.
</LI>
<LI><CODE>"-tags"</CODE>: the value of this option specifies a number of tags.
It is therefore a list of positive integer values of arbitrary length.
The only allowed values are 0 &ndash; hole, 1 &ndash; corner,
2 &ndash; crease, and 3 &ndash; interpolateboundary.
The default value of this option is an empty list: no tags.
</LI>
<LI><CODE>"-args"</CODE>: the value of this option specifies the number of
integer and floating point arguments per tag.
It is therefore a list of positive integer values of length:
double number of tags. The even entries specify the number of integer and
the odd entries the number of floating point arguments per tag.
The content of this list is partially dictated by the <CODE>"-tags"</CODE>
option, e.g.&nbsp;a crease entry has at least two integer arguments and one
floating point argument.
The default value of this option is list of proper length, with all
elements set to zero (no tags have any arguments).
</LI>
<LI><CODE>"-intargs"</CODE>: the value of this option specifies the
integer arguments of all tags.
It is therefore a list of integer values of length
sum of all even elements given by the <CODE>"-args"</CODE> option.
</LI>
<LI><CODE>"-doubleargs"</CODE>: the value of this option specifies the
floating point arguments of all tags.
It is therefore a list of double values of length
sum of all odd elements given by the <CODE>"-args"</CODE> option.
</LI>
</UL>



<SUP>&nbsp;</SUP>
Examples:
<OL>
<LI><B><CODE>"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5}"</CODE></B><BR>
creates a tetrahedral (four triangular faces) mesh.</LI>
<LI><B><CODE>"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5} -tags {1} -args {1 1} -intargs {0} -doubleargs {3.0}"</CODE></B><BR>
creates a tetrahedral mesh with a semi-sharp corner.</LI>
<LI><B><CODE>"crtOb SDMesh -f 4 -v {0 1 3  1 2 3  0 3 2  0 2 1} -cv {0 0 0  1 0 0  0 0 -1  0.5 1 -0.5} -tags {1} -args {2 1} -intargs {0 1} -doubleargs {10.0}"</CODE></B><BR>
creates a tetrahedral mesh with a crease.</LI>
</OL>


Notes:<SUP>&nbsp;</SUP><BR>
Besides checking the lengths of arrays, maximum indices, and minimum
number of vertices per face, there is <EM>no</EM> error checking.
Undetected errors include: degenerated or non-planar faces,
faces with unsuitable vertex counts (for the selected subdivision scheme),
non-manifold meshes, unused control points, wrong tag arguments.
Those errors may be problematic for further processing steps &ndash; some
may even go unnoticed in Ayam and will only be detected later in other
applications.<BR>
See also section 
<A HREF="ayam-4.html#sdmeshobj">SDMesh Object</A>.
<SUP>&nbsp;</SUP><BR>


<UL style="list-style: none; ">
<LI>&nbsp;</LI>
</UL>

</LI>
<LI><CODE>"<B>Script</B>"</CODE>: Script objects accept the following
arguments:<SMALL TITLE="Since 1.29."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
<UL>
<LI><CODE>"-type"</CODE>: the value of this option specifies the script
type, it may be set to <CODE>"run"</CODE>, <CODE>"modify"</CODE>, or
<CODE>"create"</CODE> (without quotes) only.
</LI>
<LI><CODE>"-active"</CODE>: the value of this option specifies whether
to activate the script immediately or not. It may be set to
<CODE>"yes"</CODE>, <CODE>"no"</CODE>, 0, or 1.
</LI>
<LI><CODE>"-script"</CODE>: the value of this option is the script code
itself.
</LI>
<LI><CODE>"-file"</CODE>: the value of this option is the full path and
file name of a script to load into the new Script object.
</LI>
</UL>

See also section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>.

<SUP>&nbsp;</SUP>
<UL style="list-style: none; ">
<LI>&nbsp;</LI>
</UL>

</LI>
<LI><CODE>"<B>Level</B>"</CODE>: these objects can be given an
additional type argument, this argument
may be one of:
<CODE>"0"</CODE> (level - default), <CODE>"1"</CODE> (union), <CODE>"2"</CODE> (intersection),
<CODE>"3"</CODE> (difference), or <CODE>"4"</CODE> (primitive).

<P>Examples:
<OL>
<LI><B><CODE>"crtOb Level"</CODE></B><BR>
creates a simple level object.</LI>
<LI><B><CODE>"crtOb Level 3"</CODE></B><BR>
creates a CSG difference level object.</LI>
</OL>
</P>
<P>See also section 
<A HREF="ayam-4.html#levelobj">Level Object</A>.</P>

</LI>
<LI><CODE>"<B>Material</B>"</CODE>: Materials must be given an additional
argument giving the name of the new material.
<P>If a material with the chosen name already exists, no object will be created.</P>

<P>Example:
<OL>
<LI><B><CODE>"crtOb Material Wood"</CODE></B><BR>
creates a material named Wood.</LI>
</OL>
</P>
<P>See also section 
<A HREF="ayam-4.html#materialobj">Material Object</A>.</P>

</LI>
<LI><CODE>"<B>Instance</B>"</CODE>: creates an instance of the selected object.

<P>Example:
<OL>
<LI><B><CODE>"crtOb Sphere; selOb -1; crtOb Instance"</CODE></B><BR>
creates a Sphere and an instance of it.</LI>
</OL>
</P>

<P>See also section 
<A HREF="ayam-4.html#instanceobj">Instance Object</A>.</P>

</LI>
<LI>...</LI>
</UL>
</P>
</LI>
<LI>Example: Create a sphere and update the GUI:
<CODE>"crtOb Sphere; uS; rV"</CODE>.</LI>
</UL>
</P>
<P><SUB><BR></SUB>
There are some helper commands, that create certain often used
curves:</P>


<P>crtNCircle &ndash; create NURBS circle:
<A NAME="sccrtncircle"></A> 
<UL>
<LI>Synopsis: <CODE>"crtNCircle [-r radius] [-a arc]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command creates a circular NURBS curve
with radius as defined via the <CODE>-r</CODE> option and arc as
defined via the <CODE>-a</CODE> option. The curve always starts on the
positive X-axis. The radius defaults to 1.0 and
the arc to 360.0. The arc option supports negative values.
<P>See also section 
<A HREF="ayam-5.html#ncirct">NURB Circle Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccrtclosedbs"></A> 
crtClosedBS &ndash; create closed (circular) B-Spline:
<UL>
<LI>Synopsis: <CODE>"crtClosedBS [-s sections] [-o order] [-a arc] [-r radius]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command creates a circular B-Spline curve
with desired number of sections (defaults to 6), order (defaults to 4),
arc (defaults to 360.0, negative values are allowed), and
radius (defaults to 1.0). The curve always starts on the positive X-axis.
<P>See also section 
<A HREF="ayam-5.html#cbspt">Circular B-Spline Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccrtnrect"></A> 
crtNRect &ndash; create a rectangular NURBS curve:
<UL>
<LI>Synopsis: <CODE>"crtNRect [-w width] [-h height]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command creates a centered rectangular NURBS curve
of twice the given width and height in the XY-plane.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccrttrimrect"></A> 
crtTrimRect &ndash; create a rectangular bounding trim curve:
<UL>
<LI>Synopsis: <CODE>"crtTrimRect"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command creates a rectangular NURBS curve
that fits the parameter space of the currently selected NPatch
object (or the current parent object, if it is a NPatch).
The <CODE>"CreateAt"</CODE> and <CODE>"CreateIn"</CODE> options are ignored.
<P>See also section 
<A HREF="ayam-5.html#trrt">TrimRect Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scdelob"></A> 
delOb &ndash; delete object(s):
<UL>
<LI>Synopsis: <CODE>"delOb"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Delete the selected object(s) and their children
from the scene.
This operation fails for the root object.
This operation may fail for master objects (objects with instances/references)
or for parent objects with master objects among their children.
In case of failure, an error will be reported and the undeletable object(s)
will be moved to the end of the current level. The root object, however,
will never be moved.

See also the 
<A HREF="#sccandelob">candelOb scripting interface command</A>.</LI>
</UL>
</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scintob"></A> Interrogating Objects</H3>


<P>These commands help to inquire objects about various aspects.</P>
<P>
<A NAME="scgettype"></A> 
getType:
<UL>
<LI>Synopsis: <CODE>"getType [varname]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command writes the type of the
selected object into the variable designated by the <CODE>varname</CODE> argument.
The types are the well known strings that are displayed in the hierarchy
list box if the objects are not named (NPatch, NCurve, Sphere, etc.).
If no variable name is specified the command returns the respective result(s).<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgetname"></A> 
getName:
<UL>
<LI>Synopsis: <CODE>"getName [-s] [varname]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command writes the name of the
selected object into the variable designated by the <CODE>varname</CODE>
argument. If the object has no name, a warning message will be
emitted (unless the option <CODE>"-s"</CODE> is given).
If no variable name is specified the command returns the respective result(s).<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.<BR>
See also section 
<A HREF="#scnameob">nameOb scripting interface command</A>.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="schaschild"></A> 
hasChild:
<UL>
<LI>Synopsis: <CODE>"hasChild"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
has child objects, otherwise <CODE>0</CODE> is returned. If multiple objects are
selected, a list is returned.</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="schasmat"></A> 
hasMat &ndash; has material:
<UL>
<LI>Synopsis: <CODE>"hasMat"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
has a material assigned, otherwise <CODE>0</CODE> is returned. If multiple objects are
selected, a list is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="schasrefs"></A> 
hasRefs &ndash; has references:
<UL>
<LI>Synopsis: <CODE>"hasRefs"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
has references (e.g.&nbsp;it is a master), otherwise <CODE>0</CODE> is returned.
If multiple objects are selected, a list is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccandelob"></A> 
candelOb &ndash; delete object(s):
<UL>
<LI>Synopsis: <CODE>"candelOb"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object(s)
can be deleted without errors and without moving objects to the end of
the current level, otherwise <CODE>0</CODE> is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="schastrafo"></A> 
hasTrafo &ndash; has transformations:
<UL>
<LI>Synopsis: <CODE>"hasTrafo [-r</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-t]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
has non-default transformation attributes, otherwise <CODE>0</CODE> is returned.
If multiple objects are selected, a list is returned.<BR>
If the <CODE>"-r"</CODE> flag is provided, the command only checks the rotation
attributes.<BR>
If the <CODE>"-s"</CODE> flag is provided, the command only checks the scale
attributes.<BR>
If the <CODE>"-t"</CODE> flag is provided, the command only checks the translation
attributes.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sciscurve"></A> 
isCurve:
<UL>
<LI>Synopsis: <CODE>"isCurve"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is (or provides&thinsp;/&thinsp;converts to) a parametric curve, otherwise
<CODE>0</CODE> is returned.
If multiple objects are selected, a list is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scissurface"></A> 
isSurface:
<UL>
<LI>Synopsis: <CODE>"isSurface"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is (or provides&thinsp;/&thinsp;converts to) a parametric surface, otherwise
<CODE>0</CODE> is returned.
If multiple objects are selected, a list is returned.</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="scgetbb"></A> 
getBB &ndash; get the bounding box:
<UL>
<LI>Synopsis: <CODE>"getBB"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns the axis parallel bounding box
of the selected object(s) as a list of six double values (xmin, ymin, zmin,
xmax, ymax, zmax). Note, that for multiple selected objects the union
of all individual bounding boxes will be returned and <EM>not</EM> the
individual bounding boxes in a list.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgetplanenormal"></A> 
getPlaneNormal &ndash; get the plane normal of an object:
<UL>
<LI>Synopsis: <CODE>"getPlaneNormal [-t]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns the plane normal(s)
of the selected object(s) as a list of three double values.<BR>
If the option <CODE>"-t"</CODE> is given, the normal will be transformed
by the objects transformation attributes.

<P>If the object is not planar, a mean normal will be computed.
If the normal can not be computed because e.g.&nbsp;the selected curve is a
straight line or degenerate the returned vector
will be 0.0, 0.0, 0.0.</P>
<P>This command supports arbitrary object types that just need to
provide their points.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scisclosed"></A> 
isClosed:
<UL>
<LI>Synopsis: <CODE>"isClosed [-u</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-v]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is a closed parametric curve or surface,
otherwise <CODE>0</CODE> is returned.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
<P>The optional parameter <CODE>"-u"</CODE>/<CODE>"-v"</CODE> determines which dimension
of a surface to check.</P>
<P>If multiple objects are selected, a list is returned.</P>

<P>This command supports arbitrary object types that just need to
provide NURBS curves or surfaces.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scisplanar"></A> 
isPlanar &ndash; check for planarity:
<UL>
<LI>Synopsis: <CODE>"isPlanar"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is a planar parametric curve or surface,
otherwise <CODE>0</CODE> is returned.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.

<P>This command supports arbitrary object types that just need to
provide NURBS curves or surfaces.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scisdegen"></A> 
isDegen &ndash; check for degeneracy:
<UL>
<LI>Synopsis: <CODE>"isDegen"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is a degenerated parametric curve (point shape) or surface (point or line
shape), otherwise <CODE>0</CODE> is returned.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.

<P>This command supports arbitrary object types that just need to
provide NURBS curves or surfaces.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scisparent"></A> 
isParent:
<UL>
<LI>Synopsis: <CODE>"isParent"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is a potential parent, otherwise <CODE>0</CODE> is
returned.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scistrimmed"></A> 
isTrimmed:
<UL>
<LI>Synopsis: <CODE>"isTrimmed"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is a non trivially trimmed parametric surface, otherwise
<CODE>0</CODE> is returned.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.

<P>This command supports arbitrary object types that just need to
provide a NURBS surface.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scishidden"></A> 
isHidden:
<UL>
<LI>Synopsis: <CODE>"isHidden"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected object
is hidden, otherwise
<CODE>0</CODE> is returned.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If multiple objects are selected, a list is returned.

<P>This command supports arbitrary object types that just need to
provide a NURBS surface.</P>
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciselob"></A> Selecting Objects</H3>

<P>These commands are probably the most important ones, because many other
scripting interface commands operate on selected objects only:</P>


<P>
<A NAME="scselob"></A> 
selOb &ndash; select object(s):
<UL>
<LI>Synopsis: <CODE>"selOb ([-get</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-end</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-clear] | [index] | [first-last])"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Use this command to set or clear the current
selection, <CODE>index</CODE> may be a single (zero based) index, an ordered list of
indices or a range.<BR>
If the <CODE>"-get"</CODE> option is specified, the current
selection will be returned just as the <CODE>"getSel"</CODE> command does.<BR>
If no index is given or the <CODE>"-clear"</CODE> option is specified, the current
selection will be cleared.<BR>
If the single index is -1 or the <CODE>"-end"</CODE> option is specified, the last
object in the current level will be selected.</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"selOb"</CODE></B><SUP>&nbsp;</SUP><BR>
clears the current selection,</LI>
<LI><B><CODE>"selOb 0"</CODE></B><BR>
selects the first object in the current level,</LI>
<LI><B><CODE>"selOb 0 1"</CODE></B><BR>
selects the first two objects in the current level, and</LI>
<LI><B><CODE>"selOb 0 3-8"</CODE></B><BR>
selects the first and the fourth up to the ninth objects in the current
level, and</LI>
<LI><B><CODE>"selOb 1-end"</CODE></B><BR>
selects all objects in the current level except for the first.</LI>
</OL>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scsl"></A> 
sL &ndash; select last object:
<UL>
<LI>Synopsis: <CODE>"sL [count]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Select the last object in the current level
and, if run in the Ayam interpreter, update the GUI.<BR>
If an argument is provided, it determines the number of objects to select.<BR>
If run in the safe interpreter (e.g.&nbsp;from a Script objects script)
this command will create a hidden selection.
This command is often called in a sequence
after creating a new object like this:
<HR>
<PRE>
# create object
crtOb NCurve
# update tree
uCR
# select new object
sL
</PRE>
<HR>


In Script objects scripts the above example command sequence would leave out
the <CODE>"uCR"</CODE> command, as access to the GUI is blocked anyway in this
context:
<HR>
<PRE>
# create object
crtOb NCurve
# select new object
sL
</PRE>
<HR>
</LI>
<LI>Note: In the main Tcl interpreter, <CODE>sL</CODE> is a procedure that operates
on information in the Tcl context alone.
Calling <CODE>sL</CODE> on outdated hierarchy data (e.g.&nbsp;by leaving out <CODE>uS</CODE> or
<CODE>uCR</CODE> after object creation) will possibly lead to the wrong objects
being selected.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="schsl"></A> 
hSL &ndash; hidden select last object:
<UL>
<LI>Synopsis: <CODE>"hSL [count]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Select the last object in the current level
but do not update the GUI.<BR>
If an argument is provided, it determines the number of objects to select.<BR>
This command does not need an updated hierarchy in the Tcl context.
In fact it is completely oblivious of the GUI and therefore safe to
use directly after e.g.&nbsp;script based object creation.<BR>
Note: prior to Ayam 1.18 this command used to be available in the
safe interpreter. This is no longer the case, use <CODE>"sL"</CODE> instead.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scsp"></A> 
sP &ndash; hidden select parent object:
<UL>
<LI>Synopsis: <CODE>"sP"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Select the current parent object
but do not update the GUI.<BR>
This command does not need an updated hierarchy in the Tcl context.
In fact it is completely oblivious of the GUI and therefore safe to
use directly after e.g.&nbsp;script based object creation.<BR>
Note that this command is only available in the safe interpreter.
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciselpnts"></A> Selecting Points</H3>

<P>This command manipulates the point selection.</P>


<P>
<A NAME="scselpnts"></A> 
selPnts &ndash; select points:
<UL>
<LI>Synopsis: <CODE>"selPnts [(-count</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-get) [vname] | -has | -all | -none | index1 index2 ...]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description:
<UL>
<LI>If called without arguments, this command deselects all points.</LI>
<LI>If the argument is <CODE>"-count"</CODE>, this command puts the number
of all currently selected points into the variable specified by the
<CODE>"vname"</CODE> argument. If no variable name is provided, the number is
returned.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>If the argument is <CODE>"-get"</CODE>, this command puts the indices
of all currently selected points into the variable specified by the
<CODE>"vname"</CODE> argument. If no variable name is provided, the indices are
returned.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>If the argument is <CODE>"-has"</CODE>, this command returns <CODE>"1"</CODE>
if at least one of the selected objects has selected points. Otherwise <CODE>"0"</CODE>
is returned.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>If the argument is <CODE>"-all"</CODE>, this command selects all points.</LI>
<LI>If the argument is <CODE>"-none"</CODE>, this command de-selects all points.</LI>
<LI>If the argument contains an index, the corresponding point(s) will
be added to the selection; already selected points will not be deselected.
The index is zero-based and always one dimensional (even
for surfaces). Multiple indices may be provided.</LI>
</UL>
</LI>
<LI>Notes:
In contrast to the tag points modelling action, selecting a single point
of a multiple point (of NCurve and NPatch objects) via this command
only selects this single point.</LI>
<LI>Examples: Given that a single NCurve object is selected,
<OL>
<LI><B><CODE>"selPnts -all"</CODE></B><SUP>&nbsp;</SUP><BR>
selects all points of the curve, and</LI>
<LI><B><CODE>"selPnts 0 2"</CODE></B><BR>
selects the first and third point of the curve.</LI>
</OL>
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciprop"></A> Manipulating Properties</H3>

<P>These procedures allow easy access to object properties from the
scripting interface:<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>


<P>
<A NAME="scgetproperty"></A> 
getProperty &ndash; get single property value
<UL>
<LI>Synopsis: <CODE>"getProperty propname(elemname) [varname] [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-i]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure gets a single property element
named <CODE>elemname</CODE> from the property named <CODE>propname</CODE> of the currently
selected object and writes the result into the variable named <CODE>varname</CODE>.
Multiple selected objects are supported and lead to a list of values
produced in the output variable.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>

<P>If the <CODE>"varname"</CODE> is omitted, the procedure will return the fetched
value(s), otherwise the returned value will be <CODE>"1"</CODE> for successful
operations and <CODE>"0"</CODE> else.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the <CODE>"-s"</CODE> option is specified, no errors will be
reported.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the <CODE>"-i"</CODE> option is specified, <CODE>"RP"</CODE> tags will be
ignored.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
</LI>
<LI>Notes: This procedure runs more slowly than calling the appropriate
get-procedure and accessing the data array that is associated with the
property in question directly, especially if multiple values are to be
fetched.<BR>
However, the name of the data array and the appropriate procedure
are inferred automatically and errors are caught and reported.
Furthermore, potential object type initialization and <CODE>"NP"</CODE>/<CODE>"RP"</CODE>
tags are also handled transparently.<BR>
See below for more information regarding direct access of property values.</LI>
<LI>Example: Given that a single Sphere object is selected, its
radius may be retrieved in the variable <CODE>"r"</CODE> easily using the command
<BLOCKQUOTE><CODE>
<PRE>
getProperty SphereAttr(Radius) r
</PRE>
</CODE></BLOCKQUOTE>

In contrast to using <CODE>"getProperty"</CODE>, here is an equivalent example for the
direct (fast) access of property values:
<BLOCKQUOTE><CODE>
<PRE>
getProp
set r $::SphereAttrData(Radius)
</PRE>
</CODE></BLOCKQUOTE>

See also section
<A HREF="#ayproparr">Global Property Management and Data Arrays</A>.</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scsetproperty"></A> 
setProperty &ndash; set single property value
<UL>
<LI>Synopsis: <CODE>"setProperty propname(elemname) value"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure sets a single property element
named <CODE>elemname</CODE> of the property named <CODE>propname</CODE> for the currently
selected object to the new value given in <CODE>value</CODE>.
Multiple selected objects are supported.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>Notes: This procedure runs more slowly than accessing the data array
that is associated with a property and calling the appropriate set-procedure
directly, especially if multiple values are to be set.
However, the name of the data array and the appropriate procedure
are inferred automatically and errors are caught and reported.
See below for more information regarding direct access of property values.</LI>
<LI>Example: Given that a single Sphere object is selected, its
radius may be set to the new value <CODE>"3.0"</CODE> easily using the command
<BLOCKQUOTE><CODE>
<PRE>
setProperty SphereAttr(Radius) 3.0
</PRE>
</CODE></BLOCKQUOTE>


In contrast to using <CODE>"setProperty"</CODE>, here is an equivalent example for the
direct (fast) access of property values:
<BLOCKQUOTE><CODE>
<PRE>
getProp
set SphereAttrData(Radius) 3.0
setProp
</PRE>
</CODE></BLOCKQUOTE>

See also section
<A HREF="#ayproparr">Global Property Management and Data Arrays</A>.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciclip"></A> Clipboard Operations</H3>

<P>These commands operate the object clipboard:</P>


<P>
<A NAME="sccopob"></A> 
copOb &ndash; copy object(s):
<UL>
<LI>Synopsis: <CODE>"copOb [-append]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Copy the selected object(s) to the object clipboard
after clearing it.<BR>
This is a deep copy, reference counters of master or material objects
may be increased and there are special rules for instances, see also
section 
<A HREF="ayam-4.html#instclip">Instances and the Object Clipboard</A>.<BR>
If the option <CODE>"-append"</CODE> is used, the clipboard will not be cleared
before this operation.
</LI>
<LI>Notes: May fail if the clipboard contains referenced objects.
If the append option is set, this operation only fails if there is
not enough memory.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccutob"></A> 
cutOb &ndash; cut object(s):
<UL>
<LI>Synopsis: <CODE>"cutOb [-append]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Move the selected object(s) and their children into
the object clipboard after clearing it.<BR>
If the option <CODE>"-append"</CODE> is used, the clipboard will not be cleared
before this operation.</LI>
<LI>Notes: May fail if the clipboard contains referenced objects.
If the append option is set, this operation never fails.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scpasob"></A> <A NAME="sccmovob"></A> <A NAME="scpasmovob"></A> 
pasOb &ndash; paste object(s):
<UL>
<LI>Synopsis: <CODE>"pasOb [-move]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Copy all object(s) from the object
clipboard to the current level.<BR>
This is a deep copy, reference counters of master or material objects
may be increased and there are special rules for instances, see also
section 
<A HREF="ayam-4.html#instclip">Instances and the Object Clipboard</A>.<BR>
If the option <CODE>"-move"</CODE> is given,
the objects are moved and not copied, i.e.&nbsp;after a <CODE>"pasOb -move"</CODE>,
the clipboard is empty and no reference counters will be changed.</LI>
<LI>Notes: This operation may fail if the result would be an illegal
instance configuration (i.e.&nbsp;recursive references).</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screpob"></A> 
repOb &ndash; replace clipboard content with selected object(s):
<UL>
<LI>Synopsis: <CODE>"repOb"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Swap all objects from the object clipboard
with the currently selected object(s). If multiple objects are selected
in non consecutive sequences, only the first consecutive sequence
or single object is replaced.</LI>
<LI>Notes: This operation may fail if the result would be an illegal
instance configuration (i.e.&nbsp;recursive references).</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scclearclip"></A> 
clearClip &ndash; clear object clipboard:
<UL>
<LI>Synopsis: <CODE>"clearClip"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Clears the object clipboard.</LI>
<LI>Notes: May fail if the clipboard contains referenced objects.</LI>
</UL>
</P>

<P><SUB><BR></SUB>
The following procedures operate the property clipboard,
which is totally independent from the object clipboard.</P>


<P>
<A NAME="scpclip_copy"></A> <A NAME="sccopyprop"></A> 
copyProp &ndash; copy a property to the property clipboard
<UL>
<LI>Synopsis: <CODE>"copyProp [mode]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Copy the currently selected property from the
currently selected object to the property clipboard.
If <CODE>mode</CODE> is 0 (default), all marked entries will be omitted.
If <CODE>mode</CODE> is 1 only the marked entries will be copied.
Property entries are usually marked by double clicks
on the respective entry labels but they can also be marked programmatically
by adding the respective property element names to the global array
<CODE>"pclip_omit"</CODE>.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scpclip_paste"></A> <A NAME="scpasteprop"></A> 
pasteProp &ndash; paste a property
<UL>
<LI>Synopsis: <CODE>"pasteProp"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Copy the property from the property clipboard
to the currently selected object.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scihier"></A> Hierarchy Operations</H3>

<P>These commands manipulate the current level of Ayam:</P>


<P>
<A NAME="scgodown"></A> 
goDown:
<UL>
<LI>Synopsis: <CODE>"goDown index"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Enter the object determined by <CODE>index</CODE>. If
<CODE>index</CODE> is 0 and the current level is inside some object
the parent level will be entered instead. If <CODE>index</CODE> is -1, the last
object of the current level will be entered.</LI>
<LI>Notes: The object selection is <EM>not</EM> synchronized.</LI>
<LI>Example: <B><CODE>"crtOb Level; goDown -1; crtOb Sphere"</CODE></B>
creates a simple Level, enters it, and creates a Sphere as child of
this level.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgoup"></A> 
goUp:
<UL>
<LI>Synopsis: <CODE>"goUp"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Go one level up in the object hierarchy.</LI>
<LI>Notes: The object selection is <EM>not</EM> synchronized.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgotop"></A> 
goTop:
<UL>
<LI>Synopsis: <CODE>"goTop"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Go to the top level of the object hierarchy.</LI>
<LI>Notes: The object selection is <EM>not</EM> synchronized.</LI>
</UL>
</P>
<P><SUB><BR></SUB>
The following commands move objects around in the hierarchy:</P>


<P>upOb &ndash; shuffle object(s) backward in the current level:
<A NAME="scupob"></A> 
<UL>
<LI>Synopsis: <CODE>"upOb"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Shuffle the currently selected object(s) backwards
(towards the first object) in the current level. Non contiguous selections
are supported.
If the first of the selected objects is the first in the current level,
nothing will be changed, i.e.&nbsp;either all selected objects move, or none.
<P>The moved objects stay selected, i.e.&nbsp;this command can be used
multiple times in a row.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scdownob"></A> 
downOb &ndash; shuffle object(s) forward in the current level:
<UL>
<LI>Synopsis: <CODE>"downOb"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Shuffle the currently selected object(s) forwards
(towards the last object) in the current level. Non contiguous selections
are supported.
If the last of the selected objects is the last in the current level,
nothing will be changed, i.e.&nbsp;either all selected objects move, or none.
<P>The moved objects stay selected, i.e.&nbsp;this command can be used
multiple times in a row.</P>
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scitrafo"></A> Transformations</H3>

<P>These commands transform objects or selected points of objects:</P>


<P>
<A NAME="scmovob"></A> 
movOb &ndash; move objects:
<UL>
<LI>Synopsis: <CODE>"movOb dx dy dz"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Move the selected object(s) by <CODE>dx</CODE> in direction of the
objects X-axis, by <CODE>dy</CODE> in direction of the objects Y-axis, and by
<CODE>dz</CODE> in direction of the objects Z-axis.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scrotob"></A> 
rotOb &ndash; rotate objects:
<UL>
<LI>Synopsis: <CODE>"rotOb (dx dy dz | -a ax ay az a)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Rotate the selected object(s) by <CODE>dx</CODE> degrees around the
objects X-axis, then by <CODE>dy</CODE> degrees around objects Y-axis, and finally by
<CODE>dz</CODE> degrees around the objects Z-axis. Note the order of the
rotations.<BR>
If the parameters start with an <CODE>-a</CODE>, they denote an rotation
axis followed by the angle in degrees.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>Examples:
<OL>
<LI><B><CODE>"rotOb 0 0 45"</CODE></B><SUP>&nbsp;</SUP><BR>
rotates the selected objects by an angle of 45&deg; about the Z-axis.</LI>
<LI><B><CODE>"rotOb -a 1 1 0 45"</CODE></B><BR>
rotates the selected objects by an angle of  45&deg; about the
axis <CODE>"1 1 0"</CODE>.</LI>
</OL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scscalob"></A> 
scalOb &ndash; scale objects:
<UL>
<LI>Synopsis: <CODE>"scalOb dx dy dz"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Scale the selected object(s) by a factor of <CODE>dx</CODE> in
direction of the objects X-axis, by a factor of <CODE>dy</CODE> in
direction of the objects Y-axis, and by a factor of <CODE>dz</CODE> in
direction of the objects Z-axis.</LI>
<LI>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scmovsel"></A> <A NAME="scmovpnts"></A> 
movPnts &ndash; move selected points:
<UL>
<LI>Synopsis: <CODE>"movPnts dx dy dz"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Move the selected points by <CODE>dx</CODE> in direction of the
objects X-axis, by <CODE>dy</CODE> in direction of the objects Y-axis, and by
<CODE>dz</CODE> in direction of the objects Z-axis.</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scrotsel"></A> <A NAME="scrotpnts"></A> 
rotPnts &ndash; rotate selected points:
<UL>
<LI>Synopsis: <CODE>"rotPnts (dx dy dz | -a ax ay az a)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Rotate the selected points by <CODE>dx</CODE> degrees around the
objects X-axis, then by <CODE>dy</CODE> degrees around objects Y-axis, and finally
by <CODE>dz</CODE> degrees around the objects Z-axis. Note the order of the
rotations.<BR>
If the parameters start with an <CODE>-a</CODE>, they denote an rotation
axis followed by the angle in degrees.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI>Examples:
<OL>
<LI><B><CODE>"rotPnts 0 0 45"</CODE></B><SUP>&nbsp;</SUP><BR>
rotates the selected points by an angle of 45&deg; about the Z-axis.</LI>
<LI><B><CODE>"rotPnts -a 1 1 0 45"</CODE></B><BR>
rotates the selected points by an angle of 45&deg; about the
axis <CODE>"1 1 0"</CODE>.</LI>
</OL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scscalsel"></A> <A NAME="scscalpnts"></A> 
scalPnts &ndash; scale selected points:
<UL>
<LI>Synopsis: <CODE>"scalPnts dx dy dz"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Scale the selected points by a factor of <CODE>dx</CODE> in
direction of the objects X-axis, by a factor of <CODE>dy</CODE> in
direction of the objects Y-axis, and by a factor of <CODE>dz</CODE> in
direction of the objects Z-axis.</LI>
<LI>Note: A scale factor of zero is generally a bad idea and thus will
be changed to 1.0 silently.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scdelegtrafo"></A> 
delegTrafo &ndash; delegate transformations:
<UL>
<LI>Synopsis: <CODE>"delegTrafo"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Delegates the transformations associated
with the selected objects to their child objects. Additionally,
the transformations of the selected objects will be reset to the
default values.

<P>This operation fails for complex setups (i.e.&nbsp;if the combination of
parent and child transformation is a shear transformation).</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scapplytrafo"></A> 
applyTrafo &ndash; apply transformations:
<UL>
<LI>Synopsis: <CODE>"applyTrafo [-sel]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Applies the transformations encoded in the
transformation attributes of the selected objects to their points.
Either all points (default) or just the selected ones (if the option
<CODE>"-sel"</CODE> is given) are modified.
It is no error, if an object has no points at all or if the points
are readonly.
Additionally, if any points of an object are modified, the transformations
of this object will be reset to the default values.</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scnormtrafos"></A> 
normTrafos &ndash; normalize transformation values:
<UL>
<LI>Synopsis: <CODE>"normTrafos"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Normalize all transformation attribute values
of the selected objects. The values will be rounded to the number of
significant digits specified via the hidden preference setting
<CODE>"NormalizeDigits"</CODE> (by default 6).</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scnormpnts"></A> 
normPnts &ndash; normalize points:
<UL>
<LI>Synopsis: <CODE>"normPnts"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Normalize all selected points
of the selected objects. The values will be rounded to the number of
significant digits specified via the hidden preference setting
<CODE>"NormalizeDigits"</CODE> (by default 6).</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scnormvar"></A> 
normVar &ndash; normalize variable(s):
<UL>
<LI>Synopsis: <CODE>"normVar varname"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Normalize the value of the designated variable(s).
The value of the variable will be rounded to the number of
significant digits specified via the hidden preference setting
<CODE>"NormalizeDigits"</CODE> (by default 6).
Lists are also supported.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scnormval"></A> 
normVal &ndash; normalize double value(s):
<UL>
<LI>Synopsis: <CODE>"normVar value"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Returns the normalized value(s). Lists are supported.
The value(s) will be rounded to the number of
significant digits specified via the hidden preference setting
<CODE>"NormalizeDigits"</CODE> (by default 6).</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scishaders"></A> Manipulating Shaders</H3>

<P>These commands operate the shader properties:</P>


<P>
<A NAME="scshaderset"></A> 
shaderSet:
<UL>
<LI>Synopsis: <CODE>"shaderSet shadertype [varname]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Set the shader of type <CODE>shadertype</CODE> for the selected
object. Type may be one of <CODE>"surface"</CODE>, <CODE>"displacement"</CODE>,
<CODE>"light"</CODE>, <CODE>"imager"</CODE>, <CODE>"atmosphere"</CODE>, <CODE>"exterior"</CODE>
or <CODE>"interior"</CODE>. If <CODE>varname</CODE> is not given, the shader in question
is deleted from the object instead.
Otherwise, <CODE>varname</CODE> points to an associative array that contains
the data (arguments) of the shader. Example content may be created
with the <CODE>"shaderGet"</CODE> command below. The data is <EM>not</EM> checked
against the internal shader database for correctness or completeness.
This command fails, if the selected object does not support a shader
of given type.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scshaderget"></A> 
shaderGet:
<UL>
<LI>Synopsis: <CODE>"shaderGet shadertype varname"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Get the shader of type <CODE>shadertype</CODE> for the selected
object. Type may be one of <CODE>"surface"</CODE>, <CODE>"displacement"</CODE>,
<CODE>"light"</CODE>, <CODE>"imager"</CODE>, <CODE>"atmosphere"</CODE>, <CODE>"exterior"</CODE>
or <CODE>"interior"</CODE>. The shader data will be written to an associative
array pointed to by <CODE>varname</CODE>.</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scitags"></A> Manipulating Tags</H3>

<P>These commands may be used to modify the tags of an object
(see also section 
<A HREF="ayam-4.html#tags">Tags</A>).</P>
<P>When processing tags of unknown or unregistered type, a corresponding
warning message may be emitted. This warning can be inhibited using
the hidden preference
setting <CODE>"WarnUnknownTag"</CODE> or by registering the tag type using
the <CODE>"registerTag"</CODE> command (see below).</P>


<P>
<A NAME="scsettag"></A> 
setTag:
<UL>
<LI>Synopsis: <CODE>"setTag type value"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Set a tag with type-string <CODE>type</CODE> and value-string
<CODE>value</CODE> to the currently selected object(s).<BR>
If a tag of matching type already exists, the new value will be set to
the first matching tag. Otherwise a new tag will be added to the
selected object(s);<BR>
It is legal to deliver <CODE>""</CODE> as value parameter. This is
e.g.&nbsp;needed for the <CODE>"NoExport"</CODE> tag type.</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"setTag NoExport """</CODE></B><SUP>&nbsp;</SUP><BR>
sets or adds a <CODE>"NoExport"</CODE> tag to the selected objects.</LI>
<LI><B><CODE>"setTag RP Transformations"</CODE></B><BR>
sets or adds a <CODE>"RP"</CODE> (remove property) tag to the selected objects
that hides the Transformations property GUI.</LI>
</OL>
</LI>
</UL>
</P>
<P><SUB><BR></SUB>
addTag:
<A NAME="scaddtag"></A> 
<UL>
<LI>Synopsis: <CODE>"addTag type value"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Add a tag with type-string <CODE>type</CODE> and value-string
<CODE>value</CODE> to the currently selected objects.<BR>
It is legal to deliver <CODE>""</CODE> as value parameter. This is
e.g.&nbsp;needed for the <CODE>"NoExport"</CODE> tag type.<BR>
Potentially existing tags of the designated type will <EM>not</EM> be
changed.</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"addTag NoExport """</CODE></B><SUP>&nbsp;</SUP><BR>
adds a <CODE>"NoExport"</CODE> tag to the selected objects.</LI>
<LI><B><CODE>"addTag RP Transformations"</CODE></B><BR>
adds a <CODE>"RP"</CODE> (remove property) tag to the selected objects
that hides the Transformations property GUI.</LI>
</OL>
</LI>
</UL>
</P>
<P><SUB><BR></SUB>
<A NAME="schastag"></A> 
hasTag:
<UL>
<LI>Synopsis: <CODE>"hasTag type [value]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>"1"</CODE> if the selected
object has at least one tag of the designated type. Otherwise <CODE>"0"</CODE>
is returned. If multiple objects are selected, a list of values
is returned.<SMALL TITLE="Since 1.29."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>

<P>If a value is provided, this string is matched against the potential
tag value, it may also contain any of <CODE>*?[]</CODE> for more complex
forms of matching.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="scdeltags"></A> 
delTags:
<UL>
<LI>Synopsis: <CODE>"delTags [type]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Delete all tags of designated type from
the currently selected objects.
If the type parameter is omitted or <CODE>"all"</CODE>, <EM>all</EM> tags are
deleted from the currently selected objects.</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"delTags"</CODE></B><SUP>&nbsp;</SUP><BR>
removes all tags from the selected objects.</LI>
<LI><B><CODE>"delTags RP"</CODE></B><BR>
removes all <CODE>"RP"</CODE> tags from the selected objects.</LI>
</OL>
</LI>
</UL>
</P>
<P><SUB><BR></SUB>
<A NAME="scgettags"></A> 
getTags:
<UL>
<LI>Synopsis: <CODE>"getTags tvname vvname"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Get all tags from
the currently selected object and put them as lists into two
variables named <CODE>tvname</CODE> for the tag types and <CODE>vvname</CODE> for the tag
values.</LI>
</UL>
</P>
<P>
<A NAME="scsettags"></A> 
setTags:
<UL>
<LI>Synopsis: <CODE>"setTags tagslist"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Clear all tags from the currently selected objects
and set all new tags from the list <CODE>tagslist</CODE>. The tag types are
taken from the list elements with even index numbers and the tag
value-strings from the list elements with odd index numbers.</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"setTags {RP Transformations RP Attributes}"</CODE></B><SUP>&nbsp;</SUP><BR>
replaces all tags from the selected objects with two <CODE>"RP"</CODE>
tags.</LI>
</OL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgettag"></A> 
getTag:
<UL>
<LI>Synopsis: <CODE>"getTag type [vname]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Get the value of a specific tag from
the currently selected object and put it into the designated variable.
If there is no tag of the specified type, the variable will be set
to <CODE>""</CODE>.
If no variable name is provided, the value of the tag is returned.</LI>
</UL>
</P>

<P><SUB><BR></SUB>
<A NAME="scregistertag"></A> 
registerTag:
<UL>
<LI>Synopsis: <CODE>"registerTag type"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command registers the designated tag type.</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scicurves"></A> Manipulating Curves</H3>

<P>These commands operate on parametric curves:</P>
<P>
<A NAME="scopenc"></A> 
openC &ndash; open curve:
<UL>
<LI>Synopsis: <CODE>"openC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Open the selected curve objects.

<P>See also section 
<A HREF="ayam-5.html#openct">Open Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scclosec"></A> 
closeC &ndash; close curve:
<UL>
<LI>Synopsis: <CODE>"closeC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Close the selected curve objects.

<P>See also section 
<A HREF="ayam-5.html#closect">Close Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screfinenc"></A> <A NAME="screfinec"></A> 
refineC &ndash; refine curve:
<UL>
<LI>Synopsis: <CODE>"refineC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Refine the control vector of the selected
curve objects by inserting a new control point into every control
point interval, changing the shapes of the curves.
If a curve has selected points, only the interval between the first and the
last of the selected points is refined. For periodic NURBS
curves, the last <EM>p</EM> intervals are not refined (where <EM>p</EM>
is the degree of the curve).

<P>See also section 
<A HREF="ayam-5.html#refit">Refine Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccoarsenc"></A> 
coarsenC &ndash; coarsen curve:
<UL>
<LI>Synopsis: <CODE>"coarsenC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove every second control point from the
selected curve objects. If a curve has selected
points, only the interval between the first and the
last of the selected points is affected. For periodic NURBS
curves, the last <EM>p</EM> intervals are not affected (where <EM>p</EM>
is the degree of the curve).</LI>
<LI>Notes:
Prior to Ayam 1.26 this command was named <CODE>"coarsenNC"</CODE>,
the old name is still available for compatibility but its
use is deprecated.

<P>See also section 
<A HREF="ayam-5.html#coart">Coarsen Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screvert"></A> <A NAME="screvertc"></A> 
revertC &ndash; revert curves:
<UL>
<LI>Synopsis: <CODE>"revertC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Revert the direction of the selected curve objects.

<P>See also section 
<A HREF="ayam-5.html#revertt">Revert Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scshiftc"></A> 
shiftC &ndash; shift control points of a (closed) curve:
<UL>
<LI>Synopsis: <CODE>"shiftC i"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: shifts the control points of the selected
NCurve, ACurve, and ICurve objects by an amount specified by the
parameter <CODE>i</CODE> (which may be negative to revert the direction of the
shifting). For a simple closed curve, shifting with <CODE>i=1</CODE>, the first
control point will get the coordinates of the former last control point.
This means, positive shifts occur in the direction of the curve.
Note that for closed and periodic NURBS curves, the multiple points will
be managed correctly.

<P>See also section 
<A HREF="ayam-5.html#shiftclc">Shift Closed Curve Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sctoxyc"></A> <A NAME="sctoxync"></A> 
toXYC &ndash; rotate curve to XY-plane
<UL>
<LI>Synopsis: <CODE>"toXYC"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: rotates the control points of the selected planar NCurve,
ACurve, and ICurve objects to their respective XY-plane, modifying
the transformation attributes accordingly.

<P>See also section 
<A HREF="ayam-5.html#toxyt">To XY Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scconcatc"></A> 
concatC &ndash; concatenate curves:
<UL>
<LI>Synopsis: <CODE>"concatC [-c closed | -k knottype | -f fillets | -fl len]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Concatenate the selected curve objects into a
single NURBS curve. The order of the new curve is taken from the first curve.

<P>The option <CODE>"-c"</CODE> allows to create a closed curve
(0 &ndash; open, 1 &ndash; closed; default 0).</P>
<P>The option <CODE>"-k"</CODE> allows to set a knot type (0 &ndash; NURB,
1 &ndash; Custom; default 0 &ndash; NURB).</P>
<P>The option <CODE>"-f"</CODE> determines whether or not fillets should be created
(0 &ndash; no, 1 &ndash; yes; default 0).</P>
<P>The option <CODE>"-fl"</CODE> allows to set the length of the fillets.</P>
<P>See also section 
<A HREF="ayam-4.html#concatncp">ConcatNCAttr Property</A>
for more information on these options.</P>
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scisurf"></A> Manipulating Surfaces</H3>

<P>These commands operate on parametric surfaces:</P>
<P>
<A NAME="screvertu"></A> <A NAME="screvertus"></A> 
revertuS &ndash; revert surfaces:
<UL>
<LI>Synopsis: <CODE>"revertuS"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Revert the direction of the selected surfaces in
the u parametric dimension.

<P>See also section 
<A HREF="ayam-5.html#revertut">Revert U Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screvertv"></A> <A NAME="screvertvs"></A> 
revertvS &ndash; revert surfaces:
<UL>
<LI>Synopsis: <CODE>"revertvS"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Revert the direction of the selected surfaces in
the v parametric dimension.

<P>See also section 
<A HREF="ayam-5.html#revertvt">Revert V Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scswapuvs"></A> 
swapuvS &ndash; swap dimensions of surfaces:
<UL>
<LI>Synopsis: <CODE>"swapuvS"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Swap the dimensions of the selected surfaces
(objects of type NPatch, IPatch, BPatch, and PatchMesh), thus
exchanging width and height, without altering the shape of the surfaces.

<P>See also section 
<A HREF="ayam-5.html#swapuvt">Swap UV Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scconcats"></A> 
concatS &ndash; concatenate surfaces:
<UL>
<LI>Synopsis: <CODE>"concatS [-o order | -t type | -k knottype | -u uvselect]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Concatenate the selected surface objects into a
single NURBS patch.

<P>The option <CODE>"-o"</CODE> determines the desired order
of the surface in U direction.</P>
<P>The option <CODE>"-t"</CODE> allows to set a surface type
(0 &ndash; open, 1 &ndash; closed, 3 &ndash; periodic; default 0).</P>
<P>The option <CODE>"-k"</CODE> allows to set a knot type (default 1 &ndash; NURB).</P>
<P>Finally, the <CODE>"-u"</CODE> option allows to specify the uv-select-string.</P>
<P>See also section 
<A HREF="ayam-4.html#concatnpp">ConcatNPAttr Property</A>
for more information on these options.</P>
</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scinurbs"></A> Manipulating NURBS Curves</H3>

<P>These are more specialized commands to change NURBS curve properties:</P>


<P>
<A NAME="scclampnc"></A> 
clampNC &ndash; clamp NURBS curve:
<UL>
<LI>Synopsis: <CODE>"clampNC [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Clamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve will be changed to <CODE>"Custom"</CODE> and
the knots will have <EM>o</EM> equal values at the desired side(s), where <EM>o</EM>
is the order of the curve.

<P>If the side parameter is omitted, both sides are clamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is clamped.</P>
<P>In Ayam versions prior to 1.18 it was an error if the curve was already
clamped at either side, this is no longer the case.
Furthermore, curves with multiple knots in the end region(s) could not be
clamped, this works ok now.</P>
<P>See also section 
<A HREF="ayam-5.html#clat">Clamp Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scunclampnc"></A> 
unclampNC &ndash; unclamp NURBS curve:
<UL>
<LI>Synopsis: <CODE>"unclampNC [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Unclamp the knot vector of the selected NURBS curves
without changing the shape of the curves.
The knot type of the clamped curve can be changed to <CODE>"Custom"</CODE>.

<P>If the side parameter is omitted, both sides are unclamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is unclamped.</P>
<P>See also section 
<A HREF="ayam-5.html#unclat">Unclamp Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scextendnc"></A> 
extendNC &ndash; extend NURBS curve:
<UL>
<LI>Synopsis: <CODE>"extendNC (x y z [w] | -vn varname | -m)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Extend the selected NURBS curves to a given
point or to the mark without changing the current shape of
the curve.

<P>See also section 
<A HREF="ayam-5.html#extendt">Extend Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scelevatenc"></A> 
elevateNC &ndash; increase order of NURBS curve:
<UL>
<LI>Synopsis: <CODE>"elevateNC [n]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Increases the order of the selected NURBS curves
without changing the shape of the curves by <CODE>n</CODE>.
If the parameter <CODE>n</CODE> is omitted, a default value of 1 is used.
The knot type of the elevated curves will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#elevt">Elevate Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="screducenc"></A> 
reduceNC &ndash; decrease order of  NURBS curve:
<UL>
<LI>Synopsis: <CODE>"reduceNC [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Decrease the order of the selected NURBS curves
by one if the shape of the reduced curves does not deviate from the
original curves by <CODE>tol</CODE> in any point.
If the parameter <CODE>tol</CODE> is omitted, a default value of 0.0 is used,
i.e.&nbsp;the order is only reduced if the curve does not change.
The knot type of the reduced curves will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#reduct">Reduce Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scinsknnc"></A> 
insknNC &ndash; insert knot into NURBS curve:
<UL>
<LI>Synopsis: <CODE>"insknNC u r"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Insert a new knot at the position
specified by <CODE>u</CODE> <CODE>r</CODE> times. The valid range for <CODE>u</CODE> is determined by
the current knot vector U as follows: <CODE>U[p] &lt;= u &lt;= U[n]</CODE>, where
<CODE>p</CODE> is the degree (order-1) of the curve and <CODE>n</CODE> is the length of
the curve.
The knot type of the curves will always be changed to custom but
the shape of the curves will not change.
<P>See also section 
<A HREF="ayam-5.html#insknt">Insert Knot Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremknnc"></A> 
remknNC &ndash; remove knot from NURBS curve:
<UL>
<LI>Synopsis: <CODE>"remknNC (u | -i ind) r [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove a knot at the position
specified by <CODE>u</CODE> (u must be in the valid range of the knot vector
of the selected curve) <CODE>r</CODE> times from the curve. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.&nbsp;use <CODE>"remknNC -i 3 1"</CODE> instead of
<CODE>"remknNC 0.5 1"</CODE> for the knot vector <CODE>"0 0 0 0.5 1 1 1"</CODE>).

<P>Note that the shape of the curve may be changed by this tool unless
the parameter <CODE>tol</CODE> is specified.
If <CODE>tol</CODE> is specified the new curve does not deviate
from the original curve more than <CODE>tol</CODE> in any point on the curve.
If the knot can not be removed <CODE>r</CODE> times due to the tolerance, an
error is reported and the original curve is left unchanged.</P>
<P>This operation also fails, if the knot removal would lead to a curve
of lower order.</P>
<P>See also section 
<A HREF="ayam-5.html#remknt">Remove Knot Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremsuknnc"></A> 
remsuknNC &ndash; remove superfluous knots from NURBS curve:
<UL>
<LI>Synopsis: <CODE>"remsuknNC [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove all knots from the NURBS curve that do not
contribute to its shape. This may lead to control point removal and
changes, but the shape of the curve does not change unless a large
tolerance value is specified via the <CODE>tol</CODE> parameter. The default value
of this parameter is 0.0.

<P>It is no error if no knots can be removed.</P>
<P>See also section 
<A HREF="ayam-5.html#remsuknt">Remove Superfluous Knots Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="screfineknnc"></A> 
refineknNC &ndash; refine knots of NURBS curve:
<UL>
<LI>Synopsis: <CODE>"refineknNC [{u1 u2 un}]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Refine the knot vector of the selected NURBS curve
without changing the shape of the curve with n new knots <CODE>{u1 u2 un}</CODE>.
If no list of new knots is given, a new knot is inserted into each interval
in the old knot vector.

<P>See also section 
<A HREF="ayam-5.html#refknit">Refine Knots Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sctweennc"></A> 
tweenNC &ndash; interpolate (tween) curves:
<UL>
<LI>Synopsis: <CODE>"tweenNC [r]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Interpolate (tween) between the first two selected
NURBS curves, creating a new curve that incorporates features from the
selected curves. The parameter <CODE>r</CODE> defines the
ratio of influence of the first and the second curve (the latter
using <CODE>1-r</CODE>). This parameter defaults to 0.5.<BR>
The first two curves must be of the same length and order. They need
not be defined on the same knot vector, however.<BR>
If a third curve is selected, the parameter <CODE>r</CODE> is ignored and this
third curve defines the ratio of influence with its y coordinates.

<P>See also section 
<A HREF="ayam-5.html#tweennct">Tween Curve Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screscaleknnc"></A> 
rescaleknNC &ndash; rescale knots of NURBS curves:
<UL>
<LI>Synopsis: <CODE>"rescaleknNC [-r rmin rmax | -d mindist]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Rescale the knot vector(s) of the selected NURBS curve(s)
to the range [0.0,&thinsp;1.0] (if no argument is present) or to the
range [<CODE>rmin</CODE>,&thinsp;<CODE>rmax</CODE>] if the <CODE>"-r"</CODE> argument is
given or to the minimum distance <CODE>mindist</CODE> if the <CODE>"-d"</CODE> argument is used.
Scaling to a minimum distance ensures that all knots (except for multiple
knots) have a distance bigger than <CODE>mindist</CODE> afterwards.

<P>Since Ayam 1.20 the knot type of the curve does
not have to be <CODE>"Custom"</CODE> anymore. Furthermore, rescaling the knots
does not change the knot type.</P>
<P>This operation does not change the shape of the curve.</P>
<P>See also section 
<A HREF="ayam-5.html#resckrt">Rescale Knots to Range Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scsplitnc"></A> 
splitNC &ndash; split NURBS curve
<UL>
<LI>Synopsis: <CODE>"splitNC [-a</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-r] u"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: splits the selected NURBS curves at the designated
parametric value <CODE>u</CODE> into two curves, creating one new curve and
<EM>modifying the original</EM> selected curve.
<P>If the option <CODE>"-r"</CODE> is present, the parametric value is interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].<SMALL TITLE="Since 1.28."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the option <CODE>"-a"</CODE> is present, the new curve(s) will be appended
to the current level. Otherwise the new curve(s) will be inserted
into the level right after the respective curve(s) to split.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<P>See also section 
<A HREF="ayam-5.html#splitt">Split Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scextrnc"></A> 
extrNC &ndash; extract NURBS curve:
<UL>
<LI>Synopsis: <CODE>"extrNC [-relative] umin umax"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Extracts a sub-curve from the selected NCurve
or NCurve providing objects. The extracted curve(s) will be appended
as new object(s) to the current level of the scene. The sub-curve to be
extracted is specified by the parametric values <CODE>umin</CODE> and <CODE>umax</CODE>
which have to be in the respective valid knot range.

<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
values are interpreted in a relative
way and must consequently be in the range [0,1].</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sctrimnc"></A> 
trimNC &ndash; trim NURBS curve
<UL>
<LI>Synopsis: <CODE>"trimNC [-relative] umin umax"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: trims the selected NURBS curve to the designated
parametric range (umin-umax), modifying the original selected curve.

<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
values are interpreted in a relative way and must consequently be in
the range [0,&thinsp;1].</P>
<P>See also section 
<A HREF="ayam-5.html#ctrimt">Curve Trim Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scestlennc"></A> 
estlenNC &ndash; estimate length of NURBS curve:
<UL>
<LI>Synopsis: <CODE>"estlenNC [-trafo | -refine n] [varname]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: estimate the length of the currently selected NURBS curve
or NURBS curve providing object and put the result into the designated
variable.<BR>
If multiple curves are selected or provided, a list of results is
created.<BR>
If the optional parameter <CODE>"-trafo"</CODE> is given, the transformation
attributes of the curve will be applied to the control points for the
length estimation.<BR>
If the optional parameter <CODE>"-refine"</CODE> is given, the curve will be
refined <CODE>n</CODE> times prior to the length estimation which increases
the accuracy of the estimation.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
If no variable name is specified the command returns the respective result(s).<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screparamnc"></A> 
reparamNC &ndash; reparameterise a NURBS curve:
<UL>
<LI>Synopsis: <CODE>"reparamNC type"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: reparameterise all selected NURBS curves to have
chordal knots (type: <CODE>0</CODE>), or centripetal knots (type: <CODE>1</CODE>).
The knot type of the curve will be changed to <CODE>"Custom"</CODE>.
See also section 
<A HREF="ayam-5.html#reparamt">Reparameterisation Tool</A>.</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="sciscompnc"></A> 
isCompNC:
<UL>
<LI>Synopsis: <CODE>"isCompNC [-l level]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected NURBS curves
are compatible (i.e.&nbsp;defined on the same knot vector), otherwise it
returns <CODE>0</CODE>.

<P>If <CODE>"level"</CODE> is <CODE>0</CODE>, only the orders of the curves
are compared.<BR>
If <CODE>"level"</CODE> is <CODE>1</CODE>, only the orders and lengths of the curves
are compared.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="scmakecompnc"></A> 
makeCompNC &ndash; make NURBS curves compatible
<UL>
<LI>Synopsis: <CODE>"makeCompNC [-f | -l level]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: makes the selected NURBS curves compatible
i.e.&nbsp;of the same order and defined on the same knot vector.

<P>If the option <CODE>"-f"</CODE> is present, there will be no prior compatibility check.</P>
<P>If <CODE>"level"</CODE> is <CODE>0</CODE>, only the orders will be adapted.<BR>
If <CODE>"level"</CODE> is <CODE>1</CODE>, only the orders and lengths will be adapted.</P>
<P>See also section 
<A HREF="ayam-5.html#makecompt">Make Compatible Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scinterpnc"></A> 
interpNC &ndash; interpolate NURBS curve:
<UL>
<LI>Synopsis: <CODE>"interpNC [-order order | -ptype type | -closed (0|1) | -sdlen length | -edlen length]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Interpolate the selected NURBS curves
with desired order and parameterisation type.
Order defaults to 4 and must be higher than 2.
The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.
The interpolation can create a closed curve if requested by the
<CODE>"-closed"</CODE> parameter but this will also increase
the length of the resulting NURBS curve. The default is to
create an open curve for open input curves and a closed curve for
closed or periodic input curves.

<P>Using the options <CODE>"-sdlen"</CODE> and <CODE>"-edlen"</CODE> (which both default
to 0.0) the length of automatically created start/end derivatives
can be adjusted. If any of these is not 0.0, a different interpolation
algorithm will be used, which increases the length of the resulting NURBS
curve.</P>
<P>The curve will interpolate all current control points after the
interpolation and the position of certain control points will be
changed in this process so that, after interpolation, the new control
points will <EM>not</EM> be interpolated by the curve. The curve will
rather interpolate the <EM>old</EM> control point positions.</P>
<P>The knot type of the interpolated curves will be changed to <CODE>"Custom"</CODE>.</P>
<P>See also section 
<A HREF="ayam-5.html#interpnct">Interpolate Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scapproxnc"></A> 
approxNC &ndash; approximate NURBS curve:
<UL>
<LI>Synopsis: <CODE>"approxNC [-order o | -length l | -closed (0|1) | -tesselate t]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Approximate the selected NURBS curves
with a new NURBS curve of desired order and length.

<P>The order defaults to the order of the respective NURBS curve and must be
at least 2. If a smaller value is supplied the command will silently
fall back to the default.</P>
<P>The length defaults to the length of the respective NURBS curve and must be
higher than 2. If a smaller value is supplied the command will silently
fall back to the default.</P>
<P>If the <CODE>"-closed"</CODE> parameter is set to <CODE>"1"</CODE> a closed periodic curve
will be created. By default, whether or not a closed curve shall be created
will be derived from the type of the curve to be approximated.</P>
<P>The <CODE>"-tesselate"</CODE> parameter allows to specify a parameter for
the tesselation of the curve to be approximated.</P>
<P>The knot type of the processed curves will be changed to <CODE>"Custom"</CODE>.</P>
<P>See also section 
<A HREF="ayam-5.html#approxnct">Approximate Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sccurvatnc"></A> 
curvatNC &ndash; compute curvature:
<UL>
<LI>Synopsis: <CODE>"curvatNC [-r] -u u"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Compute and return the curvature of the selected NURBS
curve or NURBS curve providing object at the designated parametric
value <CODE>u</CODE>.<BR>
<P>If the option <CODE>"-r"</CODE> is present, the parametric value is interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].</P>
<P>If multiple objects are selected, a list of curvature values is returned.</P>
<P>See also section 
<A HREF="ayam-5.html#plotcurt">Plot Curvature Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sctorsionnc"></A> 
torsionNC &ndash; compute torsion:
<UL>
<LI>Synopsis: <CODE>"torsionNC [-r] -u u"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Compute and return the torsion of the selected NURBS
curve or NURBS curve providing object at the designated parametric
value <CODE>u</CODE>.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
<P>If the option <CODE>"-r"</CODE> is present, the parametric value is interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].</P>
<P>If multiple objects are selected, a list of torsion values is returned.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="scfairnc"></A> 
fairNC &ndash; improve curve shape:
<UL>
<LI>Synopsis: <CODE>"fairNC [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Improve the curve shape by moving control points
so that the curvature is distributed more evenly.<BR>
<P>If a tolerance value is present the processed control points do not move
more than the given value.</P>
<P>If points are selected, only these will be processed.</P>
<P>See also section 
<A HREF="ayam-5.html#fairt">Fair Tool</A>.</P>
</LI>
</UL>
</P>




<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scinurbss"></A> Manipulating NURBS Surfaces</H3>

<P>These are more specialized commands to change NURBS surface properties:</P>
<P>
<A NAME="scclampnpu"></A> <A NAME="scclampunp"></A> 
clampuNP &ndash; clamp NURBS patch in U direction:
<UL>
<LI>Synopsis: <CODE>"clampuNP [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Clamp the U direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <CODE>"Custom"</CODE> and the knots will have <EM>o</EM>
equal values at start and end (where <EM>o</EM> is the order of the patch in
U direction).

<P>If the side parameter is omitted, both sides are clamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is clamped.</P>
<P>In Ayam versions prior to 1.18 it was an error if the patch was already
clamped at either side, this is no longer the case.
Furthermore, patches with multiple knots in the end region(s) could not be
clamped, this works ok now.</P>
<P>See also section 
<A HREF="ayam-5.html#clanpt">Clamp Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scclampnpv"></A> <A NAME="scclampvnp"></A> 
clampvNP &ndash; clamp NURBS patch in V direction:
<UL>
<LI>Synopsis: <CODE>"clampvNP [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Clamp the V direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type will be changed to <CODE>"Custom"</CODE> and the knots will have <EM>o</EM>
equal values at start and end (where <EM>o</EM> is the order of the patch in
V direction).

<P>If the side parameter is omitted, both sides are clamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is clamped.</P>
<P>In Ayam versions prior to 1.18 it was an error if the patch was already
clamped at either side, this is no longer the case.
Furthermore, patches with multiple knots in the end region(s) could not be
clamped, this works ok now.</P>
<P>See also section 
<A HREF="ayam-5.html#clanpt">Clamp Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scunclampunp"></A> 
unclampuNP &ndash; unclamp NURBS patch in U direction:
<UL>
<LI>Synopsis: <CODE>"unclampuNP [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Unclamp the U direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type can be changed to <CODE>"Custom"</CODE>.

<P>If the side parameter is omitted, both sides are unclamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is unclamped.</P>
<P>See also section 
<A HREF="ayam-5.html#unclanpt">Unclamp Surface Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scunclampvnp"></A> 
unclampvNP &ndash; unclamp NURBS patch in V direction:
<UL>
<LI>Synopsis: <CODE>"unclampvNP [-s</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-e]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Unclamp the V direction knot vector of the selected NURBS
patches without changing the shape of the patches.
The knot type can be changed to <CODE>"Custom"</CODE>.

<P>If the side parameter is omitted, both sides are unclamped.
If the side parameter is <CODE>"-s"</CODE> only the start, and if it is <CODE>"-e"</CODE>
only the end is unclamped.</P>
<P>See also section 
<A HREF="ayam-5.html#unclanpt">Unclamp Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screscaleknnp"></A> 
rescaleknNP &ndash; rescale knots of NURBS patches:
<UL>
<LI>Synopsis: <CODE>"rescaleknNP [-r[u|v] rmin rmax | -d[u|v] mindist]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Rescale the knot vector(s) of the selected NURBS patch(es)
to the range [0.0,&thinsp;1.0] (if no argument is present) or to the
range [<CODE>rmin</CODE>,&thinsp;<CODE>rmax</CODE>] if the <CODE>"-r"</CODE> argument is
given or to the minimum distance <CODE>mindist</CODE> if the <CODE>"-d"</CODE> argument is
used.
Scaling to a minimum distance ensures that all knots (except for multiple
knots) have a distance bigger than <CODE>mindist</CODE> afterwards.

<P>The <CODE>"-ru"</CODE>, <CODE>"-rv"</CODE>, <CODE>"-du"</CODE>, and <CODE>"-dv"</CODE> variants scale only
the designated dimension.</P>
<P>Trim curves, if present, will also be scaled to match the new range.</P>
<P>Since Ayam 1.20 the knot type of the curve does
not have to be <CODE>"Custom"</CODE> anymore. Furthermore, rescaling the knots
does not change the knot type.</P>
<P>This operation does not change the shape of the patch.</P>
<P>See also sections
<A HREF="ayam-5.html#resckrnpt">Rescale Knots to Range Surface Tool</A>
and
<A HREF="ayam-5.html#resckmnpt">Rescale Knots to Mindist Surface Tool</A>.</P>
</LI>
<LI>Example: <CODE>"rescaleknNP -ru 0.2 0.3"</CODE> scales the u knot vector
of the selected NURBS patch objects to the new range
[0.2,&thinsp;0.3].</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scinsknnpu"></A> <A NAME="scinsknunp"></A> 
insknuNP &ndash; insert knot into NURBS patch:
<UL>
<LI>Synopsis: <CODE>"insknuNP u r"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Insert a new knot in U direction at the position
specified by <CODE>u</CODE>, <CODE>r</CODE> times. <CODE>u</CODE> must be in the valid range of
the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector U as follows: <CODE>U[p] &lt;= u &lt;= U[n]</CODE>, where
<CODE>p</CODE> is the degree (order-1) of the patch in U direction and <CODE>n</CODE> is the
width of the patch.
The u knot type of the patches will always be changed to <CODE>"Custom"</CODE> but
the shape of the patches will not change.

<P>See also section 
<A HREF="ayam-5.html#insknnpt">Insert Knot Surface Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scinsknnpv"></A> <A NAME="scinsknvnp"></A> 
insknvNP &ndash; insert knot into NURBS patch:
<UL>
<LI>Synopsis: <CODE>"insknvNP v r"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Insert a new knot in V direction at the position
specified by <CODE>v</CODE>, <CODE>r</CODE> times. <CODE>v</CODE> must be in the valid range of
the corresponding
knot vector of the selected patches. The valid range is determined by
the current knot vector V as follows: <CODE>V[p] &lt;= v &lt;= V[n]</CODE>, where
<CODE>p</CODE> is the degree (order-1) of the patch in V direction and <CODE>n</CODE> is the
height of the patch.
The v knot type of the patches will always be changed to <CODE>"Custom"</CODE> but
the shape of the patches will not change.

<P>See also section 
<A HREF="ayam-5.html#insknnpt">Insert Knot Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremknunp"></A> 
remknuNP &ndash; remove u knot from NURBS surface:
<UL>
<LI>Synopsis: <CODE>"remknuNP (u | -i ind) r [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove a knot at the position
specified by <CODE>u</CODE> (<CODE>u</CODE> must be in the valid range of the knot vector
of the selected surface) <CODE>r</CODE> times from the surface. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.&nbsp;use <CODE>"remknuNP -i 3 1"</CODE> instead of
<CODE>"remknuNP 0.5 1"</CODE> for the knot vector <CODE>"0 0 0 0.5 1 1 1"</CODE>).
Note that the shape of the surface may be changed by this tool unless the
parameter tol is specified. If <CODE>tol</CODE> is specified, the new surface does
not deviate from the original surface more than tol in any point.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original surface is left unchanged.

<P>This operation also fails, if the knot removal would lead to a surface
of lower order.</P>
<P>See also section 
<A HREF="ayam-5.html#remknnpt">Remove Knot Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremknvnp"></A> 
remknvNP &ndash; remove v knot from NURBS surface:
<UL>
<LI>Synopsis: <CODE>"remknvNP (v | -i ind) r [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove a knot at the position
specified by <CODE>v</CODE> (<CODE>v</CODE> must be in the valid range of the knot vector
of the selected surface) <CODE>r</CODE> times from the surface. Since Ayam 1.20
the knot to remove may also be specified using its (zero based)
index in the knot vector (i.e.&nbsp;use <CODE>"remknvNP -i 3 1"</CODE> instead of
<CODE>"remknvNP 0.5 1"</CODE> for the knot vector <CODE>"0 0 0 0.5 1 1 1"</CODE>).
Note that the shape of the surface may be changed by this tool unless
the parameter tol is specified. If <CODE>tol</CODE> is specified, the new surface does
not deviate from the original surface more than tol in any point.
If the knot can not be removed r times due to the tolerance, an
error is reported and the original surface is left unchanged.

<P>This operation also fails, if the knot removal would lead to a surface
of lower order.</P>
<P>See also section 
<A HREF="ayam-5.html#remknnpt">Remove Knot Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremsuknunp"></A> 
remsuknuNP &ndash; remove superfluous knots from NURBS surface:
<UL>
<LI>Synopsis: <CODE>"remsuknuNP [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove all knots from the NURBS surface that do not
contribute to its shape (in u direction).
This may lead to control point removal and
changes, but the shape of the surface does not change unless a large
tolerance value is specified via the <CODE>tol</CODE> parameter. The default value
of this parameter is 0.0.

<P>It is no error if no knots can be removed.</P>
<P>See also
section 
<A HREF="ayam-5.html#remsuknt">Remove Superfluous Knots Surface Tools</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremsuknvnp"></A> 
remsuknvNP &ndash; remove superfluous knots from NURBS surface:
<UL>
<LI>Synopsis: <CODE>"remsuknvNP [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Remove all knots from the NURBS surface that do not
contribute to its shape (in v direction).
This may lead to control point removal and
changes, but the shape of the surface does not change unless a large
tolerance value is specified via the <CODE>tol</CODE> parameter. The default value
of this parameter is 0.0.

<P>It is no error if no knots can be removed.</P>
<P>See also
section 
<A HREF="ayam-5.html#remsuknuvt">Remove Superfluous Knots Surface Tools</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screfineunp"></A> 
refineuNP &ndash; refine NURBS surface in U direction:
<UL>
<LI>Synopsis: <CODE>"refineuNP [{u1 u2 un}]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Refine the selected NURBS surfaces in u direction
with n new knots <CODE>{u1 u2 un}</CODE> without changing their shape.
If no list of new knots is given, a new knot is inserted into each interval
in the old knot vector.
The u knot type of the refined surfaces may be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#refinest">Refine Knots Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screfinevnp"></A> 
refinevNP &ndash; refine NURBS surface in V direction:
<UL>
<LI>Synopsis: <CODE>"refinevNP [{v1 v2 vn}]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Refine the selected NURBS surfaces in v direction
with n new knots <CODE>{v1 v2 vn}</CODE> without changing their shape.
If no list of new knots is given, a new knot is inserted into each interval
in the old knot vector.
The v knot type of the refined surfaces may be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#refinest">Refine Knots Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scelevateunp"></A> 
elevateuNP &ndash; elevate NURBS surface in U direction:
<UL>
<LI>Synopsis: <CODE>"elevateuNP [n]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Elevate the u order of the selected NURBS surfaces
without changing the shape of the surfaces by <CODE>n</CODE>.
If the parameter <CODE>n</CODE> is omitted, a default value of 1 is used.
The u knot type of the elevated surfaces will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#elevuvt">Elevate Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scelevatevnp"></A> 
elevatevNP &ndash; elevate NURBS surface in V direction:
<UL>
<LI>Synopsis: <CODE>"elevatevNP [n]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Elevate the v order of the selected NURBS surfaces
without changing the shape of the surfaces by <CODE>n</CODE>.
If the parameter <CODE>n</CODE> is omitted, a default value of 1 is used.
The v knot type of the elevated surfaces will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#elevuvt">Elevate Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screduceunp"></A> 
reduceuNP &ndash; decrease order of  NURBS surface:
<UL>
<LI>Synopsis: <CODE>"reduceuNP [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Decrease the order of the selected NURBS surfaces
in u direction by one if the shape of the reduced surfaces does not
deviate from the original surfaces by <CODE>tol</CODE> in any point.
If the parameter <CODE>tol</CODE> is omitted, a default value of 0.0 is used,
i.e.&nbsp;the order is only reduced if the surface does not change.
The knot type of the reduced surfaces will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#reduceuvt">Reduce Surface Tools</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="screducevnp"></A> 
reducevNP &ndash; decrease order of  NURBS surface:
<UL>
<LI>Synopsis: <CODE>"reducevNP [tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Decrease the order of the selected NURBS surfaces
in v direction by one if the shape of the reduced surfaces does not
deviate from the original surfaces by <CODE>tol</CODE> in any point.
If the parameter <CODE>tol</CODE> is omitted, a default value of 0.0 is used,
i.e.&nbsp;the order is only reduced if the surface does not change.
The knot type of the reduced surfaces will be changed to <CODE>"Custom"</CODE>.

<P>See also section 
<A HREF="ayam-5.html#reduceuvt">Reduce Surface Tools</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scsplitnpu"></A> <A NAME="scsplitunp"></A> 
splituNP &ndash; split NURBS patch:
<UL>
<LI>Synopsis: <CODE>"splituNP [-a</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-r] u"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Splits the selected NPatch objects into two patches
at the parametric value <CODE>u</CODE>, creating one new NPatch object and
<EM>modifying the original</EM> selected NPatch object.
<P>If the option <CODE>"-r"</CODE> is present, the parametric value is interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].</P>
<P>If the option <CODE>"-a"</CODE> is present, the new NPatch object(s) will be appended
to the current level. Otherwise the new NPatch object(s) will be inserted
into the level right after the respective NPatch object(s) to split.
This is the new default.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<P>See also section 
<A HREF="ayam-5.html#splitnpt">Split Surface Tools</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scsplitnpv"></A> <A NAME="scsplitvnp"></A> 
splitvNP &ndash; split NURBS patch:
<UL>
<LI>Synopsis: <CODE>"splitvNP [-a</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-r] v"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Splits the selected NPatch objects into two patches
at the parametric value <CODE>v</CODE>, creating one new NPatch object and
<EM>modifying the original</EM> selected NPatch object.<BR>
<P>If the option <CODE>"-r"</CODE> is present, the parametric value is interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].</P>
<P>If the option <CODE>"-a"</CODE> is present, the new NPatch object(s) will be appended
to the current level. Otherwise the new NPatch object(s) will be inserted
into the level right after the respective NPatch object(s) to split.
This is the new default.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<P>See also section 
<A HREF="ayam-5.html#splitnpt">Split Surface Tools</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scextrnp"></A> 
extrNP &ndash; extract NURBS patch:
<UL>
<LI>Synopsis: <CODE>"extrNP [-relative] umin umax vmin vmax"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Extracts a sub-patch from the selected NPatch
or NPatch providing objects. The extracted patch(es) will be appended as
new object(s) to the current level of the scene.
The sub-patch to be extracted is specified by the parametric values
<CODE>umin</CODE>, <CODE>umax</CODE>, <CODE>vmin</CODE>, and <CODE>vmax</CODE> which have to be in the
respective valid knot range.

<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
values are interpreted in a relative
way and must consequently be in the range [0,1].</P>
<P>See also section 
<A HREF="ayam-5.html#extrnpt">Extract Patch Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="sctweennp"></A> 
tweenNP &ndash; interpolate (tween) surfaces:
<UL>
<LI>Synopsis: <CODE>"tweenNP [r]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Interpolate (tween) between the first two selected
NURBS patches, creating a new patch that incorporates features from the
selected patches. The parameter <CODE>r</CODE> defines the
ratio of influence of the first and the second patch (the latter
using <CODE>1-r</CODE>). This parameter defaults to 0.5.<BR>
The two patches must be of the same width, height, uorder, and vorder.
They need not be defined on the same knot vectors, however.<BR>
If a third surface is selected, the parameter <CODE>r</CODE> is ignored and this
third surface defines the ratio of influence with its y coordinates.

<P>See also section 
<A HREF="ayam-5.html#tweennpt">Tween Surfaces Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scinterpunp"></A> 
interpuNP &ndash; interpolate NURBS surface in U direction:
<UL>
<LI>Synopsis: <CODE>"interpuNP [-order order | -ktype type | -closed (0|1) | -sdlen length | -edlen length]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Interpolate the selected NURBS surfaces
in U direction with desired order and parameterisation type.
Order defaults to 4 and must be higher than 2.
The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.
The interpolation can create a closed surface if requested by the
<CODE>"-closed"</CODE> parameter but this will also increase
the width of the resulting NURBS surface. The default is to
create an open surface for open input surfaces and a closed surface
for closed or periodic input surfaces.

<P>Using the options <CODE>"-sdlen"</CODE> and <CODE>"-edlen"</CODE> (which both default
to 0.0) the length of automatically created start/end derivatives
can be adjusted. If any of these is not 0.0, a different interpolation
algorithm will be used, which increases the width of the resulting NURBS
surface.</P>
<P>The surface will interpolate all current control points after the
interpolation and the position of certain control points will be
changed in this process so that, after interpolation, the new control
points will <EM>not</EM> be interpolated by the surface. The surface will
rather interpolate the <EM>old</EM> control point positions.</P>
<P>The u knot type of the interpolated surfaces will be changed to <CODE>"Custom"</CODE>.</P>
<P>If the <CODE>"-closed"</CODE> option is not present, the interpolated surface
will be closed for closed and periodic surfaces.</P>
<P>See also section 
<A HREF="ayam-5.html#interpnpt">Interpolate Surface Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scinterpvnp"></A> 
interpvNP &ndash; interpolate NURBS surface in V direction:
<UL>
<LI>Synopsis: <CODE>"interpvNP [-order order | -ktype type | -closed (0|1) | -sdlen length | -edlen length]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Interpolate the selected NURBS surfaces
in V direction with desired order and parameterisation type.
Order defaults to 4 and must be higher than 2.
The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.
The interpolation can create a closed surface if requested by the
<CODE>"-closed"</CODE> parameter but this will also increase
the height of the resulting NURBS surface. The default is to
create an open surface for open input surfaces and a closed surface
for closed or periodic input surfaces.

<P>Using the options <CODE>"-sdlen"</CODE> and <CODE>"-edlen"</CODE> (which both default
to 0.0) the length of automatically created start/end derivatives
can be adjusted. If any of these is not 0.0, a different interpolation
algorithm will be used, which increases the height of the resulting NURBS
surface.</P>
<P>The surface will interpolate all current control points after the
interpolation and the position of certain control points will be
changed in this process so that, after interpolation, the new control
points will <EM>not</EM> be interpolated by the surface. The surface will
rather interpolate the <EM>old</EM> control point positions.</P>
<P>The v knot type of the interpolated surfaces will be changed to <CODE>"Custom"</CODE>.</P>
<P>See also section 
<A HREF="ayam-5.html#interpnpt">Interpolate Surface Tool</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scapproxnp"></A> 
approxNP &ndash; approximate NURBS surface:<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
<UL>
<LI>Synopsis: <CODE>"approxNP [-m mode | -aw awidth | -ah aheight | -ou uorder | -ov vorder | -ktu typeu | -ktv typev | -cu (0|1) | -cv (0|1) | -tp tess]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Approximate the selected NURBS surfaces
in desired direction(s) with a new surface of desired dimensions
(awidth, aheight), orders and parameterisation type.

<P>The mode parameter determines whether to just approximate along U (0),
V (1), U and then V (2), or V and then U (3).
If just approximating in one direction, the approximation parameters
of the other direction will be ignored and the values from the original
surface will be used instead.</P>
<P>The order parameters default to 4 and must be higher than 2.</P>
<P>The parameterisation type must be one of 0 &ndash; Chordal,
1 &ndash; Centripetal, or 2 &ndash; Uniform, default is Chordal.</P>
<P>The approximation can create a closed surface if requested by the
<CODE>"-cu"</CODE> / <CODE>"-cv"</CODE> parameter(s).</P>
<P>The knot type of the approximated surfaces will be changed to <CODE>"Custom"</CODE>.</P>
<P>See also section 
<A HREF="ayam-5.html#approxnpt">Approximate Surface Tools</A>.</P>
</LI>
</UL>
</P>




<P><SUB><BR></SUB>
<A NAME="scbreaknp"></A> 
breakNP &ndash; break NURBS patch into curves:
<UL>
<LI>Synopsis: <CODE>"breakNP [-r | -a | (-u | -v)]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Breaks the selected NPatch objects into NURBS curves,
along parametric dimension U or V (depending on whether the option
<CODE>"-u"</CODE> or <CODE>"-v"</CODE> is specified, default is U).

<P>If the option <CODE>"-a"</CODE> is specified, the transformations of the NPatch
objects will be applied to the control points and the NCurve objects
will be created with default transformation attributes, otherwise the
control points will be copied verbatim and the NCurve objects will get
the transformation attributes of the respective NPatch.</P>
<P>If the option <CODE>"-r"</CODE> is specified, the new curve objects will
replace each NPatch object instead of being appended to the current
level. They will also be selected immediately.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See also section 
<A HREF="ayam-5.html#breaknpt">Break into Curves Tool</A>.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scbuildnp"></A> 
buildNP &ndash; build NURBS patch from curves:
<UL>
<LI>Synopsis: <CODE>"buildNP [-r|-a (0|1) | -o order | -t type | -k knottype]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Builds a NURBS patch from the selected NURBS curves.
The width of the new patch depends on the number of provided curves
and the surface type.

<P>The option <CODE>"-a"</CODE> controls, whether the transformation attributes
of the NURBS curves shall be applied to the respective control points
before building the patch (default 1 &ndash; yes).</P>
<P>The option <CODE>"-o"</CODE> determines the desired order of the surface in U
direction (default min(4,width)).</P>
<P>The option <CODE>"-t"</CODE> allows to set a surface type
(0 &ndash; open, 1 &ndash; closed, 3 &ndash; periodic; default 0).</P>
<P>The option <CODE>"-k"</CODE> allows to set a knot type (0 &ndash; Bezier,
1 &ndash; B-Spline, 2 &ndash; NURB, 4 &ndash; Chordal,
5 &ndash; Centripetal, default 2 &ndash; NURB). Custom knots
are not supported.</P>
<P>If the option <CODE>"-r"</CODE> is present, the new NPatch objects will
replace the first selected NCurve object instead of being appended to
the current level, the other NCurve objects will be removed.</P>
<P>See also section 
<A HREF="ayam-5.html#buildnpt">Build from Curves Tool</A>.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="sciscompnp"></A> 
isCompNP:
<UL>
<LI>Synopsis: <CODE>"isCompNP [(-u</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-v) | -l level]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command returns <CODE>1</CODE> if the selected NURBS surfaces
are compatible (i.e.&nbsp;defined on the same knot vector), otherwise it
returns <CODE>0</CODE>.

<P>If the option <CODE>"-u"</CODE> is given, only the U dimension will be checked.<BR>
If the option <CODE>"-v"</CODE> is given, only the V dimension will be checked.</P>
<P>If <CODE>"level"</CODE> is <CODE>0</CODE>, only the orders of the surfaces
are compared.<BR>
If <CODE>"level"</CODE> is <CODE>1</CODE>, width/height and orders of the surfaces are
compared.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scmakecompnp"></A> 
makeCompNP &ndash; make NURBS surfaces compatible
<UL>
<LI>Synopsis: <CODE>"makeCompNP [-f | (-u</CODE>&thinsp;<CODE>|</CODE>&thinsp;<CODE>-v) | -l level]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: makes the selected NURBS surfaces compatible
i.e.&nbsp;of the same order and defined on the same knot vectors.

<P>If the option <CODE>"-f"</CODE> is present, there will be no prior compatibility check.</P>
<P>If the option <CODE>"-u"</CODE> is given, only the U dimension will be adapted.<BR>
If the option <CODE>"-v"</CODE> is given, only the V dimension will be adapted.</P>
<P>If <CODE>"level"</CODE> is <CODE>0</CODE>, only the orders will be adapted.<BR>
If <CODE>"level"</CODE> is <CODE>1</CODE>, only the orders and lengths will be adapted.</P>
<P>See also section 
<A HREF="ayam-5.html#makecompst">Make Compatible Tool</A>.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="sccurvatnp"></A> 
curvatNP &ndash; compute Gaussian curvature:
<UL>
<LI>Synopsis: <CODE>"curvatNP [-r] -u u -v v"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Compute and return the Gaussian curvature of the
selected NURBS surface or NURBS surface providing object at the
designated parametric values <CODE>u</CODE> and <CODE>v</CODE>.<BR>
<P>If the option <CODE>"-r"</CODE> is present, the parametric values are interpreted
in a relative way and should therefore be in the range
[0,&thinsp;1].</P>
<P>If multiple objects are selected, a list of curvature values is returned.</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
<A NAME="scfairnp"></A> 
fairNP &ndash; improve surface shape:
<UL>
<LI>Synopsis: <CODE>"fairNP [-m mode | -w | -t tol]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Improve the surface shape by moving control points
so that the curvature is distributed more evenly.<BR>
<P>The value of the option <CODE>"-m"</CODE> (mode) controls how the surface
shall be faired: 0 &ndash; U direction only,
1 &ndash; along V direction only,
2 &ndash; first along U direction, then along V direction, and
3 &ndash; first along V direction, then along U direction.
The mode defaults to 0 &ndash; U direction only.</P>
<P>If the option <CODE>"-w"</CODE> (worst) is present, only the point that would
move the farthest distance in a row/column will be changed.</P>
<P>If a tolerance value is present the processed control points do not move
more than the given value.</P>
<P>If points are selected, only these will be processed.</P>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
<A NAME="sctobasispm"></A> 
tobasisPM &ndash; convert PatchMesh to a different
basis:
<UL>
<LI>Synopsis: <CODE>"tobasisPM [-t type | -s step | -b basis]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Converts all selected bicubic PatchMesh objects to a
different basis. Both dimensions will be converted to the same
basis; it is not an error if one dimension is already of the
target basis type.

<P>The option <CODE>"-t"</CODE> controls the new basis type
(0 &ndash; <CODE>"Bezier"</CODE>, 1 &ndash; <CODE>"B-Spline"</CODE>,
2 &ndash; <CODE>"Catmull-Rom"</CODE>, 3 &ndash; <CODE>"Hermite"</CODE>,
4 &ndash; <CODE>"Power"</CODE>, 5 &ndash; <CODE>"Custom"</CODE>),
default is 1 (conversion to <CODE>"B-Spline"</CODE>).</P>
<P>The option <CODE>"-s"</CODE> determines the new step size (1 to 4), it defaults
to the natural step size of the target basis type and thus can be
omitted safely, unless the target type is <CODE>"Custom"</CODE>, in which case the step
size <EM>must</EM> be specified.</P>
<P>The option <CODE>"-b"</CODE> allows to convert to a custom basis and thus
is a list of 16 floating point values specifying a 4 by 4 basis matrix
in column major order. If <CODE>"-b"</CODE> is given, the target type defaults
to <CODE>"Custom"</CODE> and the option <CODE>"-t"</CODE> can be omitted.</P>
</LI>
<LI>Example:<BR>
<SUP>&nbsp;</SUP><B><CODE>"tobasisPM -t 0"</CODE></B><BR>
converts the selected bicubic patch meshes to the Bezier basis.</LI>
</UL>
</P>
<P><SUB><BR></SUB>
<A NAME="sctobasisbc"></A> 
tobasisBC &ndash; convert BCurve objects to a different
basis:
<UL>
<LI>Synopsis: <CODE>"tobasisBC [-t type | -s step | -b basis]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Converts all selected BCurve objects to a
different basis.

<P>The option <CODE>"-t"</CODE> controls the new basis type
(0 &ndash; <CODE>"Bezier"</CODE>, 1 &ndash; <CODE>"B-Spline"</CODE>,
2 &ndash; <CODE>"Catmull-Rom"</CODE>, 3 &ndash; <CODE>"Hermite"</CODE>,
4 &ndash; <CODE>"Power"</CODE>, 5 &ndash; <CODE>"Custom"</CODE>),
default is 1 (conversion to <CODE>"B-Spline"</CODE>).</P>
<P>The option <CODE>"-s"</CODE> determines the new step size (1 to 4), it defaults
to the natural step size of the target basis type and thus can be
omitted safely, unless the target type is <CODE>"Custom"</CODE>, in which case the step
size <EM>must</EM> be specified.</P>
<P>The option <CODE>"-b"</CODE> allows to convert to a custom basis and thus
is a list of 16 floating point values specifying a 4 by 4 basis matrix
in column major order. If <CODE>"-b"</CODE> is given, the target type defaults
to <CODE>"Custom"</CODE> and the option <CODE>"-t"</CODE> can be omitted.</P>
</LI>
<LI>Example:<BR>
<SUP>&nbsp;</SUP><B><CODE>"tobasisBC -t 0"</CODE></B><BR>
&nbsp;&nbsp;converts the selected basis curves to the Bezier basis.</LI>
</UL>
</P>




<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scipomesh"></A> Manipulating PolyMesh Objects</H3>

<P>These are more specialized commands to change PolyMesh
properties:</P>


<P>
<A NAME="scgenfnPo"></A> 
genfnPo &ndash; generate face normals:
<UL>
<LI>Synopsis: <CODE>"genfnPo"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Generate face normals for the selected PolyMesh object(s)
using the robust Newell algorithm.

<P>The generated normals will be stored in a PV tag.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scgensnPo"></A> 
gensnPo &ndash; generate smooth normals:
<UL>
<LI>Synopsis: <CODE>"gensnPo"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Generate smooth vertex normals for the selected
PolyMesh object(s), averaging the surrounding face normals of each vertex.
The face normals will be weighted by the vertex face-centroid distance,
which takes both, face area and face shape, into account.
Vertices of hole loops will just get the respective face normal.

<P>Already existing vertex normals will be destroyed.</P>
<P>If face normals already exist, they will be used, otherwise, new face
normals will be generated using the same algorithm as implemented in the
<CODE>"genfnPo"</CODE> command above.</P>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scremsnPo"></A> 
remsnPo &ndash; remove smooth normals:
<UL>
<LI>Synopsis: <CODE>"remsnPo"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Removes all smooth/vertex normals from the selected
PolyMesh object(s).</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scflipPo"></A> 
flipPo &ndash; flip normals or loops:
<UL>
<LI>Synopsis: <CODE>"flipPo [0|1|2]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Flips smooth/vertex normals of the selected
PolyMesh object(s). By default, and if the parameter is 0, also all
loops will be flipped. If the parameter is 1, only the normals are
reversed. If the parameter is 2, only the loops are reversed.</LI>
</UL>
</P>




<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scipoints"></A> Manipulating Points and Normals</H3>

<P>Use these commands to read or manipulate the control points or normals of
objects that support point editing.</P>
<P>
<A NAME="scgetpnt"></A> 
getPnt &ndash; get point(s):
<UL>
<LI>Synopsis: <CODE>"getPnt [-trafo | -world | -eval | -relative] (index | indexu indexv | u | u v) [(varx vary varz [varw] | -vn varname | -all [varname] | -sel [varname])]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Get a control point of the currently selected object
and write the coordinate values into the variables <CODE>varx</CODE>, <CODE>vary</CODE>,
<CODE>varz</CODE>, and (if the object supports rational coordinates) <CODE>varw</CODE>.

<P>The index arguments needed depend on the type of the selected
object, e.g.&nbsp;reading the points of a NURBS curve requires just one
index parameter (<CODE>index</CODE>), whereas reading the points of a NURBS
patch requires two index parameters (<CODE>indexu</CODE> and <CODE>indexv</CODE>) to be
specified.</P>
<P>If the optional argument <CODE>"-trafo"</CODE> is given, the coordinates
will additionally be transformed by the values given in the objects
Transformation property.</P>
<P>If the optional argument <CODE>"-world"</CODE> is used, the coordinates
will additionally be transformed to world space.</P>
<P>If the optional argument <CODE>"-eval"</CODE> is specified, the <CODE>"indexu"</CODE>
and <CODE>"indexv"</CODE> values are interpreted as parametric values of a
NURBS curve or surface and the corresponding point on the curve or
surface is delivered in <CODE>varx</CODE>, <CODE>vary</CODE>, and <CODE>varz</CODE>.</P>
<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
value for NURBS curve or surface evaluation is interpreted in a relative
way and must consequently be in the range [0,1].</P>
<P>If the alternative argument <CODE>"-vn"</CODE> is given, the coordinate values
will be appended to the list variable specified by <CODE>"varname"</CODE>.</P>
<P>If the alternative argument <CODE>"-all"</CODE> is used, all coordinate values
of the selected objects will be appended to the list variable
specified by <CODE>"varname"</CODE>.</P>
<P>If the alternative argument <CODE>"-sel"</CODE> is used, the coordinate values
of the currently selected points of the selected objects will be appended
to the list variable specified by
<CODE>"varname"</CODE>.<SMALL TITLE="Since 1.28."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If any of the variable name arguments are omitted, the command returns the
respective results.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

</LI>
<LI>Notes: In Ayam versions prior to 1.20, only global variables
were written, this is no longer the case.</LI>
<LI>Examples:<SUB>&nbsp;</SUB>
<OL>
<LI><B><CODE>"getPnt 1 x y z w"</CODE></B><SUP>&nbsp;</SUP><BR>
gets the coordinate values of the second point of the selected NURBS
curve and writes the values to the variables <CODE>"x"</CODE>, <CODE>"y"</CODE>, <CODE>"z"</CODE>,
and <CODE>"w"</CODE>.</LI>
<LI><B><CODE>"getPnt -eval 0.5 x y z"</CODE></B><BR>
gets the curve point at parametric value <CODE>"0.5"</CODE> and writes the
coordinate values to the variables <CODE>"x"</CODE>, <CODE>"y"</CODE>, and <CODE>"z"</CODE>.</LI>
</OL>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
setPnt &ndash; set point(s):
<A NAME="scsetpnt"></A> 
<UL>
<LI>Synopsis:
<CODE>"setPnt [-world] (index | indexu indexv) (x y z [w] | -vn varname) | (-all|-sel) varname)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Set a control point of the
currently selected object to the coordinates x, y, z, and w or to
coordinates from a list, or set all control points from a list of
coordinate values.

<P>The index arguments needed depend on the type of the selected
object, e.g.&nbsp;manipulating the points of a NURBS curve requires just one
index parameter (index), whereas manipulating the points of a NURBS
patch requires two index parameters (indexu and indexv) to be specified.</P>
<P>If the optional parameter <CODE>"-world"</CODE> is given, the coordinate values are
expressed in world space and will be transformed to appropriate
object space coordinates before setting.</P>
<P>If the optional parameter <CODE>"w"</CODE> is omitted,
but the selected object has rational points, a default value of 1.0 will
be used for the weight.</P>
<P>If the alternative parameter <CODE>"-vn"</CODE> is used, the coordinate
values will be read from the variable specified by <CODE>"varname"</CODE>
which must be a list of double values.</P>
<P>If the alternative parameter <CODE>"-all"</CODE> is provided, all control
points of the selected objects will be set and the coordinate
values will be read from the variable specified by <CODE>"varname"</CODE>
which must be a list of double values.</P>
<P>If the alternative argument <CODE>"-sel"</CODE> is used, all selected control
points of the selected objects will be set and the coordinate
values will be read from the variable specified by <CODE>"varname"</CODE>
which must be a list of double values.<SMALL TITLE="Since 1.28."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>When reading data from list variables, no precision will be lost
as there are no double-string-double conversions involved.</P>

</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"setPnt 1 0.0 0.2 0.3 1.0"</CODE></B><SUP>&nbsp;</SUP><BR>
sets the coordinate values of the second point of the selected NURBS
curve object to <CODE>"0.0 0.2 0.3 1.0"</CODE>.</LI>
<LI><B><CODE>"setPnt -world 0 0 0 0"</CODE></B><BR>
sets the first point of the selected NURBS
curve object to the world origin, regardless of the transformation
attributes of the curve object (or any of its potential parent objects).</LI>
<LI><B><CODE>"setPnt 2 1 0.0 0.2 0.3"</CODE></B><BR>
sets the coordinate values of the second point in the third column of
the control mesh of the selected NURBS
patch object to <CODE>"0.0 0.2 0.3 1.0"</CODE>.</LI>
</OL>
</LI>
</UL>
</P>



<P><SUB><BR></SUB>
getNormal &ndash; get normal(s):
<A NAME="scgetnormal"></A> 
<UL>
<LI>Synopsis: <CODE>"getNormal [-cv | -relative] (index | u v) [(varx vary varz | -vn varname)]"</CODE>
</LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Get a normal of the currently selected object
and write the normal vector component values into the variables
<CODE>varx</CODE>, <CODE>vary</CODE>, and <CODE>varz</CODE>.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>

<P>This operation fails for PolyMesh objects, if there are no vertex normals.</P>

<P>The index arguments needed depend on the type of the selected
object, e.g.&nbsp;reading the normal of a PolyMesh requires just one
index parameter (<CODE>index</CODE>), whereas evaluating the normal of a NURBS
patch requires two parameters (<CODE>u</CODE> and <CODE>v</CODE>) to be
specified.</P>
<P>If the optional argument <CODE>"-cv"</CODE> is specified, the <CODE>"u"</CODE>
and <CODE>"v"</CODE> values are interpreted as index parameters and the surface
is not evaluated but the normal is computed from the surrounding control
points.</P>
<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
values for NURBS surface evaluation are interpreted in a relative
way and must consequently be in the range [0,1].</P>
<P>If the alternative argument <CODE>"-vn"</CODE> is given, the coordinate values
will be appended to the list variable specified by <CODE>"varname"</CODE>.</P>

</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"getNormal 1 x y z"</CODE></B><SUP>&nbsp;</SUP><BR>
gets the coordinate values of the second point of the selected PolyMesh
and writes the values to the variables <CODE>"x"</CODE>, <CODE>"y"</CODE>, <CODE>"z"</CODE>.
</LI>
<LI><B><CODE>"getNormal 0.5 0.5"</CODE></B><BR>
evaluate the normal of the selected NURBS surface at parametric
values <CODE>"0.5"</CODE> <CODE>"0.5"</CODE> and returns the result as list.</LI>
</OL>
</LI>
</UL>
</P>
<P>setNormal &ndash; set normal:
<A NAME="scsetnormal"></A> 
<UL>
<LI>Synopsis:
<CODE>"setNormal index (x y z | -vn varname)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Set a vertex normal of the selected PolyMesh object(s)
to the values delivered by the x, y, and z arguments, or to
values from a list.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>

<P>This operation fails if there are currently no vertex normals.</P>

<P>If the alternative parameter <CODE>"-vn"</CODE> is used, the normal
values will be read from the variable specified by <CODE>"varname"</CODE>
which must be a list of double values.</P>
<P>When reading data from list variables, no precision will be lost
as there are no double-string-double conversions involved.</P>

</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"setNormal 1 0.0 0.2 0.3"</CODE></B><SUP>&nbsp;</SUP><BR>
sets the normal values of the second control point of the selected
PolyMesh object to <CODE>"0.0 0.2 0.3"</CODE>.</LI>
<LI><B><CODE>"setNormal 0 -vn normal"</CODE></B><SUP>&nbsp;</SUP><BR>
sets the normal values of the first control point of the selected
PolyMesh object to the values from the list variable <CODE>"normal"</CODE>.</LI>
</OL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
getTangent &ndash; get first
derivative(s)/tangent(s):
<A NAME="scgettangent"></A> <SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
<UL>
<LI>Synopsis: <CODE>"getTangent [-relative] (u | u v) (varx vary varz [varu varv varw] | -vn varname)"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Compute the first derivative/tangent of the
currently selected parametric
curve object(s) and write the tangent vector component values into the
variables <CODE>varx</CODE>, <CODE>vary</CODE>, and <CODE>varz</CODE>; for parametric surface
objects both tangents (in u and v direction) will be computed
and, consequently, also <CODE>varu</CODE>, <CODE>varv</CODE>, and <CODE>varw</CODE> will be
written to.
<P>If the optional argument <CODE>"-relative"</CODE> is specified, the parametric
values are interpreted in a relative
way and must consequently be in the range [0,1].</P>
<P>If the alternative argument <CODE>"-vn"</CODE> is given, the resulting values
will be appended to the list variable specified by <CODE>"varname"</CODE>.</P>

</LI>
<LI>Examples:
<OL>
<LI><B><CODE>"getTangent 0.5 x y z"</CODE></B><SUP>&nbsp;</SUP><BR>
compute the first derivative/tangent values of the selected NURBS curve
and writes the values to the variables <CODE>"x"</CODE>, <CODE>"y"</CODE>, <CODE>"z"</CODE>.
</LI>
<LI><B><CODE>"getTangent 0.5 0.5"</CODE></B><BR>
evaluate the first derivatives of the selected NURBS surface at parametric
values <CODE>"0.5"</CODE> <CODE>"0.5"</CODE> and returns the result as list.</LI>
</OL>
</LI>
</UL>
</P>




<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciupd"></A> Updating the GUI</H3>

<P>These procedures update various parts of the Ayam user interface:</P>


<P>
<A NAME="scrv"></A> 
rV &ndash; redraw all views:
<UL>
<LI>Synopsis: <CODE>"rV"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Redraws all currently open views, except for
iconified views and views where automatic redraw has been turned off.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scus"></A> 
uS &ndash; update select:
<UL>
<LI>Synopsis: <CODE>"uS [update_prop maintain_selection]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Update the object listbox or tree view after a change
to the object hierarchy.
<P>If update_prop is 0 no update of the property GUIs will take place.</P>
<P>If maintain_selection is 1 the old selection will be established again.</P>
<P>If both arguments are omitted update_prop defaults
to 1 and maintain_selection to 0.</P>
</LI>
<LI>Deficiencies: uS completely removes the object tree from
the tree widget and rebuilds it, which can be a very time consuming
operation (depending on the complexity of the scene). There are some
options to speed this process up:
<UL>
<LI>If there were just changes to the current level (and below),
the global array entry <CODE>"ay(ul)"</CODE> (UpdateLevel) may be set
to the current level before calling <CODE>"uS"</CODE>. This will not remove
and update the complete scene but just the part below <CODE>"ay(ul)"</CODE>.
Example:
<HR>
<PRE>
global ay; set ay(ul) $ay(CurrentLevel); uS;
</PRE>
<HR>
.</LI>
<LI>If objects have been created and thus just need to be
added to the current level of the object tree view, the command
<CODE>"uCR"</CODE> may be used instead of <CODE>"uS"</CODE>.</LI>
<LI>If just names or types of objects of the current level changed,
the command <CODE>"uCL cl"</CODE> may be used instead of <CODE>"uS"</CODE>.</LI>
</UL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scucl"></A> 
uCL &ndash; update current level:
<UL>
<LI>Synopsis: <CODE>"uCL mode [args]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Update only the current level of the object listbox
or tree view after changes. See also the discussion of <CODE>"uS"</CODE> above.
The parameter <CODE>"mode"</CODE> may be "cl" or "cs", where "cl" is the normal
operation mode, and "cs" just clears the selection.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scucr"></A> 
uCR &ndash; update current level after create:
<UL>
<LI>Synopsis: <CODE>"uCR"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Update only the current level of the object listbox
or tree view after objects have been created and need to be added to
the current level. See also the discussion of <CODE>"uS"</CODE> above.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scplb_update"></A> 
plb_update &ndash; property listbox update:
<UL>
<LI>Synopsis: <CODE>"plb_update"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Clear the current property GUI, ask the currently
selected object for a list of properties and insert them in the
property listbox, then rebuild the property GUI of the property
with the same index in the property listbox
as the property selected before plb_update was started (this is not
necessarily a property of the same type).</LI>
</UL>
</P>
<P>Since Ayam 1.13 it is also possible to automatically run GUI updating
commands in the console by using <CODE>&lt;Shift+Return&gt;</CODE> instead
of <CODE>&lt;Return&gt;</CODE>. The commands from the hidden preference setting
<CODE>"AUCommands"</CODE> will be executed after the commands from the command
line, if the <CODE>&lt;Shift&gt;</CODE> key is held down. <CODE>&lt;Shift+Return&gt;</CODE>
may also be used without commands on the command line.
By default, the <CODE>"AUCommands"</CODE> are <CODE>"uS; rV;"</CODE>, leading to
updated object tree, property GUI, and views.</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciprefs"></A> Managing Preferences</H3>

<P>These commands manage preferences data:</P>
<P>
<A NAME="scgetprefs"></A> 
getPrefs &ndash; get preferences data:
<UL>
<LI>Synopsis: <CODE>"getPrefs"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Copy preferences data from the C to the Tcl context.</LI>
</UL>
</P>


<P>
<A NAME="scsetprefs"></A> 
<SUB><BR></SUB>
setPrefs &ndash; set preferences data:
<UL>
<LI>Synopsis: <CODE>"setPrefs"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: Copy preferences data from the Tcl to the C context.
This is necessary after a change to the global Tcl array <CODE>"ayprefs"</CODE>
to let all changes take effect.</LI>
</UL>
</P>
<P>See also section 
<A HREF="ayam-2.html#prefs">Preferences</A></P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scicust"></A> Custom Objects&thinsp;/&thinsp;Plugins</H3>

<P>This command manages custom objects (plugins):</P>
<P>
<A NAME="scio_lc"></A> <A NAME="scloadPlugin"></A> 
loadPlugin &ndash; load custom object&thinsp;/&thinsp;plugin:
<UL>
<LI>Synopsis: <CODE>"loadPlugin name"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Load a custom object&thinsp;/&thinsp;plugin.
If <CODE>name</CODE> is a complete
filename and the designated file exists, it will be loaded directly.
Otherwise, the file to load will be searched for in the list of configured
plugin directories (see <CODE>"Plugins"</CODE> preference setting).

<P>Note that it is currently not possible to unload a custom object or plugin
from Ayam.</P>
</LI>
</UL>
</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scifall"></A> Applying Commands to a Number of Objects</H3>

<P>These procedures and commands help to apply arbitrary commands
to a number of selected objects.</P>



<P>
<A NAME="scforall"></A> 
forAll:
<UL>
<LI>Synopsis: <CODE>"forAll [(-recursive|-r) r | (-type|-t) t] command"</CODE></LI>
<LI>Background: depends,&nbsp;&nbsp;Undo: depends,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: The forAll procedure executes command for all
objects that have been selected currently, or for every object
of the current level if nothing has been selected.

<P>If <CODE>r</CODE> is 1 (this is the default) then forAll will recurse into
every object (if it has child objects) before the execution of command.
If <CODE>r</CODE> is 2, the recursion will happen after the execution of command.
If <CODE>r</CODE> is 0, only objects from the current level will be processed.</P>
<P>If the <CODE>"-type"</CODE> option is given, only objects of the specified type
<CODE>t</CODE> will be processed.</P>
<P>Prior to Ayam 1.22, potential errors from the command(s) were suppressed and
processing continued regardless. But this made interactive usage and
debugging unnecessarily difficult.
From 1.22 on, errors are reported to the user and processing immediately
stops. Errors may still be suppressed using the <CODE>"catch"</CODE> command
like this:
<CODE>"forAll { catch { commands } }"</CODE></P>
<P>As the command will potentially be called multiple times, result
values of any kind can not be delivered using the <CODE>"return"</CODE>
command but should rather be collected in global variables.
In fact, returning any value that is not <CODE>-1</CODE> will be interpreted
as error and the processing will stop immediately.
Returning <CODE>-1</CODE> in a recursive forAll will stop the processing
without raising an error.</P>
<P>The global variable <CODE>"ay(CurrentLevel)"</CODE> will be maintained while
a recursive forAll browses the scene. In addition, the global variable
<CODE>"i"</CODE> will be set to the index of the current object.</P>
<P>Note that forAll will run slowly if a property GUI is displayed.
If the current property is de-selected first (using e.g.&nbsp;the property
context menu), it will run much faster.</P>
<P>Furthermore, the current selection is correctly
maintained.<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

</LI>
<LI>Deficiencies:
<UL>
<LI>A recursive forAll will
e.g.&nbsp;also descend into NURBS patches (if they have trim curves) and apply
the command to the trim curves, which might not exactly be intended.
In this case, the <CODE>"-type"</CODE> option can be used.</LI>
<LI>The command will not have access to global arrays unless
e.g.&nbsp;one of the following constructs is in use:

<P><CODE>"forAll { uplevel #0 { commands } }"</CODE></P>
<P><CODE>"forAll { global arrayname; commands }"</CODE></P>

</LI>
<LI>It is not possible to use commands that change the object
hierarchy (e.g.&nbsp;deleting or inserting objects). The commands
may just modify existing objects.</LI>
</UL>
</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scwithob"></A> 
withOb &ndash; execute a command on certain selected object(s):
<UL>
<LI>Synopsis: <CODE>"withOb index [do] command"</CODE></LI>
<LI>Background: depends on command,&nbsp;&nbsp;Undo: depends on command,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: Use this command to execute command on a
single object (designated by the zero based index) from a multiple selection
without changing the selection state of any objects.</LI>
<LI>Example:
<OL>
<LI><B><CODE>"withOb 2 {movOb 0 1 0}"</CODE></B><SUP>&nbsp;</SUP><BR>
moves the third object from multiple selected objects. All objects stay selected.</LI>
</OL>
</LI>
</UL>
</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scio"></A> Scene IO</H3>

<P>These commands help to load scenes from and save them to Ayam scene
files:</P>



<P>
<A NAME="screplacescene"></A> 
replaceScene:
<UL>
<LI>Synopsis: <CODE>"replaceScene filename"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: clears the current scene, then loads a new scene
from the file designated by the <CODE>"filename"</CODE> parameter.</LI>
<LI>Notes: In contrast to using the main menu,
further house keeping tasks detailed
in section 
<A HREF="ayam-8.html#opensf">Opening Scene Files</A>
will <EM>not</EM> be executed. In particular, this command
does <EM>not</EM> check or modify the scene changed state and does <EM>not</EM> set
the most recently used list. Furthermore, automatic import is not working.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scinsertscene"></A> 
insertScene:
<UL>
<LI>Synopsis: <CODE>"insertScene filename"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: inserts a scene from the file designated by the
<CODE>"filename"</CODE> parameter.</LI>
<LI>Notes: In contrast to using the main menu,
some house keeping tasks detailed
in section 
<A HREF="ayam-8.html#insertsf">Inserting Scene Files</A>
will <EM>not</EM> be executed. In particular, this command
does <EM>not</EM> modify the scene changed state.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scsavescene"></A> 
saveScene:
<UL>
<LI>Synopsis: <CODE>"saveScene filename [selected]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: saves the current scene to the file designated by the
<CODE>"filename"</CODE> parameter. If the optional parameter <CODE>"selected"</CODE> is 1,
only the selected objects will be saved.</LI>
<LI>Notes: In contrast to using the main menu,
some house keeping tasks detailed
in section 
<A HREF="ayam-8.html#savesf">Saving Scene Files</A>
will <EM>not</EM> be executed. In particular, this command
does <EM>not</EM> modify the scene changed state and does <EM>not</EM> set
the most recently used list. Furthermore, automatic export and
saving of window geometries are not working.</LI>
</UL>
</P>


<P><SUB><BR></SUB>
<A NAME="scnewscene"></A> 
newScene:
<UL>
<LI>Synopsis: <CODE>"newScene"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: clears the current scene.</LI>
<LI>Notes:
In contrast to using the main menu, this command does <EM>not</EM> check
or modify the scene changed state.</LI>
</UL>
</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sciribex"></A> RIB Export</H3>

<P>This command allows to export the current scene to a RenderMan
Interface Bytestream (RIB):</P>



<P>
<A NAME="scwrib"></A> 
wrib &ndash; RIB export:
<UL>
<LI>Synopsis:
<CODE>"wrib filename [-image imagename] [-smonly | -selonly | -objonly]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: exports the current scene to a RIB file designated
by <CODE>"filename"</CODE>.

<P>If the argument <CODE>"-image"</CODE> is given, the RIB file
will create an image file named <CODE>"imagename"</CODE> upon rendering. The export
will use the camera transformation from the currently selected Camera
object.</P>
<P>If the argument <CODE>"-smonly"</CODE> is provided, a RIB to render shadow maps
will be created and the argument of <CODE>"-image"</CODE> will be ignored.
See also section 
<A HREF="ayam-4.html#shadowmaps">Using ShadowMaps</A>.</P>
<P>If the argument <CODE>"-selonly"</CODE> is used, only the selected (geometric)
objects will be exported, which will result in a RIB file not
suitable for rendering (no setup, camera transformation, or lights
are in it) but for inclusion into other scenes via RiArchive.
See also section 
<A HREF="ayam-4.html#riincobj">RiInc Object</A>.</P>
<P>Likewise <CODE>"-objonly"</CODE> leads to a RIB file containing all objects in the
scene but not suitable for rendering.</P>
<P>The <CODE>"wrib"</CODE> command always needs a selected camera object
(unless the <CODE>"-selonly"</CODE> or <CODE>"-objonly"</CODE> options are given); if
there is none or if the camera transformations of the camera associated
with a view window shall be used, the corresponding Togl callback for
the view might be used like this instead:
<HR>
<PRE>
.view1.f3D.togl wrib -file filename.rib
</PRE>
<HR>

The Togl callback understands the same options as the <CODE>"wrib"</CODE>
command.</P>
</LI>
<LI>Notes: In Ayam versions prior to 1.15, the filename had to be prepended
by a <CODE>"-filename "</CODE>, this is no longer the case.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scierr"></A> Reporting Errors</H3>

<P>This command is for error reporting from scripts:</P>



<P>
<A NAME="scayerror"></A> 
ayError:
<UL>
<LI>Synopsis: <CODE>"ayError code place detail"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: This command reports errors or warnings.
<CODE>ayError</CODE> should be preferred to <CODE>puts</CODE> because the error
reporting mechanism of Ayam features consistently formatted output,
compression of repeated messages, and logging.
The code parameter should be one of: 1 &ndash; warning, 2 &ndash; error,
3 &ndash; flush messages, 4 &ndash; unspecified output.
There are more codes defined (see ayam.h, look for Return/Error Codes)
but they are generally not needed in the Tcl script context.
The place parameter should describe the procedure where the error occurred.
The detail parameter is the string to be output.</LI>
<LI>Notes: The actual output in the Ayam console depends on the
preference option <CODE>"ErrorLevel"</CODE> see section
<A HREF="ayam-2.html#prefmisc">Miscellaneous Preferences</A>.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scipgui"></A> Property GUI Management</H3>

<P>These procedures help to manage property GUIs.
See also
section 
<A HREF="#ayproparr">Property Management and Data Arrays</A>.</P>
<P>
<A NAME="scaddpropertygui"></A> 
addPropertyGUI:
<UL>
<LI>Synopsis: <CODE>"addPropertyGUI name"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure sets up a property GUI management
array and creates an enclosing frame for GUI elements whose window
name will be returned.

<P>The array will be set up in a way that the data array of the property
will be named as the property with the string <CODE>Data</CODE> appended,
i.e.&nbsp;for <CODE>MyProperty</CODE> it will be <CODE>MyPropertyData</CODE>.</P>
<P>The get/set procedure entries will be left empty.</P>
<P>After the creation of property GUI elements, <CODE>"NP"</CODE> tags must
be used to make the new property visible to the user.
See also section 
<A HREF="ayam-4.html#nptag">NP (New Property) Tag</A>.</P>
<P>A complete example is available in
section 
<A HREF="ayam-4.html#scriptobjex">Script Object Examples</A>.</P>

</LI>
<LI>Example:
<B><CODE>"set w [addPropertyGUI MyProperty]"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB></P>
<P>The following procedures add user interface elements to the
property GUIs created by <CODE>"addPropertyGUI"</CODE>.</P>
<P>addParam:
<UL>
<LI>Synopsis: <CODE>"addParam window arrayname paramname [defaults]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a single
integer or floating point number parameter.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The <CODE>"defaults"</CODE> parameter is a list
of default values. Those values will be presented to the user as an
additional drop down menu on the right side of the interface element.</P>
</LI>
<LI>Example:
<B><CODE>"addParam $w MyPropertyData MyFloat {0.1 0.5 1.5}"</CODE></B></LI>
</UL>
</P>



<P><SUB><BR></SUB>
addString:
<UL>
<LI>Synopsis: <CODE>"addString window arrayname paramname [defaults]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a single
string parameter.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The <CODE>"defaults"</CODE> parameter is a list
of default values. Those values will be presented to the user as an
additional drop down menu on the right side of the interface element.
If the list contains an entry <CODE>"..."</CODE>, selecting this entry will
clear the string entry field and move the input focus to the field.</P>
</LI>
<LI>Example:
<B><CODE>"addString $w MyPropertyData MyString {"a" "b" "abc"}"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addCheck:
<UL>
<LI>Synopsis: <CODE>"addCheck window arrayname paramname [onoffvalues]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a single
boolean parameter realized by a check-button.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The optional <CODE>"onoffvalues"</CODE> parameter is a list of two values that will
be used when setting the corresponding variable when the check-button is
enabled or disabled. The default values are 0 and 1.</P>
</LI>
<LI>Example:
<B><CODE>"addCheck $w MyPropertyData MyBool"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addColor:
<UL>
<LI>Synopsis: <CODE>"addColor window arrayname paramname [defaults]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a single
color parameter.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The <CODE>"defaults"</CODE> parameter is a list
of default values. Those values will be presented to the user as an
additional drop down menu on the right side of the interface element.</P>
</LI>
<LI>Example:
<B><CODE>"addColor $w MyPropertyData MyColor"</CODE></B></LI>
</UL>
</P>



<P><SUB><BR></SUB>
addMatrix:
<UL>
<LI>Synopsis: <CODE>"addMatrix window arrayname paramname"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a
four by four element matrix, e.g.&nbsp;a transformation matrix.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.
The individual matrix value variable names will be formed by appending a
<CODE>"_0"</CODE> to <CODE>"_15"</CODE> to the <CODE>"paramname"</CODE>.</P>
</LI>
<LI>Example:
<B><CODE>"addMatrix $w MyPropertyData MyMatrix"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addMenu:
<UL>
<LI>Synopsis: <CODE>"addMenu window arrayname paramname choices"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a
menu&thinsp;/&thinsp;multiple choice parameter, realized through
a drop down menu. The value of the parameter will be the index
of the chosen menu item.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The <CODE>"choices"</CODE> parameter is a list
of strings that will be presented in the menu.</P>
<P>In contrast to the other user interface element generating procedures,
the corresponding entry in the property data array <EM>must</EM> exist
before this procedure is called.</P>
</LI>
<LI>Example:
<B><CODE>"addMenu $w MyPropertyData MyMenu {Choice1 Choice2}"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addFile:
<UL>
<LI>Synopsis: <CODE>"addFile window arrayname paramname [defaults]"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element for a
file name.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter.</P>
<P>The <CODE>"defaults"</CODE> parameter is a list
of default values. Those values will be presented to the user as an
additional drop down menu on the right side of the interface element.</P>
</LI>
<LI>Notes: There is a variation of this procedure for file names
meant to be used for saving: <CODE>"addSFile"</CODE></LI>
<LI>Example:<BR>
<B><CODE>"addFile $w MyPropertyData MyFile {"/tmp/file1" "/tmp/file2"}"</CODE></B></LI>
</UL>
</P>



<P><SUB><BR></SUB>
addCommand:
<UL>
<LI>Synopsis: <CODE>"addCommand window name text command"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element to let
the user initiate a command with the help of a push-button.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"name"</CODE> parameter is the name of the corresponding
button widget. The names must be unique in each property GUI.</P>
<P>The <CODE>"text"</CODE> parameter is the string to be put on the button.</P>
<P>The <CODE>"command"</CODE> parameter is the command to be executed when the
button is pushed.</P>
</LI>
<LI>Example:
<B><CODE>"addCommand $w b1 PushMe {puts pushed}"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addText:
<UL>
<LI>Synopsis: <CODE>"addText window name text"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element to
display static information, e.g.&nbsp;a parameter section name.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"name"</CODE> parameter is the name of the corresponding
label widget. The names must be unique in each property GUI.</P>
<P>The <CODE>"text"</CODE> parameter is the string to be displayed.</P>
</LI>
<LI>Example:
<B><CODE>"addText $w t1 "Angular Parameters:""</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addInfo:
<UL>
<LI>Synopsis: <CODE>"addInfo window arrayname paramname"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element to
display dynamic textual information.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter whose
value is to be displayed. Whenever the value of this variable changes,
the corresponding label will be updated automatically.</P>
<P>If a second variable named like <CODE>"paramname"</CODE> but with an additional
trailing <CODE>"Ball"</CODE> exists, its value will be displayed as balloon help
text, when the mouse pointer hovers over the label. This way longer or
more complex information can be presented.</P>

</LI>
<LI>Example:
<B><CODE>"addInfo $w MyPropertyData NumGeneratedElems"</CODE></B></LI>
</UL>
</P>


<P><SUB><BR></SUB>
addProgress:
<UL>
<LI>Synopsis: <CODE>"addProgress window arrayname paramname"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element to
display progress information.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the corresponding
data array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of the parameter where
the progress is stored in percent.</P>
</LI>
<LI>Example:
<B><CODE>"addProgress $w MyPropertyData Progress"</CODE></B></LI>
</UL>
</P>

<P><SUB><BR></SUB>
addVSpace:
<UL>
<LI>Synopsis: <CODE>"addVSpace window name height"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds an empty property GUI element with
defined height to improve the layout of a property GUI.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"name"</CODE> parameter is the name of the corresponding
widget. The names must be unique in each property GUI.</P>
<P>The <CODE>"height"</CODE> parameter is the desired height in pixels.</P>
</LI>
<LI>Example:
<B><CODE>"addVSpace $w v1 20"</CODE></B></LI>
</UL>
</P>
<P><SUB><BR></SUB>
addOptionToggle:
<UL>
<LI>Synopsis: <CODE>"addOptionToggle window arrayname paramname text cmd"</CODE></LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds a property GUI element that
allows to toggle the visibility of other property GUI elements.

<P>The <CODE>"window"</CODE> parameter should contain the window name as returned by
<CODE>"addPropertyGUI"</CODE> above.</P>
<P>The <CODE>"arrayname"</CODE> parameter is the name of the property management
array of the property.</P>
<P>The <CODE>"paramname"</CODE> parameter is the name of a variable that contains the
current visibility state.</P>
<P>The <CODE>"text"</CODE> parameter is the text to display on the toggle widget,
this is usually a string like <CODE>"Advanced Options"</CODE>.</P>
<P>The <CODE>"cmd"</CODE> parameter is the name of a procedure that, based on the
current visibility state, creates or destroys the other property GUI
elements.</P>



</LI>
<LI>Example:
<HR>
<PRE>
proc toggleAdvanced { } {
  global MyProp
  set w $MyProp(w)
  if { $MyProp(ShowAdvanced) } {
    addCheck $w MyPropData AdvancedOption
  } else {
    catch {destroy $w.fAdvancedOption}
  }
}

set w [addPropGUI MyProp]
set MyProp(w) $w
addCheck $w MyPropData CommonOption
addOptionToggle $w MyProp ShowAdvanced "Advanced Options" \
  toggleAdvanced
</PRE>
<HR>
</LI>
</UL>
</P>


<P><SUB><BR></SUB></P>

<P>addScriptProperty:
<UL>
<LI>Synopsis: <CODE>"addScriptProperty propname propargs"</CODE>
<A NAME="scaddscriptproperty"></A> </LI>
<LI>Background: No,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure manages a property for a Script
object script.

<P>The <CODE>"propname"</CODE> parameter is the base name of the property.</P>
<P>The <CODE>"propargs"</CODE> parameter is a list of parameter specifications
of the property.</P>
<P>This procedure
<UL>
<LI> creates the appropriate data arrays in safe and main interpreter;</LI>
<LI> arranges for all parameters from the parameter specifications
to be saved between multiple instances of the script object and to scene files
(by adding a DA tag);</LI>
<LI> creates and populates the property GUI, based on the default value
types in the parameter specifications;</LI>
<LI> copies the parameters from property GUI to designated variables
for easy perusal by the script object code;</LI>
<LI> adds a NP tag to the script object so that the (new) property
GUI is visible to the user.</LI>
</UL>

Even though the name of this procedure suggests otherwise, it can
and should be invoked on every run of the script objects code
(unlike code that manages data arrays and GUI manually).</P>
<P>Each parameter specification is a list of three values:<BR>
<CODE>"{ Name Defaultvalue ScriptContextVariableName }"</CODE><BR>
where:
<UL>
<LI> <CODE>"Name"</CODE> is the string to be used in the property GUI as parameter
name,</LI>
<LI> <CODE>"Defaultvalue"</CODE> is the initial value to be used for this parameter,
the type of the default value determines the type of property GUI
element to be created:
<UL>
<LI> simple double and integer values lead to standard number
parameter GUI elements (addParam),</LI>
<LI><CODE>true</CODE> or <CODE>false</CODE> lead to check boxes (addCheck), but the
values in the script variable will still be <CODE>1</CODE> or <CODE>0</CODE> (and not
<CODE>true</CODE> or <CODE>false</CODE>),</LI>
<LI>menu components will be created, when the default value is a list
(addMenu),<BR>
each element of this list is a string to display in the menu,
the zero based index in the list is the integer value to be put
into the corresponding script variable, the first entry from
this list is the default,</LI>
<LI>other types of values lead to simple string entry fields (addString),</LI>
</UL>
</LI>
<LI><CODE>"ScriptContextVariableName"</CODE> is a short variable name where the value
from the property GUI element will be stored for use in the script.</LI>
</UL>
</P>


</LI>
<LI>Example:
<HR>
<PRE>
addScriptProperty MyProp {
 { FloatParam 0.1 fp }
 { BoolParam false bp }
 { MenuParam { "Mode1" "Mode2" } mp }
 { StringParam "texture.tif" tp }
}
</PRE>
<HR>

leads to the following property GUI:

<CENTER>
<IMG SRC="pics/addscriptprop.gif" HEIGHT=212 WIDTH=451  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">addScriptProperty Procedure Example</FONT></CENTER><P><CENTER>
</CENTER>


and the script code can then go on and use the parameter values
from the variables <CODE>fp</CODE>, <CODE>bp</CODE>, <CODE>mp</CODE>, and <CODE>tp</CODE> respectively.</LI>
</UL>
</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scimisc"></A> Miscellaneous</H3>

<P>Miscellaneous commands:</P>



<P>
<A NAME="scconvob"></A> 
convOb:
<UL>
<LI>Synopsis: <CODE>"convOb [-inplace [type] | -check type]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: depends (if -inplace: Yes),&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command calls the registered converter
for the selected objects which usually creates new objects of a different type.

<P>If the option <CODE>"-inplace"</CODE> is
used, the new object(s) will replace the old object(s).
If, additionally, a target type is specified, the conversion
will be repeated until the object is of the requested
type (and no conversion is attempted if the object is already
of the requested type).<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the option <CODE>"-check"</CODE> is given, the convOb command does not
convert but checks, whether a conversion to a given object type would be
successful, the result of the check will be returned as 0 &ndash; no,
or 1 &ndash; yes. Note, that only immediate, one step, conversions are
checked, not multi step conversions as carried out by in-place conversions
with target type.</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
undo:
<A NAME="scundo"></A> 
<UL>
<LI>Synopsis: <CODE>"undo [redo | save opname [0|1] | clear | rewind]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: No</LI>
<LI>Description:
<UL>
<LI>If called without arguments, this command performs the undo
operation.</LI>
<LI>If the argument is <CODE>"redo"</CODE>, this command performs the redo
operation.</LI>
<LI>If the argument is <CODE>"save"</CODE>, the currently selected objects
are saved to the undo buffer for future undo operations. The name
of the now following modelling operation <EM>has</EM> to be provided in
a second argument (<CODE>"opname"</CODE>).
This name will be displayed in the default console prompt, to inform the
user about which operation would be undone/redone, if undo/redo would be
used (e.g.&nbsp;<CODE>"[Undo:MoveObj/Redo:none].../bin&gt;"</CODE>).
Since Ayam 1.13, a third argument may be given, that controls whether
all the children of the selected objects should also be saved. This may
be needed if the modelling action that follows the undo save is about to
change the selected objects and also their children.
Note: undo save does not fail if no objects are selected.</LI>
<LI>If the argument is <CODE>"clear"</CODE>, all currently saved states
will be cleared from the undo buffer.</LI>
<LI>The argument <CODE>"rewind"</CODE> is available since Ayam 1.14. With
this command you can undo the last undo save operation. This may be
necessary, if a modelling operation failed. Care should be taken,
however, to <EM>not</EM> rewind the undo state, when a modelling
operation only failed for some (not for all) of the selected objects.</LI>
</UL>
</LI>
<LI>Example:
<HR>
<PRE>
undo save "MovOb"
set ay_error ""
movOb 0 1 0
if { $ay_error > 1 } {
  undo rewind
}
</PRE>
<HR>
</LI>
<LI>Notes: See also section 
<A HREF="ayam-8.html#undos">The Undo System</A>.</LI>
</UL>
</P>

<P><SUB><BR></SUB>
runTool:
<A NAME="scruntool"></A> 
<UL>
<LI>Synopsis: <CODE>"runTool vars labels commands title [doc]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure opens a dialog window to request
a set of parameter values, specified via <CODE>vars</CODE> and <CODE>labels</CODE>,
and if the dialog is closed via the <CODE>"Ok"</CODE>-button, runs the specified
commands.

<P><CODE>"vars"</CODE> is a list of variable names, array names are allowed. If the
specified variables already exist, their current values will be used
to infer a parameter type for presenting a type specific GUI component
to the user. The type detection uses the <CODE>string is</CODE> facility of Tcl.
If the current value is of type integer and there is a second variable
(named like the original variable with the appendix <CODE>_l</CODE>), a menu
component will be used and the menu choices will be taken from the
second variable.</P>
<P><CODE>"labels"</CODE> is a list of label strings for the parameters.</P>
<P><CODE>"commands"</CODE> is the code that calls the tool and runs additional
GUI updating. If the code contains strings like <CODE>%0</CODE>, those will
be replaced by the corresponding parameter value requested before
the code runs.</P>
<P><CODE>"title"</CODE> is the title string of the dialog window. It can be used
to convey the tool name or description to the user.</P>
<P><CODE>"doc"</CODE> is an optional argument that contains a documentation URL
for the tool. This URL will be opened when the <CODE>&lt;F1&gt;</CODE>-key is
pressed in the dialog.</P>

</LI>
<LI>Examples:

<P>
<OL>
<LI>&nbsp;

<P>
<HR>
<PRE>
runTool {x} {"X:"} {moveOb %0 0 0;plb_update;rV} "MoveX"
</PRE>
<HR>

opens a dialog to request a single parameter and moves the selected object(s)
along the X-axis by the specified amount.</P>
</LI>
<LI>&nbsp;
<P>
<HR>
<PRE>
runTool {x y} {"X:" "Y:"} {moveOb %0 %1 0;plb_update;rV} "MoveXY"
</PRE>
<HR>

opens a dialog to request two parameters and moves the selected object(s)
along the X-axis and the Y-axis by the specified amounts.</P>
</LI>
<LI>&nbsp;

<P>
<HR>
<PRE>
set l 0
set l_l {"Start" "End" "Both"}
runTool {l} {"Side:"} {
 switch %0 {
  0 {clampNC -s}
  1 {clampNC -e}
  2 {clampNC}
 }
 plb_update;rV
} "Clamp"
</PRE>
<HR>

opens a dialog with a menu GUI component and clamps the selected
NURBS curve(s) on the chosen side(s).</P>
</LI>
</OL>
</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
notifyOb:
<A NAME="scnotifyob"></A> 
<UL>
<LI>Synopsis: <CODE>"notifyOb [-all | -modified | -parent]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: Yes<SUP>&lowast;</SUP></LI>
<LI>Description: This command executes the notification
of the selected object(s) and their parents, or, if no object
is selected, for all objects of the scene.
This includes running BNS or ANS tag scripts (if present) and
executing the notification of referenced objects.
<P>If the <CODE>"-modified"</CODE> parameter is used, only modified objects
will be notified.</P>
<P>If the <CODE>"-all"</CODE> parameter is used, all objects
will be notified regardless of the selection.</P>
<P>If the <CODE>"-parent"</CODE> parameter is used, only the current
parent object of the current level will be notified.</P>
<P>Prior to Ayam 1.20 this command was named <CODE>"forceNot"</CODE>,
the old name is still available for compatibility but its
use is deprecated.</P>
<P><SUP>&lowast;</SUP>: Since 1.21 this command is also available
in the safe interpreter with limited functionality: only the notification
callbacks of the selected objects will be executed. No BNS or ANS tags
will be considered, notification of parents will not be done, and the
complete notification will also be omitted. Hence, in the safe interpreter,
this command ignores all parameters.</P>
<P>See also section 
<A HREF="ayam-8.html#toolobj">The Modelling Concept Tool-Objects</A>.</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
nameOb:
<A NAME="scnameob"></A> 
<UL>
<LI>Synopsis: <CODE>"nameOb name"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: Yes,&nbsp;&nbsp;Safe: Yes</LI>
<LI>Description: This command sets the name of the
selected object(s).<BR>
See also
section 
<A HREF="#scgetname">getName scripting interface command</A>.</LI>
</UL>
</P>

<P><SUB><BR></SUB>
setMark:
<A NAME="scsetmark"></A> 
<UL>
<LI>Synopsis: <CODE>"setMark [x y z | l]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure sets the global mark to the specified
coordinates.<BR>
If there is only one argument, it is expected to be a list
of three floating point values.

<P>If no arguments are provided, the global mark is cleared.</P>
<P>This procedure only works, if there is at least one view.</P>
<P>See also section 
<A HREF="ayam-3.html#markac">Setting the Mark</A>.</P>
</LI>
<LI>Example:
<B><CODE>"setMark 0 0 0"</CODE></B></LI>
</UL>
</P>

<P><SUB><BR></SUB>
getMark:
<A NAME="scgetmark"></A> 
<UL>
<LI>Synopsis: <CODE>"getMark"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure returns the current global mark
as a list of three floating point values.

<P>This procedure only returns meaningful data, if there is at least one view.</P>
<P>See also section 
<A HREF="ayam-3.html#markac">Setting the Mark</A>.</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
clearMark:
<A NAME="scclearmark"></A> 
<UL>
<LI>Synopsis: <CODE>"clearMark"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure clears the global mark.<BR>
<P>This procedure only works, if there is at least one view.</P>
<P>See also section 
<A HREF="ayam-3.html#markac">Setting the Mark</A>.</P>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
tmpGet:
<A NAME="sctmpget"></A> 
<UL>
<LI>Synopsis: <CODE>"tmpGet tmpdir varname [ext]"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No</LI>
<LI>Description: This command calculates a name for a temporary
file in tmpdir and puts the complete name (with the optionally present
extension appended) into the variable designated by <CODE>varname</CODE>.</LI>
</UL>
</P>

<P><SUB><BR></SUB>
whatis:
<A NAME="scwhatis"></A> 
<UL>
<LI>Synopsis: <CODE>"whatis this"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: N/A,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: Print information about the named object
<CODE>"this"</CODE> in the Tcl scripting context to the console.
This procedure can be used to inquire about the existence of variables,
widgets, or whether or not something is a command or a procedure.</LI>
<LI>Example:
<B><CODE>"whatis ."</CODE></B>
leads to the output:
<BLOCKQUOTE><CODE>
<PRE>
. is a command.
. is a widget.
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>

<P><SUB><BR></SUB>
addToProc:
<A NAME="scaddtoproc"></A> 
<UL>
<LI>Synopsis: <CODE>"addToProc procedure addition"</CODE></LI>
<LI>Background: Yes,&nbsp;&nbsp;Undo: No,&nbsp;&nbsp;Safe: No,&nbsp;&nbsp;Type: Procedure</LI>
<LI>Description: This procedure adds the code from <CODE>addition</CODE> to
the Tcl procedure <CODE>procedure</CODE>.</LI>
<LI>Note: This procedure uses the introspection facilities of
Tcl and works only correctly for procedures, that end with
a single <CODE>"return;"</CODE> statement.</LI>
</UL>
</P>




<H2><A NAME="scexpdiag"></A> <A NAME="ss6.3">6.3</A> <A HREF="ayam.html#toc6.3">Expression Support in Dialog Entries</A>
</H2>

<P>Various entries of dialogs for object creation and modelling tools
support Tcl variables and expressions.</P>
<P>It is e.g.&nbsp;possible to enter
<HR>
<PRE>
$::u
</PRE>
<HR>

instead of a numeric knot value in the insert knot tool parameter dialog
to infer the parametric value from the global variable <CODE>u</CODE> (that
may have been set before using the find u modelling action) and
insert a knot at the picked point.</P>
<P>It is also possible to enter complex mathematical expressions:
<HR>
<PRE>
[expr sin(45)]
</PRE>
<HR>
</P>
<P>or call into own procedures (that have to return appropriately
typed values):
<HR>
<PRE>
[myproc]
</PRE>
<HR>

where <CODE>"myproc"</CODE> is defined elsewhere (e.g.&nbsp;in a Tcl script file
loaded via the <CODE>"Scripts"</CODE> preference setting) as follows:
<HR>
<PRE>
proc myproc { } {
  return [expr sin(45)];
}
</PRE>
<HR>

.</P>
<P>Repeated calling of the tool without opening the dialog (using
the keyboard shortcut <CODE>&lt;Ctrl+T&gt;</CODE>), will execute the
provided expression again.
This means, a number of curves with increasing length can be created
by entering into the Ayam console
<HR>
<PRE>
set ::myvar 1
</PRE>
<HR>

then entering for the length in the create NURBS curve dialog:
<HR>
<PRE>
[incr ::myvar]
</PRE>
<HR>

then pressing <CODE>&lt;Ctrl+T&gt;</CODE> multiple times.</P>



<H2><A NAME="ss6.4">6.4</A> <A HREF="ayam.html#toc6.4">Scripting Interface Examples</A>
</H2>

<P>Here are some complete example scripts for the Ayam Tcl scripting interface.</P>
<P>All examples may be copied from the documentation and pasted directly
into the console of Ayam.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scexmov"></A> Moving Objects</H3>

<P>The following example script shows how to move a selected object
to a specified position in space.
<HR>
<PRE>
proc placeOb { x y z } {
  global transfPropData

  # copy Transformations-property data to
  # global array "transfPropData"
  getTrafo

  # set array values according to procedure parameters
  set transfPropData(Translate_X) $x
  set transfPropData(Translate_Y) $y
  set transfPropData(Translate_Z) $z

  # copy Transformations-property data from
  # global array "transfPropData" to selected object
  setTrafo
}
# placeOb
</PRE>
<HR>

In order to move all selected objects to 1 1 1 you may enter the
following into the console:
<HR>
<PRE>
forAll -recursive 0 {placeOb 1 1 1}
</PRE>
<HR>

But perhaps you would rather like a small GUI for that?
No problem, the following snippet adds an entry to the custom
menu that opens a small requester for the x-, y-, and z-values and
calls the <CODE>"placeOb"</CODE> procedure (defined above) with them:
<HR>
<PRE>
global ay
$ay(cm) add command -label "Place Object(s)" -command {
 runTool {x y z} {"X:" "Y:" "Z:"} {forAll -recursive 0 {placeOb %0 %1 %2};
   plb_update; rV
 } "Place Object(s)"
}
</PRE>
<HR>

The trailing <CODE>"plb_update; rV"</CODE> command ensures that the GUI is updated
properly and all views display the new position of the moved objects.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scexnurb"></A> Moving NURBS points</H3>

<P>The following example script snippet shows how to move control points
of a NURBS curve.</P>
<P>
<HR>
<PRE>
# first, we create a new NURBS curve with 30 control points
set len 30
crtOb NCurve -length $len
# update selection
uS
# select last object (the newly created curve)
sL
# prepare moving
set i 0
set r 3.0
set angle 0
set angled [expr 3.14159265/2.0]
while { $i &lt; $len } {

    set x [expr $r*cos($angle)]
    set y [expr $r*sin($angle)]
    set z [expr $i/3.0]

    # move control point to new position
    setPnt $i $x $y $z 1.0

    set angle [expr $angle + $angled]
    incr i
}
# redraw all views
rV
</PRE>
<HR>

Now use this as path for a Sweep.
For instance, using the next small script.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scexsweep"></A> Easy Sweep</H3>

<P>The following example script shows how to easily create a sweep from a
selected path curve (avoiding the manual and lengthy creation and
parameterisation of a suitable cross section).
<HR>
<PRE>
proc easySweep { } {
 # first, we create a sweep object
 crtOb Sweep

 # now, we need to move the selected curve (path) to
 # the sweep and create a cross-section curve there too
 # for that, we move the currently selected curve to the clipboard
 cutOb

 # enter the Sweep (the last object in the current level)
 goDown -1

 # now, we create a new curve (a closed B-Spline suitable as cross section)
 crtClosedBS -s 8

 # select the new object
 selOb 0

 # now, we rotate and scale the curve
 rotOb 0 90 0
 scalOb 0.25 0.25 1.0

 # move trajectory back (we use "-move", because we
 # really want to move (and not copy) the curve object
 pasOb -move

 # go up to where we came from
 goUp

 # finally, update the GUI...
 uS
 sL

 # ...and redraw all views
 rV
}
# easySweep
</PRE>
<HR>
</P>


<P>Run this procedure by selecting a NURBS curve object, then type
into the console:
<BLOCKQUOTE><CODE>
&raquo;&thinsp;easySweep
</CODE></BLOCKQUOTE>
</P>
<P>This command may be added to the main menu as well:
<HR>
<PRE>
global ay
$ay(cm) add command -label "Easy Sweep" -command {
 easySweep
}
</PRE>
<HR>

After running the above script there should now be a new menu
entry <CODE>"Custom/Easy Sweep"</CODE> that calls the <CODE>easySweep</CODE>
procedure.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scextoolbox"></A> Toolbox Buttons</H3>

<P>Here is another example script that shows how buttons may be added
to the toolbox.
myImage should be an image created e.g.&nbsp;from a GIF file of
the size 25 by 25 pixels.
<HR>
<PRE>
global ay ayprefs

# create an image from a GIF file:
image create photo myImage -format gif -file /home/user/giffile

set b $ay(tbw).mybutton

# if the button does not already exist:
if { ![winfo exists $b] } {

  # create it:
  button $b -padx 0 -pady 0 -image myImage -command myCommand

  # tell Ayam about the new button:
  # you can use "linsert", to insert the button in a specific
  # place or just append to the end of the list using "lappend"
  lappend ay(toolbuttons) mybutton

  # display the button:
  toolbox_layout

  # from now on, the button will be under the
  # automatic toolbox layout management
}
</PRE>
<HR>
</P>
<P>This example shows that
<OL>
<LI>toolbox buttons have to be created in a frame whose path and
window name are stored in the global variable <CODE>"ay(tbw)"</CODE>
(this is <CODE>".tbw.f"</CODE> for multi-window GUI configurations or
<CODE>".fv.fTools.f"</CODE> for single-window GUI configurations),</LI>
<LI>Ayam manages a list of all toolbox buttons in the global variable
<CODE>"ay(toolbuttons)"</CODE>, the order in that list is the order
in which the buttons appear in the toolbox,</LI>
<LI>automatic layout management is carried out by the
procedure <CODE>"toolbox_layout"</CODE>.</LI>
</OL>
</P>
<P>Adding buttons with just text is a little bit more involved,
as the sizes of those buttons often do not fit well in the
icon button scheme with its constant button size. However,
the procedure <CODE>"toolbox_add"</CODE> can be of
considerable help.<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See also the script <CODE>"scripts/topoly.tcl"</CODE>
for an example.</P>

<P>The following example script adds two buttons to the bottom of the
toolbox spanning the whole window (this works best with the
standard toolbox layout of 4 by 12 buttons used in the multi-window
GUI configuration):
<HR>
<PRE>
global ay

# create a frame:
set f [frame $ay(tbw).fcollex]

# calculate the row number below the last row:
set row [expr [lindex [grid size $ay(tbw)] 1] + 1]

# now display the frame at calculated row, spanning the whole window:
grid $f -row $row -column 0 -columnspan [lindex [grid size $ay(tbw)] 0]\
     -sticky we
# create two buttons inside the frame:
button $f.b1 -width 5 -text "Coll." -command { collMP; rV; }
button $f.b2 -width 5 -text "Expl." -command { explMP; rV; }
pack $f.b1 $f.b2 -side left -fill x -expand yes
</PRE>
<HR>
</P>



<H2><A NAME="scripts"></A> <A NAME="ss6.5">6.5</A> <A HREF="ayam.html#toc6.5">Distributed Helper Scripts</A>
</H2>

<P>This sections contains the documentation of some helper scripts
that are distributed with Ayam.</P>
<P>The helper scripts may be run via the context menu of the console, the
Tcl <CODE>"source"</CODE> command in the console, or the <CODE>"Scripts"</CODE>
preference setting of Ayam on each start (the latter except for
the so called <EM>external</EM> scripts
<CODE>"repairAyam.tcl"</CODE>, <CODE>"bgconvert.tcl"</CODE>, and <CODE>"aytest.tcl"</CODE>).</P>
<P>All other, <EM>internal</EM> scripts may be combined arbitrarily except for
<CODE>"kdialog.tcl"</CODE>, <CODE>"zdialog.tcl"</CODE>, and <CODE>"intfd.tcl"</CODE>,
which are mutually exclusive.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="repayam"></A> Repair Ayam</H3>

<P>The <EM>external</EM> Tcl script <CODE>"repairAyam.tcl"</CODE>
may be used to repair the application state of Ayam,
should it be stuck e.g.&nbsp;in an endless loop of Tcl error
messages.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>On Unix systems <CODE>"repairAyam"</CODE> may be started from any
shell simply by typing
<BLOCKQUOTE><CODE>
&raquo;&thinsp;./repairAyam.tcl
</CODE></BLOCKQUOTE>

or
<BLOCKQUOTE><CODE>
&raquo;&thinsp;wish repairAyam.tcl
</CODE></BLOCKQUOTE>

on the command prompt; if the script detects that it is running on Unix
and not in Ayam it will send itself to the Tcl interpreter Ayam is
running in using the Tk send command. On Mac OS X Aqua (not X11!)
AppleScript events will be used instead of the Tk send command.
If this does not work as expected <CODE>"repairAyam.tcl"</CODE> may still
be run via the Ayam console (as on Win32).</P>
<P>On Win32 <CODE>"repairAyam.tcl"</CODE> has to be started from the Ayam console
using the command:
<BLOCKQUOTE><CODE>
&raquo;&thinsp;source scripts/repairAyam.tcl
</CODE></BLOCKQUOTE>

or via the consoles context menu: <CODE>"Console/Load File"</CODE>.</P>
<P>The script <CODE>"repairAyam.tcl"</CODE> should be considered a
<EM>last resort</EM> to help saving the current state of
modified objects.</P>
<P>The script will close all views, clean up the application state variables,
reset the mouse cursor and the console prompt, and try to update important
main window widgets.</P>
<P>Furthermore, the script will also clear the console and
try to break potential endless loops running e.g.&nbsp;in the console or
in Script objects.<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>After running <CODE>"repairAyam.tcl"</CODE> the scene (or the most
important objects currently worked on) should be immediately
saved to a new scene file, <EM>not</EM> the file currently loaded,
using <CODE>"File/Save As"</CODE> or
<CODE>"Special/Save Selected"</CODE>) and Ayam should be restarted
afterwards.</P>
<P>Simply saving the scene using <CODE>"File/Save"</CODE> or <CODE>&lt;Ctrl+s&gt;</CODE>
should be avoided because views were possibly deleted.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="aytesttcl"></A> Test Ayam</H3>

<P>The <EM>external</EM> script <CODE>"aytest.tcl"</CODE> allows to test the
Ayam implementation by creating objects with various combinations
of parameters and executing standard operations and modelling actions
on them.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bgconverttcl"></A> Use Ayam as Command Line Converter</H3>

<P>The <EM>external</EM> Tcl script <CODE>"bgconvert.tcl"</CODE>
converts scene files from one 3D file format to another,
with the help of Ayam which is running in the
background.<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>In the most simple form, bgconvert may be used from a Unix command line
(or shell script) like this:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;bgconvert.tcl infile.x3d outfile.dxf</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>The above command would load the X3D file <CODE>"infile.x3d"</CODE>
into Ayam and export the scene as DXF file to <CODE>"outfile.dxf"</CODE>.</P>
<P>For a successful conversion Ayam has to run and the plugins required
for the import and export processes need to be available and properly
configured (check the <CODE>"Plugins"</CODE> preference setting).
The plugins necessary for the conversion will be loaded automatically.</P>
<P>Import and export options may also be given like this:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;bgconvert.tcl "infile.rib -p 1" outfile.dxf</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>In the example above the <CODE>"-p 1"</CODE> option switches on reading
of partial RIB files.</P>
<P>Available options and their syntax may be inquired from the
import and export plugin Tcl scripts (e.g.&nbsp;<CODE>"plugins/rrib.tcl"</CODE>).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="slxmltcl"></A> Shader Parsing</H3>

<P>The Tcl script <CODE>"slxml.tcl"</CODE> switches the shader parsing
machinery of Ayam to recognize XML based meta information embedded in
shading language comments.<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
This way, the shader database for the Material
objects can be built up from shading language source files, instead of
compiled shaders.<BR>
The XML tags will not be parsed by a real XML parser, so that well
formedness is not an issue. However, the attributes must be ordered
in a certain way. To specify a shader, use:
<BLOCKQUOTE><CODE>
<PRE>
&lt;shader type="stype" name="sname">
</PRE>
</CODE></BLOCKQUOTE>

where <CODE>stype</CODE> is one of <CODE>surface</CODE>, <CODE>displacement</CODE>, <CODE>volume</CODE>, <CODE>light</CODE>, <CODE>imager</CODE>, or <CODE>transformation</CODE> and <CODE>sname</CODE> is the shader name
that must also match the file name of the shader source file sans extensions.</P>
<P>To specify a shader parameter, use a line like:
<BLOCKQUOTE><CODE>
<PRE>
&lt;argument name="argname" type="argtype" value="argval">
</PRE>
</CODE></BLOCKQUOTE>

where <CODE>argname</CODE> is the name of the parameter, <CODE>argtype</CODE> is one of
<CODE>float</CODE>, <CODE>string</CODE>, <CODE>matrix</CODE>, <CODE>color</CODE>, <CODE>point</CODE>, <CODE>normal</CODE>,
or <CODE>vector</CODE> and <CODE>argval</CODE> is the default value.</P>
<P>See also the following example shader source:
<HR>
<PRE>
/* myshader.sl:
 *  Author: Randolf Schultz
 * &lt;shader type="surface" name="myshader">
 * &lt;argument name="Ka" type="float" value="0.5">
 * &lt;argument name="Kd" type="float" value="0.9">
 * &lt;argument name="ic" type="color" value="0 1 0">
 */
surface myshader(float Ka = 0.5, Kd = 0.9; color ic = color (0, 1, 0);)
{
  color mycolor;

  ...

  Ci = Cs*mycolor*(Ka*ambient()+Kd*diffuse(faceforward(normalize(N),I)));
}
</PRE>
<HR>
</P>
<P>The following restrictions/caveats (in contrast to the normal shader parsing)
apply:
<UL>
<LI>there can only be one shader per shader source file,</LI>
<LI>shader file name and shader name must match,</LI>
<LI>shaders for which there is no source code available are not supported
(unless the parameter information is known, in which case a shader source
file with matching comment can be faked),</LI>
<LI>there is no control over whether the meta data matches the actual
shader signature,</LI>
<LI>there is no control over whether the compiled shader, that is used
for rendering, matches the shader source code.</LI>
</UL>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="topolytcl"></A> Convert Everything to Polygons</H3>

<P>The script <CODE>"topoly.tcl"</CODE>
recursively browses through the scene and converts everything
to a polygonal representation.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>After running the script, there is a new button in the toolbox
named <CODE>"ToPolyMesh"</CODE>. Additionally, there is a corresponding
entry in the <CODE>"Custom"</CODE> main menu.
Pressing the button or using the menu entry immediately starts the
conversion process.</P>
<P>Since the changes of the conversion can not be undone, the conversion
will not run if the scene contains unsaved changes.</P>
<P>The conversion will use the current parameters from the preference settings
<CODE>"SMethod"</CODE>, <CODE>"SParamU"</CODE>, and <CODE>"SParamV"</CODE>; <CODE>"TP"</CODE>
tags (if present) will override these parameters.
TP tags may be created easily using the tesselation tool, see also
section 
<A HREF="ayam-5.html#tesst">Tesselation Tool</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tonpatchtcl"></A> Convert Everything to NURBS patches</H3>

<P>The script <CODE>"tonpatch.tcl"</CODE>
recursively browses through the scene and converts everything
to a NURBS patch representation effectively flattening the tool object
hierarchy.<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>After running the script, there is a new button in the toolbox
named <CODE>"ToNPatch"</CODE>. Additionally, there is a corresponding
entry in the <CODE>"Custom"</CODE> main menu.
Pressing the button or using the menu entry immediately starts the
conversion process.</P>
<P>Since the changes of the conversion can not be undone, the conversion
will not run if the scene contains unsaved changes.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="twolconstcl"></A> Restrict the Console</H3>

<P>The script <CODE>"2lcons.tcl"</CODE> (for two line console) may be
used to restrict the screen space occupied by the console.</P>
<P>Normally, the Ayam console is resized with the main window and
occupies a varying amount of screen space.
After running the script, the console will always resize to exactly
two lines of text. Different values may be chosen easily by adapting the
script.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="colfocustcl"></A> Color the Focus Ring</H3>

<P>The script <CODE>"colfocus.tcl"</CODE> (for <B>col</B>ored <B>focus</B>) may be
used to paint the focus ring in a more visible color.</P>
<P>After running the script, the focus ring will be painted in blue
(instead of black): focused sub-windows (views, console, object
tree) will be more easily recognizable. Other colors may be used
by editing the script.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="linktcl"></A> Decouple Hierarchy View Link</H3>

<P>
<CENTER>
<IMG SRC="pics/link.gif" HEIGHT=79 WIDTH=240  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Link Button</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"link.tcl"</CODE> places a small button into the
object hierarchy title area that controls the, otherwise permanent,
link between the hierarchy and the views.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If this button is disabled, selection actions and changes to the
hierarchy or to the objects themselves (via the property GUI)
do not result in redraw operations.</P>
<P>Toggling the state to <CODE>"on"</CODE> will result in a single redraw.</P>
<P>This script may be used with all other scripts that place buttons
in the designated area. The buttons will be placed from the right
to the left in the order of the script execution.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="shufudtcl"></A> Shuffle Objects Up/Down</H3>

<P>
<CENTER>
<IMG SRC="pics/shufud.gif" HEIGHT=80 WIDTH=240  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Shuffle Objects Up/Down Buttons</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The scripts <CODE>"shufup.tcl"</CODE> and <CODE>"shufdown.tcl"</CODE> place
small buttons into the object hierarchy title area that shuffle the
selected objects up or down in the current
level.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
See also the image above.</P>
<P>See also the discussion about multiple hierarchy button scripts
in section 
<A HREF="#linktcl">Decouple Hierarchy View Link</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="openclosettcl"></A> Open/Close All Tree Levels</H3>

<P>
<CENTER>
<IMG SRC="pics/opencloset.gif" HEIGHT=80 WIDTH=240  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Open/Close All Tree Levels Buttons</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The scripts <CODE>"opent.tcl"</CODE> and <CODE>"closet.tcl"</CODE> place
small buttons into the object hierarchy title area that allow to open
and close all tree levels.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
See also the image above.</P>
<P>See also the discussion about multiple hierarchy button scripts
in section 
<A HREF="#linktcl">Decouple Hierarchy View Link</A>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="aactcl"></A> Automatic About Center Actions</H3>

<P>The script <CODE>"aac.tcl"</CODE> (for <B>a</B>utomatic <B>a</B>bout <B>c</B>enter)
may be used to switch all modelling actions to their about variants with
the mark set to the center of the current selection automatically.</P>
<P>After running the script, invoking e.g.&nbsp;the scale 2D action using
the shortcut <CODE>&lt;s&gt;</CODE> will:
<UL>
<LI>if the modelling mode is object,
<OL>
<LI>set the mark to the center of all selected objects</LI>
<LI>invoke the about variant of scale 2D</LI>
</OL>

(this is the equivalent of <CODE>&lt;sac&gt;</CODE>)</LI>
<LI>if the modelling mode is point,
<OL>
<LI>set the mark to the center of all selected points</LI>
<LI>invoke the about variant of scale 2D</LI>
</OL>

(this is the equivalent of <CODE>&lt;saC&gt;</CODE>)</LI>
</UL>
</P>
<P>The script modifies all rotate and scale actions (including their axis
confined variants).</P>
<P>Note, that the mark is not reset to a new center, when the selection
changes. After a selection change (e.g.&nbsp;by selecting points in a
different view) simply restart the action to transform about the
new center.</P>
<P>To rotate or scale about a different point than the center, the mark
may still be set manually using <CODE>&lt;a&gt;</CODE>.</P>
<P>To temporarily disable the modified behavior, the global keyboard
shortcut <CODE>&lt;F11&gt;</CODE> can be used.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="apnttcl"></A> Automatic Point Actions</H3>

<P>Note that since the introduction of the <CODE>"ScopeManagement"</CODE> preference
setting (see 
<A HREF="ayam-2.html#prefmodel">Modelling Preferences</A>) in Ayam 1.30
this script is obsolete and kept only for backwards compatibility.
Furthermore, to ensure complete compatibility this script will set the
scope management mode to <CODE>"Explicit"</CODE> when loaded.</P>
<P>The script <CODE>"apnt.tcl"</CODE> (for <B>a</B>utomatic <B>p</B>oi<B>nt</B>) may be
used to switch the modelling mode to point modelling automatically
after a point selection.</P>
<P>After running the script, selecting (tagging) a point using the
select point action (shortcut <CODE>&lt;t&gt;</CODE>) will automatically
switch the view to point modelling so that the next modelling
actions (e.g.&nbsp;move, via shortcut <CODE>&lt;m&gt;</CODE>) will always
transform the points and not modify the objects transformations.
Note that currently the switch to point modelling will also occur,
if no points are actually selected, it is just the mouse click that
counts.</P>
<P>Selecting all points via the keyboard shortcut <CODE>&lt;A&gt;</CODE>
will additionally switch to point modelling and de-selecting all points via
<CODE>&lt;N&gt;</CODE> will additionally switch to object
modelling.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>It is also still possible to switch back to object modelling anytime
via the keyboard shortcut <CODE>&lt;o&gt;</CODE>.</P>
<P>To temporarily disable the modified behavior, the global keyboard
shortcut <CODE>&lt;F12&gt;</CODE> can be used.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ssptcl"></A> Save Selected Points</H3>

<P>The script <CODE>"ssp.tcl"</CODE> (for <B>s</B>ave <B>s</B>elected <B>p</B>oints)
allows to save the point selection to tags of type
<CODE>SP</CODE>.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>After running the script, two new buttons appear in the toolbox
that allow to save and restore the point selection respectively.
See also the table below.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Operation</B></TD><TD><B>Icon</B></TD></TR><TR><TD>
Save</TD><TD>
<IMG SRC="pics/ssp.gif" HEIGHT=25 WIDTH=25  loading="lazy">
</TD></TR><TR><TD>
Restore</TD><TD>
<IMG SRC="pics/rsp.gif" HEIGHT=25 WIDTH=25  loading="lazy">
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Save/Restore Selected Points</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<P>There are also two corresponding entries in the custom menu.</P>
<P>Note that the tags can be saved to scene files and also copied
to different objects.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="rctcl"></A> Revert Cursor Key Behavior</H3>

<P>The script <CODE>"rc.tcl"</CODE> (for <B>r</B>evert <B>c</B>ursor) may be
used to get more useful cursor key behavior in primary modelling
views (parallel views).</P>
<P>After running the script, the keyboard shortcuts for rotating
and panning in parallel views are swapped, e.g.&nbsp;just pressing
<CODE>&lt;Left&gt;</CODE> key will then pan the view, instead of rotating it.</P>
<P>The shortcuts will be swapped again, when the view changes
type to <CODE>"Perspective"</CODE>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="zaptcl"></A> Access Core Functions from the Toolbox</H3>

<P>The script <CODE>"zap.tcl"</CODE> demonstrates, how arbitrary core
functionality that is just available through a main menu entry
or the scripting interface might be accessed easily via the
toolbox window.</P>
<P>After running the script <CODE>"zap.tcl"</CODE>, there will be a new
toolbox button, labeled <CODE>"Zap!"</CODE>, that simply runs the zap
command (which iconifies the complete application).</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="kdialogtcl"></A> Switch Dialogs to Kdialog</H3>

<P>The script <CODE>"kdialog.tcl"</CODE> switches all file dialogs of
Ayam to use the kdialog application of the KDE project instead
of the native Tk file dialog.<BR>
The script also adds a custom main menu entry to revert any
changes.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="zdialogtcl"></A> Switch Dialogs to Zenity</H3>

<P>The script <CODE>"zdialog.tcl"</CODE> switches all file dialogs of
Ayam to use the zenity application of the Gnome project instead
of the native Tk file dialog.<BR>
The script also adds a custom main menu entry to revert any
changes.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="intfdtcl"></A> Switch File Dialogs to Tcl</H3>

<P>The script <CODE>"intfd.tcl"</CODE> switches all file dialogs of
Ayam to use the Tcl/Tk internal version instead
of the native file dialogs provided by the operating system.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="useaqsisapptcl"></A> Use Aqsis from Application Directory</H3>

<P>The script <CODE>"useaqsisapp.tcl"</CODE> sets up Ayam to use Aqsis
from the application directory structure (<CODE>"/Applications/Aqsis.app"</CODE>)
on Mac OS X. This is the default installation location of Aqsis on Mac OS X.</P>
<P>The script adapts the executable and shader search paths.
Furthermore, environment variables vital for Aqsis to work will
be set up properly.</P>
<P>Note that the script does not change the <CODE>"RIB-Export/Renderer"</CODE>
preferences, you still have to switch to Aqsis using the main menu
<CODE>"Special/Select Renderer"</CODE> once.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="usepixietcl"></A> Use Pixie from Library Directory</H3>

<P>The script <CODE>"usepixie.tcl"</CODE> sets up Ayam to use Pixie
from the <CODE>"/Library/pixie"</CODE> directory on Mac OS X.
This is the default installation location of Pixie on Mac OS X.</P>
<P>The script adapts the executable, shared library, and shader search paths.
Furthermore, environment variables vital for Pixie to work will
be set up properly.</P>
<P>Note that the script does not change the <CODE>"RIB-Export/Renderer"</CODE>
preferences, you still have to switch to Pixie using the main menu
<CODE>"Special/Select Renderer"</CODE> once.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="myiconstcl"></A> Replace Icons</H3>

<P>The script <CODE>"myicons.tcl"</CODE> allows to replace icons of the Ayam
user interface, e.g.&nbsp;toolbox icons, with user defined ones.
The new icons must be GIF image files of size 25 by 25 and reside
in the <CODE>"icons"</CODE> directory relative to the Ayam executable.</P>
<P>The names of the image files may be obtained from the script or
by the following scripting interface command (in the Ayam console):
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;image names</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>Action icon variants (e.g.&nbsp;for the scale about actions) can also be created
automatically by changing the <CODE>"createVariants"</CODE> variable in
the script file.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="dtreetcl"></A> Dynamic Tree</H3>

<P>The script <CODE>"dtree.tcl"</CODE> (dynamic/fast tree) replaces some of
BWidgets tree code for faster interaction in scenes with many objects.</P>
<P>The original BWidget tree widget (and accompanying script code in Ayam)
creates a canvas item for every object in the scene, even if it is not
visible in the tree widget. Therefore, tree update operations that
occur e.g.&nbsp;after loading of a scene or after drag-and-drop operations,
can become very slow, when a scene has many objects.</P>
<P>If the dtree script is active, there are only as many canvas items as
there are nodes visible in the current scroll region. Therefore, working
with many objects in long lists becomes much faster for operations that
require tree updates. However, operations like opening or closing
sub trees or even just scrolling in the tree will become a bit slower,
as canvas items need to be created constantly.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cvviewtcl"></A> Control Vertex View</H3>

<P>
<CENTER>
<IMG SRC="pics/cvview.gif" HEIGHT=238 WIDTH=464  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Control Vertex View Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"cvview.tcl"</CODE> (control vertex view) allows to
view the control points of NURBS surface or curve objects as property,
see also the image above.</P>
<P>The script currently supports the following object types:
APatch, IPatch, NPatch, PatchMesh, ACurve, ICurve, NCurve, BCurve, and SDCurve.
In addition also objects that provide NPatch/NCurve objects
and show a NPInfo/NCInfo entry in their parameter property
are supported.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the script is loaded, there is a new entry in the <CODE>"Custom"</CODE> menu
(<CODE>"Add CVView to Object"</CODE>) that allows to add a new
property (<CODE>"CVView"</CODE>) to an individual
surface or curve object.</P>
<P>The <CODE>"CVView"</CODE> property GUI displays all control vertices in a
regular grid. The coordinates of each vertex will be shown when
the mouse pointer hovers over it. This also works if the control points
lump together in 3D space or have unusual values.</P>
<P>Additionally, the current point selection is visualized by painting
the selected vertices in red and the selection may also be adjusted
by clicking on the circles.
Drag selection is also possible.<SMALL TITLE="Since 1.28."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="curvaturetcl"></A> Curvature Plot</H3>

<P>
<CENTER>
<IMG SRC="pics/curvature.gif" HEIGHT=318 WIDTH=510  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Curvature Plot Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"curvature.tcl"</CODE> allows to
view the curvature of NURBS curves and NURBS curve providing objects
as property, see also the image above.</P>
<P>If the script is loaded, there is a new entry in the <CODE>"Custom"</CODE> menu
(<CODE>"Add Curvature View to Object"</CODE>) that allows to add a new property
(<CODE>"Curvature"</CODE>) to an individual curve object.</P>
<P>The <CODE>"Curvature"</CODE> property GUI displays the curvature of the curve as
live and interactive diagram.
The diagram will be updated if the curve changes.
The diagram can be zoomed by dragging with the leftmost mouse button
and panned by dragging with the rightmost mouse button (in zoomed state).
Zooming is also possible with the mouse wheel.</P>
<P>The zoomed state is conveyed by prepending/appending "..." to/on the
respective label of the horizontal scale.</P>
<P>Note that when panning, the new section of the curve will be re-scaled
to completely fill the Y-axis.</P>
<P>For NURBS curve objects the real knot value range will be shown on the x axis
whereas for NURBS curve providing objects a relative knot value
range ([0,&thinsp;1]) will be displayed.</P>
<P>A click on the <CODE>"k"</CODE> label toggles between absolute and logarithmic
scaling of the Y-axis.</P>
<P>There is a resize handle that allows to adapt the size of the diagram to
the property canvas.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="x3domnurbsjs"></A> NURBS for X3DOM</H3>

<P>
<CENTER>
<IMG SRC="pics/x3dom-nurbs-ex.gif" HEIGHT=289 WIDTH=284  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">X3dom NURBS Display</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The <CODE>"x3dom-nurbs"</CODE> script implements the
<CODE>&lt;NurbsPatchSurface&gt;</CODE> and <CODE>&lt;NurbsTrimmedSurface&gt;</CODE>
X3D NURBS nodes for x3dom (see <CODE>http://www.x3dom.org/</CODE>) in
JavaScript.<BR>
After loading of the scene into the web browser, the NURBS surfaces
from these nodes are tessellated into <CODE>&lt;IndexedTriangleSet&gt;</CODE>
nodes.
This allows to directly publish NURBS
models on the web without prior conversion to a polygonal representation
which is cumbersome, inflexible, and leads to higher bandwidth consumption.</P>
<P>The tessellator is based on idea and example code from
A. J. Chung and A. J. Field: <EM>"A Simple Recursive Tessellator for Adaptive Surface Triangulation"</EM> in Journal of Graphics Tools Vol. 5, Iss. 3, 2000.</P>
<P>The implementation spans four script files:
<UL>
<LI><CODE>x3dom-nurbs-nodes.js</CODE> &ndash; interface of the tessellator to x3dom</LI>
<LI><CODE>x3dom-nurbs-pool.js</CODE> &ndash; worker management (current pool size is 3)</LI>
<LI><CODE>x3dom-nurbs-worker.js</CODE> &ndash; a worker</LI>
<LI><CODE>x3dom-nurbs-tess.js</CODE> &ndash; the tessellator</LI>
</UL>
</P>
<P>In order to use the tessellator just add the following to your XHTML file
after inclusion of <CODE>"x3dom.js"</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
 &lt;script type="text/javascript" src="x3dom-nurbs-pool.js"/>
 &lt;script type="text/javascript" src="x3dom-nurbs-nodes.js"/>
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>As the tessellator is fully automatic, no further adjustments are needed.</P>
<P>Proper XHTML files can be created using the X3D export in x3dom-mode, see
section 
<A HREF="ayam-7.html#expx3dopt">X3D (Web3D) export options</A>.</P>
<P>While the tessellator runs in the background an initial polygonal
representation that is directly derived from the control polygon of
the NURBS surface is shown. Additionally, a busy prompt is displayed,
see also the image below.
As the busy prompt is derived from the x3dom loading prompt, it may also
be styled with the <CODE>"x3dom-progress"</CODE> style in <CODE>"x3dom.css"</CODE>.
<CENTER>
<IMG SRC="pics/x3dom-nurbs-busy.gif" HEIGHT=289 WIDTH=284  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">X3dom NURBS Busy Prompt</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The tessellation runs in so called webworkers, processes that run in
parallel to the main browser thread, in order to not block user interaction
and employ multi-core CPUs.
The webworker pool is currently hard coded to only use three such
webworkers at any given time. This value may be adapted easily in
<CODE>"x3dom-nurbs-pool.js"</CODE> (e.g.&nbsp;if your average target CPU has more cores).
Note that each webworker will tessellate a single NURBS surface, i.e.&nbsp;scenes
with only one surface will not benefit from the parallelism.</P>
<P>By default, the tessellator tries to create a tessellation that represents
all important surface features in a way that a visual inspection from
mid to close viewing distance does not reveal the nature of the underlying
triangular representation. This may be too fine/slow for objects that are
never viewed from close distance or too coarse for very detailed objects.</P>
<P>Therefore, and in concordance with the respective suggestions of the X3D
specification, the tessellation quality and speed may be adjusted using the
<CODE>"uTessellation"</CODE> and <CODE>"vTessellation"</CODE> attributes of the
<CODE>&lt;NurbsPatchSurface&gt;</CODE> or
<CODE>&lt;NurbsTrimmedSurface&gt;</CODE> nodes as explained in the next sections.</P>



<H4><A NAME="s3"></A> Object Space Based Sampling</H4>

<P>If no <CODE>"uTessellation"</CODE> attribute is specified, or its value
is positive, the tessellator uses the so called <EM>object space sampling</EM>
mode. In this mode the tessellator subdivides an initial set of triangles
recursively until all edges of those triangles are shorter than a given
threshold value (in object space). The threshold value is set automatically
so that an object extending one unit by one unit in object space is subdivided
to about 15 by 15 by two triangles.
The <CODE>"uTessellation"</CODE> attribute value is simply multiplied into
this automatically determined threshold.</P>
<P>Therefore <CODE>"uTessellation"</CODE> values larger than 1.0 lead to a coarser
and faster tessellation, whereas values smaller than 1.0 lead to a
finer and slower tessellation.</P>
<P>Note that in this mode the value of the <CODE>"vTessellation"</CODE>
attribute is <EM>not</EM> considered at all.</P>
<P>Also note that in highly curved regions of the surface and at trim edges,
even smaller triangles than determined by the edge length criterion may
be created.</P>

<H4><A NAME="s3"></A> Parametric Space Based Sampling</H4>

<P>If the <CODE>"uTessellation"</CODE> attribute value is negative, the
tessellator switches to <EM>parametric space sampling</EM>.
In this mode also the <CODE>"vTessellation"</CODE> attribute is considered.</P>
<P>As in the object space sampling mode an automatic threshold value is
computed, but here the extension of the object in parametric space
(i.e.&nbsp;the number of control points) is used. This actually results
in two threshold values, one for each parametric dimension.
The <CODE>"uTessellation"</CODE> and <CODE>"vTessellation"</CODE> attributes are
multiplied into those thresholds.</P>
<P>Therefore, values larger than -1.0 (in absolute value) lead
to a coarser and faster tessellation in the respective dimension.
Values smaller than -1.0 (in absolute
value) lead to a finer and slower tessellation in the respective dimension.
This means a value of -2.0 leads to roughly half as many triangles
compared to the default and a value of -0.5 leads to twice as many
triangles when compared to the default in the respective parametric
dimension.</P>
<P>As the edge length computation is simpler and no curvature analysis is
taking place, the parametric space sampling is considerably faster than
object space sampling.</P>
<P>Note that at trim curve edges even smaller triangles than determined by
the edge length criterion may be created.</P>



<H4><A NAME="s3"></A> Additional Attributes</H4>

<P>To aid in parameterisation of the <CODE>"uTessellation"</CODE> and
<CODE>"vTessellation"</CODE> attributes, a <CODE>"normalPerVertex"</CODE> attribute
can be added to the respective <CODE>&lt;NurbsPatchSurface&gt;</CODE> or
<CODE>&lt;NurbsTrimmedSurface&gt;</CODE> node. This attribute will then also
be set for the corresponding <CODE>&lt;IndexedTriangleSet&gt;</CODE> node
that is created by the tessellator.
If the value of this attribute is <CODE>"false"</CODE>, x3dom will display
this surface in a flat shaded style and the tesselated triangles will be
visible allowing easier judgment and adjustment of the tesselation quality.</P>

<H4><A NAME="s3"></A> Restrictions and Implementation Deficiencies</H4>

<P>Due to memoization of surface points, parametric values must not
exceed:</P>





<P>
<EQ>
 1,7976931348623157&times;10<SUP>308</SUP> / 10&times;10<SUP>10</SUP> = 1,7976931348623157&times;10<SUP>297</SUP> 
</EQ>
</P>




<P>Texture coordinates are always directly derived from the parametric values.</P>
<P>Surface normals are not computed by the tessellator, but by x3dom.
This can lead to normals that are off for very coarse tessellations
but is much faster. Another benefit of this approach is, that normals
in non-differentiable surface points (e.g.&nbsp;the poles of the standard
NURBS sphere) do not flip.</P>
<P>There is <EM>no</EM> support for the following nodes:
<UL style="list-style: none; ">
<LI><CODE>&lt;NurbsTextureCoordinate&gt;</CODE>,</LI>
<LI><CODE>&lt;NurbsSet&gt;</CODE>,</LI>
<LI><CODE>&lt;NurbsSweptSurface&gt;</CODE>,</LI>
<LI><CODE>&lt;NurbsSwungSurface&gt;</CODE>,</LI>
<LI><CODE>&lt;NurbsCurve&gt;</CODE>, and all</LI>
<LI><CODE>&lt;Nurbs*Interpolator&gt;</CODE> nodes.</LI>
</UL>
</P>



<H2><A NAME="scriptobjs"></A> <A NAME="ss6.6">6.6</A> <A HREF="ayam.html#toc6.6">Distributed Script Objects</A>
</H2>

<P>These scripts implement Script objects, see also
section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tconetcl"></A> Truncated Cone</H3>

<P>
<CENTER>
<IMG SRC="pics/tcone.gif" HEIGHT=212 WIDTH=272  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Truncated Cone with ZMax 2.0</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The file <CODE>"tcone.tcl"</CODE> is a Script object script that creates
truncated cones with arguments
similar to the cylinder primitive, see also the above image.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"TConeAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the truncated cone:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the cone
may be used in CSG operations safely.
</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the cone in degrees,
default is 360.
</LI>
<LI><CODE>"ZMin"</CODE> is the base of the cone, default is 0.</LI>
<LI><CODE>"ZMax"</CODE> is the peak of the cone, default is 1.</LI>
<LI><CODE>"RMin"</CODE> is the radius of the cone at the base, default is 1.</LI>
<LI><CODE>"RMax"</CODE> is the radius of the cone at the peak, default is 0.5.</LI>
</UL>
</P>
<P>Internally, the script creates a Hyperboloid; further information about
conversion capabilities and RIB export may be found in
section 
<A HREF="ayam-4.html#hyperboloidobj">Hyperboloid</A>.</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/tcone.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="hdisktcl"></A> Disk with Hole</H3>

<P>
<CENTER>
<IMG SRC="pics/hdisk.gif" HEIGHT=179 WIDTH=180  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Disk with Hole Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The file <CODE>"hdisk.tcl"</CODE> is a Script object script that creates
a disk with a hole, also called an <EM>annulus</EM>.
See also the above image.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"HDiskAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the disk with hole:
<UL>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the disk in degrees,
default is 360.
</LI>
<LI><CODE>"RMin"</CODE> is the inner radius of the disk or radius of the hole,
default is 0.5.</LI>
<LI><CODE>"RMax"</CODE> is the outer radius of the disk, default is 1.0.</LI>
</UL>
</P>
<P>Internally, the script creates a Hyperboloid; further information about
conversion capabilities and RIB export may be found in
section 
<A HREF="ayam-4.html#hyperboloidobj">Hyperboloid</A>.</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/hdisk.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cboxtcl"></A> Box with Cylindrical Topology</H3>

<P>
<CENTER>
<IMG SRC="pics/cbox.gif" HEIGHT=194 WIDTH=206  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Box with Cylindrical Topology</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The file <CODE>"cbox.tcl"</CODE> is a Script object script that creates a NURBS
surface in the form of a box with a cylindrical topology, see also the
image above.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"CBoxAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the cylindrical box:
<UL>
<LI><CODE>"Width"</CODE> extension of the box along the X-axis, default is 1.0.</LI>
<LI><CODE>"Depth"</CODE> extension of the box along the Z-axis, default is 1.0.</LI>
<LI><CODE>"Height"</CODE> extension of the box along the Y-axis, default is 1.0.</LI>
</UL>
</P>
<P>In contrast to the standard Box object, the cylindrical box converts
to a single NURBS patch. However, this patch has poles and, consequently,
shading artefacts may appear on the top and down side. Texturing this
object is also challenging.</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/cbox.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tcircletcl"></A> NURBS Circle with Triangular Base</H3>

<P>
<CENTER>
<IMG SRC="pics/tcircle.gif" HEIGHT=252 WIDTH=280  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">NURBS Circle with Triangular Base</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The file <CODE>"tcircle.tcl"</CODE> is a Script object script that creates
NURBS circles with a triangular base, see also the above image.</P>
<P>In contrast to the standard nine point NURBS circle with rectangular base,
the triangular circle consists of just seven control points.
This can save some memory, e.g.&nbsp;in long sweep objects. However,
the parameterisation of the triangular circle is also slightly worse.
Furthermore, only full circles that start on the positive X-axis are
supported.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"TCircleAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the triangular circle:
<UL>
<LI><CODE>"Radius"</CODE> radius of the circle, default is 1.0.</LI>
</UL>
</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/tcircle.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="helixtcl"></A> Helix</H3>

<P>
<CENTER>
<IMG SRC="pics/helix.gif" HEIGHT=212 WIDTH=269  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Helix Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"helix.tcl"</CODE> creates a NURBS curve that forms a helix,
see also the above image.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
There is also a property GUI provided; one must
add a <CODE>"NP"</CODE> tag of value <CODE>"HelixAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the helix:
<UL>
<LI><CODE>"Length"</CODE> is the number of control points in the curve,
default is 30.</LI>
<LI><CODE>"Radius"</CODE> is the radius of the helix, default is 2.0.</LI>
<LI><CODE>"Angle"</CODE> is the offset angle of from one point to the next, default
is 45.0.</LI>
<LI><CODE>"DZ"</CODE> is the offset along z from one point to the next, default is
0.25.</LI>
</UL>
</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/helix.ay"</CODE>.</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="spiraltcl"></A> Spiral</H3>

<P>
<CENTER>
<IMG SRC="pics/spiral.gif" HEIGHT=184 WIDTH=213  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Spiral Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"spiral.tcl"</CODE> creates a NURBS curve that forms a spiral,
see also the above image.</P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
There is also a property GUI provided; one must
add a <CODE>"NP"</CODE> tag of value <CODE>"SpiralAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the spiral:
<UL>
<LI><CODE>"Length"</CODE> is the number of control points in the curve,
default is 30.</LI>
<LI><CODE>"Angle"</CODE> is the offset angle of from one point to the next, default
is 45.0.</LI>
<LI><CODE>"RMin"</CODE> is the start radius value, default is 0.1.</LI>
<LI><CODE>"RDiff"</CODE> is the radius difference from one point to the next,
default is 0.1.</LI>
</UL>
</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/spiral.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="dualsweeptcl"></A> DualSweep</H3>

<P>
<CENTER>
<IMG SRC="pics/dualsweep.gif" HEIGHT=223 WIDTH=509  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">DualSweep Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The file <CODE>"dualsweep.tcl"</CODE> is a Script object script that creates
a NURBS surface from three parameter curves similar to birailing but
with cross section curves perpendicular to both rails,
see also the above image.</P>
<P>The first curve is the so called <EM>cross section</EM>. This curve must be
planar and defined in the YZ-plane. It is the leftmost open curve in the
upper example image.<BR>
The second curve is the first <EM>rail</EM> curve. This curve should start in
the starting point of the cross section curve. It is the lower closed curve
in the upper example image.<BR>
The third parameter curve is the second <EM>rail</EM> curve. This curve should
start in the end point of the cross section curve. It is the upper closed curve
in the upper example image.</P>
<P>This script must be used in a Script object of type <CODE>"Modify"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"DualSweepAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the DualSweep:
<UL>
<LI><CODE>"Type"</CODE> similar to the corresponding property of the Sweep object,
this allows to set the type of the resulting surface (open, closed, or
periodic).</LI>
<LI><CODE>"Sections"</CODE> number of sections to use, also works in similar
fashion as for the Sweep object
(see also 
<A HREF="ayam-4.html#swp">SweepAttr Property</A>).
The default value is 0, i.e.&nbsp;the number of sections are determined
from the parameter curves dimensions.</LI>
</UL>
</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/dualsweep.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tsurftcl"></A> Translational Surface</H3>

<P>
<CENTER>
<IMG SRC="pics/tsurf.gif" HEIGHT=191 WIDTH=254  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Translational Surface Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"tsurf.tcl"</CODE> creates a translational surface from two
parameter curves, see also the above image.
The control points of the translational surface are created by copying
the control points of the first curve <I>n</I> times, where
<I>n</I> is the number of control points of the second curve, while also
offsetting the points according to the offset of the <I>nth</I> control point to
the first control point of the second curve.</P>
<P>The curves do not need to touch in any point, but if they start
in the same point, the translational surface will interpolate both curves.</P>
<P>Rational parameter curves are currently not supported.</P>
<P>This script must be used in a Script object of type <CODE>"Modify"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
As the surface is completely defined by the parameter curves, there are
no additional parameters and there is, consequently, also no property GUI.</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/tsurf.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="extrudentcl"></A> Extrusion along Normal</H3>

<P>
<CENTER>
<IMG SRC="pics/extruden.gif" HEIGHT=209 WIDTH=271  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Extrusion along Normal Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The script <CODE>"extruden.tcl"</CODE> extrudes a NURBS curve along
its normal, see also the above image.<BR>
If the curve object has a MN tag, it will take precedence
over the normal computation via <CODE>"getPlaneNormal"</CODE>. This is faster and
also allows to create sheared extrusions.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Internally, the script creates a Skin from two curves, therefore, arbitrarily
oriented and non-planar curves are supported.</P>
<P>This script must be used in a Script object of type <CODE>"Modify"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; one must add a <CODE>"NP"</CODE> tag
of value <CODE>"ExtrudeNAttr"</CODE> to the Script object to see it.</P>
<P>These are the parameters of the extrusion:
<UL>
<LI><CODE>"Height"</CODE> is the amount of displacement of the second curve
along the normal, default is 1.0.</LI>
</UL>
</P>
<P>An example scene file containing such an object is distributed with Ayam,
see the file:<BR>
<CODE>"ayam/scn/scripts/extruden.ay"</CODE>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="polyhedronjs"></A> Create Polyhedrons from Conway Notations</H3>

<P>
<CENTER>
<IMG SRC="pics/polyh-jtD.gif" HEIGHT=230 WIDTH=225  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Polyhedron generated from Conway notation: <CODE>"jtD"</CODE></FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Since Ayam 1.18 there is a complete example script for the JavaScript
scripting interface distributed as <CODE>"polyhedron.js"</CODE> which
creates polyhedrons from Conway notations.
The script is based on the online Polyhedron VRML generator by
George W. Hart:<BR>
<CODE>http://www.georgehart.com/virtual-polyhedra/conway_notation.html</CODE></P>
<P>This script must be used in a Script object of type <CODE>"Create"</CODE>
(see section 
<A HREF="ayam-4.html#scriptobj">Script Object</A>).
For convenience, there is also a property GUI; to make this GUI visible
a <CODE>"NP"</CODE> tag of value <CODE>"PolyhedronAttr"</CODE> must be added to the Script
object.</P>
<P>The Conway notation defines a set of operations executed consecutively
on a seed/basic shape.
The script currently supports the following seeds and operations
(information taken from George W. Harts fine web pages, see above).</P>
<P><B>Seeds:</B><BR>
The Platonic solids are denoted T, O, C, I, and D, according to their
first letter. Other polyhedra which are implemented here include prisms:
Pn, antiprisms: An, and pyramids: Yn, where n is a number (3 or greater)
which must be specified to indicate the size of the base, e.g.&nbsp;,
Y3=T, P4=C, and A3=O.</P>
<P><B>Operations:</B><BR>
Currently, d, t, k, a, j, s, g, e, b, o, m, r, and p are defined.
They are motivated by the operations needed to create the Archimedean
solids and their duals from the Platonic solids. The following tables
explain the operations in more detail:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Letter</B></TD><TD><B>Name</B></TD><TD><B>Description</B></TD></TR><TR><TD>
<CODE>d</CODE></TD><TD>dual</TD><TD>The dual of a polyhedron has a vertex for each face, and a face for each vertex, of the original polyhedron, e.g.&nbsp;dC=O.</TD></TR><TR><TD>
<CODE>t</CODE>&thinsp;/&thinsp;<CODE>t</CODE><EM>n</EM></TD><TD>truncate all&thinsp;/&thinsp;just <EM>n</EM>-fold vertices</TD><TD>Truncating a polyhedron cuts off each vertex, producing a new <EM>n</EM>-sided face for each <EM>n</EM>-fold vertex.</TD></TR><TR><TD>
<CODE>k</CODE>&thinsp;/&thinsp;<CODE>k</CODE><EM>n</EM></TD><TD>kis all&thinsp;/&thinsp;just <EM>n</EM>-sided faces</TD><TD>The kis operation divides each <EM>n</EM>-sided face into <EM>n</EM> triangles. A new vertex is added in the center of each face.</TD></TR><TR><TD>
<CODE>a</CODE></TD><TD>ambo</TD><TD>The ambo operation can be thought of as truncating to the edge midpoints. It produces a polyhedron, aX, with one vertex for each edge of X.</TD></TR><TR><TD>
<CODE>j</CODE></TD><TD>join</TD><TD>The join operator is dual to ambo, so jX=dadX=daX. jX is like kX without the original edges of X.</TD></TR><TR><TD>
<CODE>e</CODE></TD><TD>expand</TD><TD>Each face of X is separated from all its neighbors and reconnected with a new 4-sided face, corresponding to an edge of X. An n-gon is then added to connect the 4-sided faces at each n-fold vertex.</TD></TR><TR><TD>
<CODE>s</CODE></TD><TD>snub</TD><TD>The snub operation can be thought of as eC followed by the operation of slicing each of the new 4-fold faces along a diagonal into two triangles. With a consistent handedness to these cuts, all the vertices of sX are 5-fold.</TD></TR><TR><TD>
<CODE>g</CODE></TD><TD>gyro</TD><TD>The dual operation to s is g. g is like k but with the new edges connecting the face centers to the 1/3 points on the edges rather than the vertices.</TD></TR><TR><TD>
<CODE>b</CODE></TD><TD>bevel</TD><TD>The bevel operation can be defined by bX=taX.</TD></TR><TR><TD>
<CODE>o</CODE></TD><TD>ortho</TD><TD>Dual to e, oX=deX=jjX. oX has the effect of putting new vertices in the middle of each face of X and connecting them, with new edges, to the edge midpoints of X.</TD></TR><TR><TD>
<CODE>m</CODE></TD><TD>meta</TD><TD>Dual to b, m is like k and o combined; new edges connect new vertices at the face centers to the old vertices and new vertices at the edge midpoints.
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Conway Notation Operations</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Letter</B></TD><TD><B>Name</B></TD><TD><B>Description</B></TD></TR><TR><TD>
<CODE>r</CODE></TD><TD>reflect</TD><TD>Changes a left-handed solid to right handed, or vice versa, but has no effect on a reflexible solid. So rC=C, but compare sC and rsC.</TD></TR><TR><TD>
<CODE>p</CODE></TD><TD>propellor</TD><TD>Makes each n-gon face into a "propellor" of an n-gon surrounded by n quadrilaterals, e.g.&nbsp;pT is the tetrahedrally stellated icosahedron. Try pkD and pt6kT. p is a self-dual operation, i.e., dpdX=pX and dpX=pdX, and p also commutes with a and j, i.e.&nbsp;paX=apX.
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Additional Operations</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>These abbreviated explanations were again taken from George W. Hart.</P>



<H2><A NAME="jsinterp"></A> <A NAME="ss6.7">6.7</A> <A HREF="ayam.html#toc6.7">JavaScript Scripting Interface</A>
</H2>

<P>This sections contains the documentation of the JavaScript scripting
interface which is available after loading of the <CODE>"jsinterp"</CODE>
plugin.</P>
<P>The JavaScript scripting interface exists since Ayam 1.18 and
is based on the Mozilla SpiderMonkey JavaScript engine.</P>
<P>Upon loading, the <CODE>"jsinterp"</CODE> plugin creates <EM>one</EM> JavaScript
context that lives (with all variables and objects defined therein)
until Ayam exits.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Accessing JavaScript from Tcl and Script Objects</H3>

<P>The JavaScript functionality may be accessed from the Tcl scripting interface
via the <CODE>"jsEval"</CODE> command. The command can be used either to
directly execute JavaScript code provided via the commands argument
(Tcl code in <B>bold</B>):
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>jsEval {</B>var a = 0; a = a + 5.5; tclset("a", a);<B>}</B></CODE>
</CODE></BLOCKQUOTE>

or to execute JavaScript code from a file:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>jsEval -f scriptfile.js</B></CODE>
</CODE></BLOCKQUOTE>
</P>
<P>Note, that this command is not available in the safe interpreter.</P>
<P>Furthermore, Script object scripts may also be implemented in JavaScript,
provided the first line of the script is a comment that instructs Ayam to
use the JavaScript interpreter:
<BLOCKQUOTE><CODE>
<CODE>/* Ayam, use: JavaScript */<BR>
var a = 0;<BR>
...</CODE>
</CODE></BLOCKQUOTE>

Note that the JavaScript scripting context inherits the limitations
of the calling Tcl context.
For example, when running in a Script object,
the following code fails:
<BLOCKQUOTE><CODE>
<CODE>tcleval("<B>exit</B>");</CODE>
</CODE></BLOCKQUOTE>

because the Tcl command <CODE>"exit"</CODE> is not available in the safe interpreter.
The command will not fail, when the calling context is the main Tcl
interpreter; one can e.g.&nbsp;type into the Ayam console:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>jsEval {</B>tcleval("<B>exit</B>");<B>}</B></CODE>
</CODE></BLOCKQUOTE>

and Ayam quits (see also section:
<A HREF="ayam-4.html#safeinterp">Safe Interpreter</A>).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>JavaScript Functions</H3>

<P>This subsection informs about the global functions additionally
available in the Ayam JavaScript interpreter.</P>
<P>Those are converted Tcl commands (e.g.&nbsp;<CODE>"crtOb()"</CODE>),
<CODE>"tcleval()"</CODE>, <CODE>"tclvar()"</CODE>, and <CODE>"tclset()"</CODE>.</P>
<P><CODE><B>Converted Commands:</B></CODE>
<A NAME="jscc"></A> <BR>
The functionality of Ayam is accessible from JavaScript via a larger
set of global functions, named as the corresponding Tcl commands.
For instance, Ayam objects can be created in JavaScript using a function call
like this:
<BLOCKQUOTE><CODE>
<CODE>crtOb("NCircle");</CODE>
</CODE></BLOCKQUOTE>

or, with additional arguments:
<BLOCKQUOTE><CODE>
<CODE>crtOb("NCircle", "-radius", 3.0);</CODE>
</CODE></BLOCKQUOTE>

In general, all commands available in the safe Ayam Tcl interpreter are also
available as function (refer to section
<A HREF="#sccomm">Procedures and Commands</A>
for a more or less complete list of those commands).</P>
<P>Note that Tcl procedures are generally not available as global JavaScript
function, but they can be called using <CODE>"tcleval()"</CODE> as documented
in the next paragraph.</P>


<P><CODE><B>tcleval():</B></CODE>
<A NAME="tcleval"></A> <BR>
This global JavaScript function allows to evaluate arbitrary
Tcl scripts, delivered as string argument:
<BLOCKQUOTE><CODE>
<CODE>var a = 42;<BR>
a = tcleval("<B>puts </B>" + a + "<B>; return 5;</B>");<BR>
tcleval("<B>puts </B>" + a);<BR>
/* expected output: 42 5 */</CODE>
</CODE></BLOCKQUOTE>

The <CODE>"tcleval()"</CODE> function provides access to all the
functionality of Ayam that is just available as a Tcl procedure.
Note that return values are properly transferred back to JavaScript
according to the rules for data conversion as documented below.
However, due to an intermediate conversion to string data, the overhead of
such a call is considerable and bulk data transport should be arranged
by other means, see below.</P>


<P><CODE><B>tclvar():</B></CODE>
<A NAME="tclvar"></A> <BR>
Using the JavaScript function <CODE>"tclvar()"</CODE> a link between a Tcl
variable and a corresponding variable in the
JavaScript context may be established.
The <CODE>"tclvar()"</CODE> function essentially creates a write trace on the Tcl
variable, so that changes on the Tcl side are always automatically
reflected on the JavaScript side:
<BLOCKQUOTE><CODE>
<CODE>tclvar("a");<BR>
tcleval("<B>set a 42</B>");<BR>
tcleval("<B>puts </B>" + a);<BR>
/* expected output: 42 */</CODE>
</CODE></BLOCKQUOTE>

Mind that the corresponding variable on the JavaScript side does
<EM>not</EM> exist until the first write operation on the Tcl variable
occurs.
The Tcl variable, in turn, does not have to exist, when the
<CODE>"tclvar()"</CODE> function is called (i.e.&nbsp;all the work is done
in the trace callback). If the variable name contains a namespace
specifier, this namespace has to exist, when <CODE>"tclvar()"</CODE> is called.</P>
<P>Even though it looks a perfect fit, <CODE>"tclvar()"</CODE> can not be used to
manage a property data array (if the array contains components
to be saved to Ayam scene files). This is, because upon reading a scene
file with such saved array items, the items will be read (and put into
the Tcl context) before the script can establish the write trace using
<CODE>"tclvar()"</CODE> and the data from the scene file never arrives in the
JavaScript context.
There is no easy way to get around this.
A suggested way to manage a property data array is shown in the
complete examples section below.</P>


<P><CODE><B>tclset():</B></CODE>
<A NAME="tclset"></A> <BR>
The third global JavaScript function is <CODE>"tclset()"</CODE> that
allows to efficiently set Tcl variables from the JavaScript context
avoiding conversion to string data and back.
For example:
<BLOCKQUOTE><CODE>
<CODE>var a = 3.3;<BR>
var b = new Array(1, 3, 5);<BR>
tclset("a", a);<BR>
tclset("b", b);</CODE>
</CODE></BLOCKQUOTE>

sets the Tcl variable <CODE>"a"</CODE> to the floating point value 3.3,
and <CODE>"b"</CODE> to a list of integer values
<CODE>{ 1 3 5 }</CODE>.<BR>
Note that the variable names may also point to Tcl array elements,
for instance
<BLOCKQUOTE><CODE>
<CODE>tclset("SphereAttrData(Radius)", 1.2);</CODE>
</CODE></BLOCKQUOTE>

sets the <CODE>Radius</CODE> element in the <CODE>SphereAttrData</CODE> array;
or contain namespace specifiers, for example
<BLOCKQUOTE><CODE>
<CODE>tclset("::MyNameSpace::Radius", 1.2);</CODE>
</CODE></BLOCKQUOTE>

sets the <CODE>Radius</CODE> variable in the <CODE>MyNameSpace</CODE> namespace.</P>


<div style="height: 0.5em">&nbsp;</div>
<H3>Data Conversion</H3>

<P>When data is transferred from the Tcl to the JavaScript side
(e.g.&nbsp;while converting return values of <CODE>"tcleval()"</CODE> or variable
values linked via <CODE>"tclvar()"</CODE>),
the following conversions are in effect:
Scalar data types will be converted to their directly matching counterparts,
except for Booleans, which will be converted to integer values.
Lists will be converted to Array objects (nesting is allowed and will
produce accordingly nested arrays).
Associative arrays will be converted to objects with named properties.
Unicode strings are currently not supported.
See also the table below.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Tcl</B></TD><TD><B>JavaScript</B></TD></TR><TR><TD>
Boolean (true, false)</TD><TD>Integer (1, 0)</TD></TR><TR><TD>
Integer (2)</TD><TD>Integer (2)</TD></TR><TR><TD>
Double (3.14)</TD><TD>Double (3.14)</TD></TR><TR><TD>
String ("mystr")</TD><TD>String ("mystr")</TD></TR><TR><TD>
List ({0 1 2})</TD><TD>Array ((0, 1, 2))</TD></TR><TR><TD>
Array (mya(mye) = 0.1)</TD><TD>Object (mya.mye = 0.1)
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Tcl to JavaScript Data Conversions</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>When data is transferred from the JavaScript side to the Tcl side
(e.g.&nbsp;as function argument), the following conversions are in
effect:
Scalar data types will be converted to their directly matching counterparts,
Array objects will be converted to lists (nesting is allowed and will
produce accordingly nested lists).
Unicode strings and objects of a type other than Array (e.g.&nbsp;Boolean) are
currently not supported.
See also the following table.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>JavaScript</B></TD><TD><B>Tcl</B></TD></TR><TR><TD>
Integer (2)</TD><TD>Integer (2)</TD></TR><TR><TD>
Double (3.14)</TD><TD>Double (3.14)</TD></TR><TR><TD>
String ("mystr")</TD><TD>String ("mystr")</TD></TR><TR><TD>
Array ((0, 1, 2))</TD><TD>List ({0 1 2})
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">JavaScript to Tcl Data Conversions</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The transport/conversion of object properties (to e.g.&nbsp;associative array
elements) can be arranged manually like this:
<BLOCKQUOTE><CODE>
<CODE>var a = new Object();<BR>
a.b = 3.14;<BR>
tclset("a(b)", a.b);</CODE>
</CODE></BLOCKQUOTE>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Complete Examples</H3>

<P>This section contains two complete examples for Script objects
written in JavaScript.</P>
<P>For the first example use Script object type <CODE>"Modify"</CODE> and put a Sphere
as child object of the Script object.
<HR>
<PRE>
/* Ayam, use: JavaScript */
tclvar("SphereAttrData");
getProp();
if(SphereAttrData)
{
  tclset("SphereAttrData(ZMin)", -SphereAttrData.Radius);
  tclset("SphereAttrData(ZMax)", SphereAttrData.Radius);
  setProp();
}
</PRE>
<HR>

The above script will make sure, that the ZMin and ZMax parameters of
the Sphere object always match its radius.</P>
<P>First, a link from the original Sphere object property data array
<CODE>"SphereAttrData"</CODE> is established, so that when <CODE>"getProp()"</CODE>
(a converted Tcl Ayam command) is called, also the JavaScript
object <CODE>"SphereAttrData"</CODE> is filled with meaningful data.<BR>
The next line (the <CODE>if</CODE>) is a safety measure that prevents the script
from failing if the child object of the Script object is not a Sphere
object.<BR>
Now the radius value is transferred back to Tcl directly into
the property data array to the ZMin and ZMax entries respectively
with the help of <CODE>"tclset()"</CODE>.<BR>
Finally, the modified property is transferred back to the Sphere object
again with a converted Tcl Ayam command <CODE>"setProp()"</CODE>.</P>


<P>The next example shows, how to manage a property GUI in a JavaScript
implemented Script object script. Use Script object type <CODE>"Create"</CODE>
and add a tag <CODE>"NP MyProp"</CODE> to see the property GUI.
<HR>
<PRE>
/* Ayam, use: JavaScript, save array: MyPropData */
var MyPropData = new Object();
if(!tcleval("info exists MyPropData;"))
{
  /* initial script run (but not when loaded from scene file!) */
  MyPropData.MyItem = tcleval("set MyPropData(MyItem) 1.0;");
  tcleval("set MyPropData(SP) {MyItem};");
}
else
{
  /* all following script runs (and also when loaded from scene file!) */
  MyPropData.MyItem = tcleval("set MyPropData(MyItem);");
}
if(!tcleval("info exists MyPropGUI;"))
{
  tcleval("set ::phw [addPropertyGUI MyProp \"\" \"\"];");
  tcleval("addParam $::phw MyPropData MyItem;");
}
crtOb("Sphere");
sL();
getProp();
tclset("SphereAttrData(Radius)", MyPropData.MyItem);
tclset("SphereAttrData(ZMin)", -MyPropData.MyItem);
tclset("SphereAttrData(ZMax)", MyPropData.MyItem);
setProp();
</PRE>
<HR>
</P>
<P>This example demonstrates how to manage property data using the
JavaScript object variable <CODE>"MyPropData"</CODE>. The property data
can be saved to and read from Ayam scene files with the help of
a mirroring array variable on the Tcl side (also named
<CODE>"MyPropData"</CODE>).
To make this work properly, the initialisation of the JavaScript
object must be constrained to the first script run: when the
property data was read from a scene file, initialisation must
not be run, instead the read data must be fetched from the Tcl
context.
This is what the first <CODE>"if"</CODE> statement, checking for existence
of the mirroring Tcl array variable, in above example is all about.</P>
<P>Following this scheme of dual mirroring data structures on the
Tcl and JavaScript sides, now the property GUI is created, which is also
constrained to just one script run by a similar <CODE>"if"</CODE> statement.</P>
<P>After the GUI, a Sphere object is created and parameterised
according to the data in the property GUI, which is used as
radius, zmin, and zmax value.</P>



<H2><A NAME="luainterp"></A> <A NAME="ss6.8">6.8</A> <A HREF="ayam.html#toc6.8">Lua Scripting Interface</A>
</H2>

<P>This sections contains the documentation of the Lua scripting
interface which is available after loading of the <CODE>"luainterp"</CODE>
plugin.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Upon loading, the <CODE>"luainterp"</CODE> plugin creates <EM>one</EM> Lua
context that lives (with all variables and objects defined therein)
until Ayam exits.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Accessing Lua from Tcl and Script Objects</H3>

<P>The Lua functionality may be accessed from the Tcl scripting interface
via the <CODE>"luaEval"</CODE> command. The command can be used either to
directly execute Lua code provided via the commands argument
(Tcl code in <B>bold</B>):
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>luaEval {</B>a = 0; a = a + 5.5; tclset("a", a);<B>}</B></CODE>
</CODE></BLOCKQUOTE>

or to execute Lua code from a file:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>luaEval -f scriptfile.lua</B></CODE>
</CODE></BLOCKQUOTE>
</P>
<P>Note, that this command is not available in the safe interpreter.</P>
<P>Furthermore, Script object scripts may also be implemented in Lua,
provided the first line of the script is a comment that instructs Ayam to
use the Lua interpreter:
<BLOCKQUOTE><CODE>
<CODE>-- Ayam, use: Lua<BR>
a = 0<BR>
...</CODE>
</CODE></BLOCKQUOTE>

Note that the Lua scripting context inherits the limitations
of the calling Tcl context.
For example, when running in a Script object,
the following code fails:
<BLOCKQUOTE><CODE>
<CODE>tcleval("<B>exit</B>")</CODE>
</CODE></BLOCKQUOTE>

because the Tcl command <CODE>"exit"</CODE> is not available in the safe interpreter.
The command will not fail, when the calling context is the main Tcl
interpreter; one can e.g.&nbsp;type into the Ayam console:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;<B>luaEval {</B>tcleval("<B>exit</B>")<B>}</B></CODE>
</CODE></BLOCKQUOTE>

and Ayam quits (see also section:
<A HREF="ayam-4.html#safeinterp">Safe Interpreter</A>).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Lua Functions</H3>

<P>This subsection informs about the global functions additionally
available in the Ayam Lua interpreter.</P>
<P>Those are converted Tcl commands (e.g.&nbsp;<CODE>"crtOb()"</CODE>),
<CODE>"tcleval()"</CODE>, <CODE>"tclvar()"</CODE>,
and <CODE>"tclset()"</CODE>.</P>
<P><CODE><B>Converted Commands:</B></CODE>
<A NAME="luacc"></A> <BR>
The functionality of Ayam is accessible from Lua via a larger
set of global functions, named as the corresponding Tcl commands.
For instance, Ayam objects can be created in Lua using a function call
like this:
<BLOCKQUOTE><CODE>
<CODE>crtOb("NCircle")</CODE>
</CODE></BLOCKQUOTE>

or, with additional arguments:
<BLOCKQUOTE><CODE>
<CODE>crtOb("NCircle", "-radius", 3.0)</CODE>
</CODE></BLOCKQUOTE>

In general, all commands available in the safe Ayam Tcl interpreter are also
available as function (refer to section
<A HREF="#sccomm">Procedures and Commands</A>
for a more or less complete list of those commands).</P>
<P>Note that Tcl procedures are generally not available as global Lua function,
but they can be called using <CODE>"tcleval()"</CODE> as documented
in the next paragraph.</P>


<P><CODE><B>tcleval():</B></CODE>
<A NAME="luatcleval"></A> <BR>
This Lua function allows to evaluate arbitrary
Tcl scripts, delivered as string argument:
<BLOCKQUOTE><CODE>
<CODE>a = 42<BR>
a = tcleval("<B>puts </B>" ..&ensp;a ..&ensp;"<B>; return 5;</B>")<BR>
tcleval("<B>puts </B>" ..&ensp;a)<BR>
-- expected output:&ensp;42 5</CODE>
</CODE></BLOCKQUOTE>

The <CODE>"tcleval()"</CODE> function provides access to all the
functionality of Ayam that is just available as a Tcl procedure.
Note that return values are properly transferred back to Lua
according to the rules for data conversion as documented below.
However, due to an intermediate conversion to string data, the overhead of
such a call is considerable and bulk data transport should be arranged
by other means, see below.</P>


<P><CODE><B>tclvar():</B></CODE>
<A NAME="luatclvar"></A> <BR>
Using the Lua function <CODE>"tclvar()"</CODE> a link between a Tcl variable
and a corresponding variable in the Lua context can be established.
The <CODE>"tclvar()"</CODE> function creates a write trace on the Tcl
variable, so that changes on the Tcl side are always automatically
reflected on the Lua side:
<BLOCKQUOTE><CODE>
<CODE>tclvar("a")<BR>
tcleval("<B>set a 42</B>")<BR>
tcleval("<B>puts </B>" ..&ensp;a)<BR>
-- expected output:&ensp;42</CODE>
</CODE></BLOCKQUOTE>

Mind that the corresponding variable on the Lua side does
<EM>not</EM> exist until the first write operation onto the Tcl
variable occurs.
The Tcl variable, in turn, does not have to exist, when the
<CODE>"tclvar()"</CODE> function is called (i.e.&nbsp;all the work is done
in the trace callback). If the variable name contains a namespace
specifier, this namespace has to exist, when <CODE>"tclvar()"</CODE> is called.</P>
<P>Even though it looks a perfect fit, <CODE>"tclvar()"</CODE> can not be used to
manage a property data array (if the array contains components
to be saved to Ayam scene files). This is, because upon reading a scene
file with such saved array items, the items will be read (and put into
the Tcl context) before the script can establish the write trace using
<CODE>"tclvar()"</CODE> and the data from the scene file never arrives in the Lua
context.
There is no easy way to get around this.
A suggested way to manage a property data array is shown in the
complete examples section below.</P>


<P><CODE><B>tclset():</B></CODE>
<A NAME="luatclset"></A> <BR>
The third global Lua function is <CODE>"tclset()"</CODE> that
allows to efficiently set Tcl variables from the Lua context
avoiding conversion to string data and back.
For example:
<BLOCKQUOTE><CODE>
<CODE>a = 3.3<BR>
b = {1, 3, 5}<BR>
tclset("a", a)<BR>
tclset("b", b)</CODE>
</CODE></BLOCKQUOTE>

sets the Tcl variable <CODE>"a"</CODE> to the floating point value 3.3,
and <CODE>"b"</CODE> to a list of integer values
<CODE>{ 1 3 5 }</CODE>.<BR>
Note that the variable names may also point to Tcl array elements,
for instance
<BLOCKQUOTE><CODE>
<CODE>tclset("SphereAttrData(Radius)", 1.2)</CODE>
</CODE></BLOCKQUOTE>

sets the <CODE>Radius</CODE> element in the <CODE>SphereAttrData</CODE> array;
or contain namespace specifiers, for example
<BLOCKQUOTE><CODE>
<CODE>tclset("::MyNameSpace::Radius", 1.2)</CODE>
</CODE></BLOCKQUOTE>

sets the <CODE>Radius</CODE> variable in the <CODE>MyNameSpace</CODE> namespace.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Data Conversion</H3>

<P>When data is transferred from the Tcl to the Lua side
(e.g.&nbsp;while converting return values of <CODE>"tcleval()"</CODE> or variable
values linked via <CODE>"tclvar()"</CODE>),
the following conversions are in effect:
Scalar data types will be converted to their directly matching counterparts.
Lists will be converted to array-tables (nesting is allowed and will
produce accordingly nested tables).
Associative arrays will be converted to tables with properly named keys.
Unicode strings are currently not supported.
See also the table below.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Tcl</B></TD><TD><B>Lua</B></TD></TR><TR><TD>
Boolean (true, false)</TD><TD>Boolean (true, false)</TD></TR><TR><TD>
Integer (2)</TD><TD>Integer (2)</TD></TR><TR><TD>
Double (3.14)</TD><TD>Double (3.14)</TD></TR><TR><TD>
String ("mystr")</TD><TD>String ("mystr")</TD></TR><TR><TD>
List ({0 1 2})</TD><TD>Array ({0, 1, 2})</TD></TR><TR><TD>
Array (mya(mye) = 0.1)</TD><TD>Table (mya.mye = 0.1)
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Tcl to Lua Data Conversions</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>When data is transferred from the Lua side to the Tcl side
(e.g.&nbsp;as function argument), the following conversions are in
effect:
Scalar data types will be converted to their directly matching counterparts,
array-tables will be converted to lists (nesting is allowed and will
produce accordingly nested lists). Sparse and mixed tables are currently not
supported.
Unicode strings are also currently not supported.
See also the following table.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Lua</B></TD><TD><B>Tcl</B></TD></TR><TR><TD>
Boolean (true, false)</TD><TD>Boolean (true, false)</TD></TR><TR><TD>
Integer (2)</TD><TD>Integer (2)</TD></TR><TR><TD>
Double (3.14)</TD><TD>Double (3.14)</TD></TR><TR><TD>
String ("mystr")</TD><TD>String ("mystr")</TD></TR><TR><TD>
Array ({0, 1, 2})</TD><TD>List ({0 1 2})
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Lua to Tcl Data Conversions</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The transport/conversion of table entries (to e.g.&nbsp;associative array
elements) can be arranged manually like this:
<BLOCKQUOTE><CODE>
<CODE>a.b = 3.14<BR>
tclset("a(b)", a.b)</CODE>
</CODE></BLOCKQUOTE>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Complete Examples</H3>

<P>This section contains two complete examples for Script objects
written in Lua.</P>
<P>For the first example use Script object type <CODE>"Modify"</CODE> and put a Sphere
as child object of the Script object.
<HR>
<PRE>
-- Ayam, use: Lua
tclvar("SphereAttrData")
getProp()
if SphereAttrData then
  tclset("SphereAttrData(ZMin)", -SphereAttrData.Radius)
  tclset("SphereAttrData(ZMax)", SphereAttrData.Radius)
  setProp()
end
</PRE>
<HR>

The above script will make sure, that the ZMin and ZMax parameters of
the Sphere object always match its radius.</P>
<P>First, a link from the original Sphere object property data array
<CODE>"SphereAttrData"</CODE> is established, so that when <CODE>"getProp()"</CODE>
(a converted Tcl Ayam command) is called, also the Lua
object <CODE>"SphereAttrData"</CODE> is filled with meaningful data.<BR>
The next line (the <CODE>if</CODE>) is a safety measure that prevents the script
from failing if the child object of the Script object is not a Sphere
object.<BR>
Now the radius value is transferred back to Tcl directly into
the property data array to the ZMin and ZMax entries respectively
with the help of <CODE>"tclset"</CODE>.<BR>
Finally, the modified property is transferred back to the Sphere object
again with a converted Tcl Ayam command <CODE>"setProp()"</CODE>.</P>


<P>The next example shows, how to manage a property GUI in a Lua
implemented Script object script. Use Script object type <CODE>"Create"</CODE>
and add a tag <CODE>"NP MyProp"</CODE> to see the property GUI.
<HR>
<PRE>
-- Ayam, use: Lua, save array: MyPropData

if tcleval("info exists MyPropData;") == 0 then
  -- initial script run (but not when loaded from scene file!)
  MyPropData = {}
  MyPropData.MyItem = tcleval("set MyPropData(MyItem) 1.0;")
  tcleval("set MyPropData(SP) {MyItem};")
else
  -- all following script runs (and also when loaded from scene file!)
  MyPropData = {}
  MyPropData.MyItem = tcleval("set MyPropData(MyItem);")
end

if tcleval("info exists MyPropGUI;") == 0 then
  -- create property GUI "MyProp"
  tcleval("set ::phw [addPropertyGUI MyProp \"\" \"\"];")
  tcleval("addParam $::phw MyPropData MyItem;")
end

crtOb("Sphere")
sL()
getProp()
tclset("SphereAttrData(Radius)", MyPropData.MyItem)
tclset("SphereAttrData(ZMin)", -MyPropData.MyItem)
tclset("SphereAttrData(ZMax)", MyPropData.MyItem)
setProp()
</PRE>
<HR>
</P>
<P>This example demonstrates how to manage property data using the
Lua object variable <CODE>"MyPropData"</CODE>. The property data
can be saved to and read from Ayam scene files with the help of
a mirroring array variable on the Tcl side (also named
<CODE>"MyPropData"</CODE>).
To make this work properly, the initialisation of the Lua
object must be constrained to the first script run: when the
property data was read from a scene file, initialisation must
not be run, instead the read data must be fetched from the Tcl
context.
This is what the first <CODE>"if"</CODE> statement, checking for existence
of the mirroring Tcl array variable, in above example is all about.</P>
<P>Following this scheme of dual mirroring data structures on the
Tcl and Lua sides, now the property GUI is created, which is also
constrained to just one script run by a similar <CODE>"if"</CODE> statement.</P>
<P>After the GUI, a Sphere object is created and parameterised
according to the data in the property GUI, which is used as
radius, zmin, and zmax value.</P>

<HR>
<A HREF="ayam-7.html">Next</A>
<A HREF="ayam-5.html">Previous</A>
<A HREF="ayam.html#toc6">Contents</A>
</BODY>
</HTML>


