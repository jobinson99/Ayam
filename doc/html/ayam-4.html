<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.66">
 <TITLE>Ayam: Objects, Properties, and Tags</TITLE>
 <LINK HREF="ayam-5.html" REL=next>
 <LINK HREF="ayam-3.html" REL=previous>
 <LINK HREF="ayam.html#toc4" REL=contents>
</HEAD>
<BODY>
<script type="text/javascript" src="ll.js"></script>
<A HREF="ayam-5.html">Next</A>
<A HREF="ayam-3.html">Previous</A>
<A HREF="ayam.html#toc4">Contents</A>
<HR>
<H2><A NAME="obandprp"></A> <A NAME="s4">4.</A> <A HREF="ayam.html#toc4">Objects, Properties, and Tags</A></H2>

<P>This section informs about the different object types of Ayam and
about the property GUIs that appear in the properties section of the
main window if a single object and a property have been selected.</P>
<P>Note that the <CODE>"Help on object"</CODE> and <CODE>"Help on property"</CODE>
main menu entries in Ayam can be used to directly jump to the appropriate
sub-section of this part of the documentation.</P>
<P>Documentation on the standard properties (Transformations, Attributes,
Material, Shader, and Tags) can be found in
section 
<A HREF="#stdprop">Standard Properties</A>.</P>
<P>Furthermore, this section contains information about all tag types,
see section 
<A HREF="#tags">Tags</A>.</P>
<P>In the next sections general object capabilities will be briefly
documented in tables like this:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Object Type</TD><TD>No&thinsp;/&thinsp;Object Type<SUP>+/&lowast;</SUP></TD><TD>Yes/No</TD><TD>N/A&thinsp;/&thinsp;Children&thinsp;/&thinsp;Object Type<SUP>+/&lowast;</SUP></TD><TD>Yes/No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Object Capabilities Template</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The capabilities are:
<UL>
<LI><B>Type</B>: the type name as displayed in the object tree view
and understood by the <CODE>"crtOb"</CODE> scripting interface command;</LI>
<LI><B>Parent of</B>: the object is a parent object (can have child
objects of the designated type),<BR>
<SUP>+</SUP> &ndash; multiple child objects may be present
(one or many),<BR>
<SUP>&lowast;</SUP> &ndash; multiple child objects must be present
(many),<BR>
note that the type of the child object(s) does not
need to match directly, the child(ren) must rather provide an object
of the appropriate type (see also section
<A HREF="ayam-8.html#toolobj">The Modelling Concept Tool-Objects</A>);</LI>
<LI><B>Material</B>: the object can be associated with a material;</LI>
<LI><B>Converts to&thinsp;/&thinsp;Provides</B>: type of converted or
provided objects (Children means, the provided objects of the children are
delivered upstream),<BR>
<SUP>+</SUP> &ndash; multiple objects may be provided (one or many),<BR>
<SUP>&lowast;</SUP> &ndash; multiple objects will be provided (many);</LI>
<LI><B>Point Edit</B>: the object has editable points,<BR>
* &ndash; read only points are supported.</LI>
</UL>
</P>


<P>Example:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Revolve</TD><TD>NCurve</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Object Capabilities Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Explanation:
<UL>
<LI><B>Type</B>: the Revolve object has the type name <CODE>"Revolve"</CODE>,
i.e.&nbsp;it can be created from scripts using the command <CODE>"crtOb Revolve"</CODE>;</LI>
<LI><B>Parent of</B>: the Revolve object has one NCurve (or NCurve providing
object) as child;</LI>
<LI><B>Material</B>: the Revolve object can be associated with a material;</LI>
<LI><B>Converts to&thinsp;/&thinsp;Provides</B>: the Revolve object
converts to (and provides) one or multiple NPatch objects;</LI>
<LI><B>Point Edit</B>: the Revolve object has no editable points, it does
not support single point modelling actions; however, read only points are
supported (the control points of the underlying NPatch object can be read
and selected).</LI>
</UL>
</P>



<H2><A NAME="ss4.1">4.1</A> <A HREF="ayam.html#toc4.1">Object Types Overview</A>
</H2>

<P>This section provides an overview on the object types available in
Ayam (since there are so many).
The object types are grouped by application in the following sections.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Scene Organization</H3>

<P>These objects help to organize/structure the scene; view, camera, light, and
material objects are also listed here (even though deserving an own
section each):</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Root</TD><TD>View<SUP>+</SUP></TD><TD>No</TD><TD>N/A</TD><TD>No</TD></TR><TR><TD>
Level</TD><TD>Any<SUP>+</SUP></TD><TD>Yes</TD><TD>N/A&thinsp;/&thinsp;Children<SUP>+</SUP></TD><TD>No</TD></TR><TR><TD>
Clone</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Children<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Mirror</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Children<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Instance</TD><TD>No</TD><TD>No</TD><TD>Master</TD><TD>No*</TD></TR><TR><TD>
Select</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>N/A&thinsp;/&thinsp;Children<SUP>+</SUP></TD><TD>No</TD></TR><TR><TD>
RiInc</TD><TD>Any</TD><TD>No</TD><TD>N/A</TD><TD>No</TD></TR><TR><TD>
RiProc</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>No</TD></TR><TR><TD>
View</TD><TD>NPatch</TD><TD>No</TD><TD>N/A</TD><TD>Yes</TD></TR><TR><TD>
Camera</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>Yes</TD></TR><TR><TD>
Light</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>Yes</TD></TR><TR><TD>
Material</TD><TD>No</TD><TD>N/A</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Scene Organization</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#orgobjs">Scene Organization Objects</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>CSG&thinsp;/&thinsp;Solid Primitives</H3>

<P>These objects serve as geometric primitives in CSG hierarchies:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Box</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>&lowast;</SUP></TD><TD>No*</TD></TR><TR><TD>
Sphere</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Disk</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
Cone</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Cylinder</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Torus</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Paraboloid</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Hyperboloid</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">CSG&thinsp;/&thinsp;Solid Primitives</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#solids">CSG&thinsp;/&thinsp;Solid Primitives</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Freeform Curves</H3>

<P>These objects are mainly used as child objects for the surface
generating tool objects:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
NCurve</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>Yes</TD></TR><TR><TD>
ICurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes</TD></TR><TR><TD>
ACurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes</TD></TR><TR><TD>
NCircle</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Freeform Curves</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#curves">Freeform Curve Objects</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Freeform Surfaces</H3>

<P>These objects enable direct manipulation of freeform surfaces:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
NPatch</TD><TD>NCurve<SUP>+</SUP>/&thinsp;Level<SUP>+</SUP></TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes</TD></TR><TR><TD>
IPatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes</TD></TR><TR><TD>
APatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes</TD></TR><TR><TD>
BPatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes</TD></TR><TR><TD>
PatchMesh</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Freeform Surfaces</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#surfaces">Freeform Surface Objects</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Curve Tool Objects</H3>

<P>These objects modify existing curves or create new curves:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ConcatNC</TD><TD>NCurve<SUP>+</SUP></TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
ExtrNC</TD><TD>NPatch</TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
OffsetNC</TD><TD>NCurve</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Curve Tool Objects</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#ctobjs">Curve Tool Objects</A>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Surface Tool Objects</H3>

<P>These objects create freeform surfaces from curves or other surfaces:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Revolve</TD><TD>NCurve</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Extrude</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Swing</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Sweep</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Birail1</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Birail2</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Skin</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Gordon</TD><TD>NCurve<SUP>&lowast;</SUP>/&thinsp;Level&thinsp;/&thinsp;NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Bevel</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
Cap</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
Text</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
Trim</TD><TD>NPatch&thinsp;/&thinsp;NCurve<SUP>+</SUP>/&thinsp;Level<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
ConcatNP</TD><TD>NPatch<SUP>&lowast;</SUP>/&thinsp;NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
ExtrNP</TD><TD>NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*</TD></TR><TR><TD>
OffsetNP</TD><TD>NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Surface Tool Objects</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#stobjs">Surface Tool Objects</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Polygonal and Subdivision Objects</H3>

<P>These objects complement the Ayam feature set and allow
objects modelled in the polygonal or subdivision modelling
paradigms to be included in Ayam scenes:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
PolyMesh</TD><TD>No</TD><TD>Yes</TD><TD>SDMesh</TD><TD>Yes</TD></TR><TR><TD>
SDMesh</TD><TD>No</TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Polygonal and Subdivision Objects</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#polys">Polygonal and Subdivision Objects</A>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3>Scripts and Plugins</H3>

<P>These objects create/modify arbitrary other objects
from scripts or define entirely new object types via the custom object
plugin mechanism.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Script</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Any</TD><TD>No*</TD></TR><TR><TD>
MetaObj</TD><TD>MetaComp<SUP>+</SUP></TD><TD>Yes</TD><TD>PolyMesh</TD><TD>No</TD></TR><TR><TD>
MetaComp</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>No</TD></TR><TR><TD>
SDNPatch</TD><TD>No</TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes</TD></TR><TR><TD>
SfCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
SDCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes</TD></TR><TR><TD>
BCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Scripts and Plugins</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="#scobjs">Script and Custom Objects</A>.</P>
<P>A number of Script objects scripts are already distributed with
Ayam:</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Helix</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
Spiral</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
TCone</TD><TD>No</TD><TD>No</TD><TD>Hyperboloid</TD><TD>No*</TD></TR><TR><TD>
CBox</TD><TD>No</TD><TD>No</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
TCircle</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*</TD></TR><TR><TD>
DualSweep</TD><TD>NCurve*</TD><TD>No</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
TSurf</TD><TD>NCurve*</TD><TD>No</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
ExtrudeN</TD><TD>NCurve</TD><TD>No</TD><TD>NPatch</TD><TD>No*</TD></TR><TR><TD>
Polyhedron</TD><TD>No</TD><TD>No</TD><TD>PolyMesh</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Distributed Script Object Scripts</FONT></CENTER><P><CENTER>
</CENTER>

For complete documentation, see
section 
<A HREF="ayam-6.html#scriptobjs">Distributed Script Objects</A>.</P>




<H2><A NAME="orgobjs"></A> <A NAME="ss4.2">4.2</A> <A HREF="ayam.html#toc4.2">Scene Organization Objects</A>
</H2>

<P>These objects help to organize/structure the scene; view, camera, light, and
material objects are also listed here (even though deserving an own
section each).</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="rootobj"></A> Root Object</H3>

<P>
<CENTER>
<IMG SRC="pics/root.gif" HEIGHT=121 WIDTH=152  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Root Object</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>There is always exactly one Root object in the scene.
This object is something special in that it can not be deleted
or copied.
The Root object holds rendering options global to the scene like RiOptions,
atmosphere and imager shaders. Furthermore, all currently open
view windows are represented as child objects of the Root object.</P>
<P>If the Root object is hidden, the little red/green/blue coordinate system
will not be drawn in any view.</P>
<P>The Root object also aids in per-scene window geometry management
using SaveMainGeom and SavePaneLayout tags (see also sections
<A HREF="#savemaingeomtag">SaveMainGeom</A> and
<A HREF="#savepanelayouttag">SavePaneLayout</A>).</P>
<P>The following table briefly lists some capabilities of the Root object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Root</TD><TD>View<SUP>+</SUP></TD><TD>No</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Root Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The global scene rendering options are documented in the following sections.</P>

<H4><A NAME="s3"></A> <A NAME="rioptionsprop"></A> <A NAME="rio"></A> RiOptions Property</H4>

<P>This property carries RenderMan Interface options.
Both, standard and BMRT specific options may be set using this
property. For the sake of brevity only a short description of
the available options will be given here.
Please refer to the documentation of the RenderMan Interface
and the documentation of BMRT for more detailed information about the
options.</P>
<P>The RiOptions property consists of the following elements:
<UL>
<LI><CODE>"Width"</CODE>, <CODE>"Height"</CODE>, if greater than zero this value
will be used for the image size instead of the corresponding
dimension of the view window, but only for real RIB export operations,
not for the QuickRender and not for the Render actions in view windows.
QuickRender and Render actions will always use the dimensions of the
view window instead.
</LI>
<LI><CODE>"StdDisplay"</CODE>, if this is enabled, a standard display
statement will be written to the RIB, which looks like this:

<BLOCKQUOTE><CODE>
<PRE>
Display "unnamed.tif" "file" "rgba"
</PRE>
</CODE></BLOCKQUOTE>


If this option is disabled, at least one RiDisplay tag should be
added to the Root object (see also section
<A HREF="#ridtag">RiDisplay Tag</A>), otherwise the exported RIB
will not contain a RiDisplay statement. This option has no effect on
RIBs created by the QuickRender and Render actions in view windows.
</LI>
<LI><CODE>"Variance"</CODE>, maximum allowed variance of two pixel values.
The default 0.0 causes no setting in the RIB. If the variance is > 0.0
no pixel samples setting will be written to the RIB. Various
sources discourage the use of variance based sampling, because
e.g.&nbsp;the number of samples actually taken (and therefore the rendering
time) might not easily be predicted anymore.
</LI>
<LI><CODE>"Samples_X"</CODE>, <CODE>"Samples_Y"</CODE> number of samples taken per
pixel.
</LI>
<LI><CODE>"FilterFunc"</CODE>, function used to filter final pixel values.
</LI>
<LI><CODE>"FilterWidth"</CODE>, <CODE>"FilterHeight"</CODE> size of the pixel filter.
</LI>
<LI><CODE>"ExpGain"</CODE>, Exposure
</LI>
<LI><CODE>"ExpGamma"</CODE>, Exposure Gamma
</LI>
<LI><CODE>"RGBA_ONE"</CODE>, <CODE>"RGBA_MIN"</CODE>, <CODE>"RGBA_MAX"</CODE>,
<CODE>"RGBA_Dither"</CODE>, specify quantisation and dithering
</LI>
<LI><CODE>"MinSamples"</CODE>, <CODE>"MaxSamples"</CODE>, minimum and maximum number
of samples per pixel (for variance based sampling).
</LI>
<LI><CODE>"MaxRayLevel"</CODE>, maximum number of recursive rays.
</LI>
<LI><CODE>"ShadowBias"</CODE>, minimum distance that one object has to
be in order to shadow another object.
</LI>
<LI><CODE>"PRManSpec"</CODE>, toggles behaviour of BMRT's specular() function
between PRMan compatible (default) and RI standard compatible.
</LI>
<LI><CODE>"RadSteps"</CODE>, number of radiosity steps, the default 0 leads
to no radiosity calculations to be performed.
</LI>
<LI><CODE>"PatchSamples"</CODE>, minimum number of samples per patch to
calculate the radiosity form factors for this patch.
</LI>
<LI><CODE>"Textures"</CODE>, <CODE>"Shaders"</CODE>, <CODE>"Archives"</CODE> and <CODE>"Procedurals"</CODE>
are search paths for the renderer.
</LI>
<LI><CODE>"TextureMem"</CODE> and <CODE>"GeomMem"</CODE> determine how much
memory rendrib (from BMRT) should use at maximum to cache textures and
tesselated geometry.</LI>
</UL>
</P>
<P>Renderer specific options may also be set with RiOption tags
(see section 
<A HREF="#riotag">RiOption Tag</A>), most comfortably
added via the main menu <CODE>"Special/Tags/Add RiOption"</CODE>
(see section 
<A HREF="ayam-2.html#mmtags">Tags Special Menu</A>).</P>

<H4><A NAME="s3"></A> <A NAME="imager"></A> Imager, Atmosphere Property</H4>

<P>The Imager and Atmosphere properties let you define shaders for the
Root object, please refer to section
<A HREF="#shd">Shader Properties</A>
for information on how to deal with shader property GUIs.</P>
<P>Imager shaders are executed once for every rendered pixel,
they may e.g.&nbsp;be used to set a specific background color
or backdrop image.</P>
<P>Atmosphere shaders are volume shaders that may be used to implement
global atmospheric optical effects like fog.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The Root object appears in RIB output in different places as collection
of RenderMan Interface options and imager as well as atmosphere shaders.</P>
<P>The exact RIB statements used depend on the configuration of the
object and the preference setting <CODE>"RIB-Export/RIStandard"</CODE>.</P>
<P>The Root object is the only object to support RiOptions, RiHider, and
RiDisplay tags (see also section
<A HREF="#tags">Tags</A>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="viewobj"></A> View Object</H3>

<P>Every view window (see also section
<A HREF="ayam-2.html#viewwin">Anatomy of a View</A>)
has a corresponding view object as a child object of the Root object.
Using the properties of the view object, camera settings, the type of the
view, and other things related to the view can be changed.
Note that deleting the object that represents a view, will not
close the view window. You will just lose a way to configure it.
Please, do not mess with the objects in other ways (e.g.&nbsp;copy them),
you are asking for trouble otherwise!</P>
<P>Each view is associated with a virtual camera.
The type of the view determines the default up-vector of that camera.
If the type is <CODE>"Top"</CODE> the up-vector corresponds to the world
Z-axis, else the world Y-axis.
The type of the view, additionally, determines the so called
<EM>input plane</EM> of the view. Interactive modelling actions in a view are
limited to that input plane (unless the view is switched to local modelling;
see also section
<A HREF="ayam-3.html#editlocal">Editing in Local Spaces</A>).<SMALL TITLE="Since 1.4."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The standard input planes are as following: Front &ndash; XY-plane,
Side &ndash; ZY-plane, Top &ndash; XZ-plane, Trim &ndash; XY-plane.</P>
<P>In perspective views no interactive modelling actions are possible,
but the camera may be modified, objects can be picked, and points selected.</P>
<P>Views of type <CODE>"Trim"</CODE> are used to edit trim curves of NPatch objects
only. They display those trim curves as normal NURBS curves when the
current level is inside a NPatch.
The extensions of the patch in parameter-space are also drawn as a
dashed rectangle.
The trim curves should completely lie inside this rectangle.
Note that picking of objects currently does not work in views of type
<CODE>"Trim"</CODE>.</P>
<P>The following table briefly lists some capabilities of the View object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
View</TD><TD>NPatch</TD><TD>No</TD><TD>N/A</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">View Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The next sections detail the properties of the view object.</P>

<H4><A NAME="s3"></A> <A NAME="cameraprop"></A> <A NAME="camp"></A> Camera Property</H4>

<P>This section describes all elements of the <CODE>"Camera"</CODE> property:
<UL>
<LI><CODE>"From"</CODE> is the point where the camera (that is attached
to the view) is situated.</LI>
<LI><CODE>"To"</CODE> is the point the camera is looking to.</LI>
<LI><CODE>"Up"</CODE> is the up-vector of the camera.</LI>
<LI><CODE>"Near"</CODE> defines the near clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Otherwise, near should always be positive for perspective views,
and smaller than far.</LI>
<LI><CODE>"Far"</CODE> defines the far clipping plane. A value of 0.0
means a default value (that depends on the type of the view) should
be used. Otherwise, far should always be bigger than near.</LI>
<LI><CODE>"Roll"</CODE> defines an angle by which the camera is rotated
around the axis that is defined by the points from and to.</LI>
<LI><CODE>"Zoom"</CODE> is a zoom factor.</LI>
</UL>
</P>
<P>Note that the up-vector is <EM>not</EM> checked for erroneous values
(e.g.&nbsp;pointing in the direction of from-to) when applying the changes
of the <CODE>"Camera"</CODE> property.</P>

<H4><A NAME="s3"></A> <A NAME="viewattrprop"></A> <A NAME="vat"></A> ViewAttrib Property</H4>

<P>This section describes the elements of the <CODE>"ViewAttrib"</CODE> property:
<UL>
<LI><CODE>"Type"</CODE> specifies the type of the view. Front, Side, Top (all
parallel), Perspective and Trim (again parallel) may be selected.</LI>
<LI><CODE>"Width"</CODE> and <CODE>"Height"</CODE> control the size of the view
window. It is currently not possible to resize internal views
with these elements.</LI>
<LI><CODE>"Redraw"</CODE> toggles automatic redrawing of the view.
If this is disabled, no drawing takes place in the view until an
explicit redraw is requested (using the view menu, or the shortcut
<CODE>&lt;Ctrl+d&gt;</CODE>).</LI>
<LI><CODE>"DrawingMode"</CODE> allows to specify the drawing mode of
the view: <CODE>"Draw"</CODE> draws a wire-frame, <CODE>"Shade"</CODE> draws lighted
surfaces. Note that the lighting is in no way an exact (or even similar)
representation of the light information as specified with Light objects
in the scene.
Instead, a single light source, located at the camera origin
(a headlight), will be used.
<CODE>"ShadeAndDraw"</CODE> combines surfaces and wire-frames.
<CODE>"HiddenWire"</CODE> shows hidden wire-frames and silhouettes.
See also section 
<A HREF="ayam-2.html#drawingmodes">Drawing Modes</A>.
</LI>
<LI><CODE>"DrawSel"</CODE> toggles drawing of selected objects. If this is
enabled, only the current selected objects will be drawn.</LI>
<LI><CODE>"DrawLevel"</CODE> toggles drawing of the objects of the current
level only. If this is enabled, only the objects of the current
level will be drawn.</LI>
<LI><CODE>"Grid"</CODE> is the grid size, 0.0 means no grid.</LI>
<LI><CODE>"DrawGrid"</CODE> toggles drawing of the current grid.</LI>
<LI><CODE>"UseGrid"</CODE> toggles, whether the current grid should be
used by the interactive modelling actions.
See also section 
<A HREF="ayam-3.html#iac">Modelling Actions</A>.
</LI>
<LI><CODE>"ModellingMode"</CODE> enables editing in local object spaces.
See also section 
<A HREF="ayam-3.html#editlocal">Editing in Local Spaces</A>.
</LI>
<LI><CODE>"DrawBG"</CODE> controls whether the background image (specified
by the <CODE>"BGImage"</CODE> option below) should be drawn. If a NPatch object
is present as child of the View object,
the image will be mapped onto this object instead of filling the
complete view window background.
</LI>
<LI><CODE>"BGImage"</CODE> is the name of a TIFF image file, that will
be used as texture for the background image. Ayam will read this image file
when the changes to the <CODE>"ViewAttrib"</CODE> property are applied,
but also reread the image file if the notification callback of the view
object is invoked (e.g.&nbsp;using the main menu entry
<CODE>"Tools/Force Notification"</CODE>).
</LI>
<LI><CODE>"Mark"</CODE> is the marked point (in world coordinates) for
the rotate and scale about modelling actions.
</LI>
<LI><CODE>"SetMark"</CODE> controls whether the data from the <CODE>"Mark"</CODE>
entries above should be used as new mark coordinates when the
changes to the <CODE>"ViewAttrib"</CODE> property are applied.
</LI>
<LI><CODE>"EnableUndo"</CODE> allows to control undo for the interactive
view actions, e.g.&nbsp;panning or zooming a view.
If this option is disabled, these actions will not be recorded in the
undo system and also do not change the scene changed state.<BR>
This option is switched on by default.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Drag and Drop Support</H4>

<P>View objects act in special ways, when certain objects are dropped
onto them in the tree view:</P>
<P>When a Camera object is dropped onto a View object, the camera settings
of the Camera object will be copied to the views camera.</P>
<P>When a Light object of type <CODE>"Spot"</CODE> is dropped onto a View object,
the views camera will be changed,
so that the user looks along the light to see what objects of the scene
are lit by the light object (this works best with perspective views
that have equal width and height).</P>
<P>It is also possible, to directly drag arbitrary objects from the
tree view to a view window: for geometric objects, the view then
performs a zoom to object operation, for cameras and light sources
the views camera will be changed as if the object was dropped
onto a View object in the tree view (see the above
description).<SMALL TITLE="Since 1.8."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cameraobj"></A> Camera Object</H3>

<P>Camera objects are used to temporarily save camera settings
of views.
Therefore, they has just have two properties
explained above, see sections 
<A HREF="#camp">Camera</A> and
<A HREF="#attrs">Attributes Property</A>.</P>
<P>The following table briefly lists some capabilities of the Camera object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Camera</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Camera Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>


<H4><A NAME="s3"></A> Drag and Drop Support</H4>

<P>When a View object is dropped onto a Camera object the camera settings
from the view will be copied to the Camera object.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Camera objects never appear in RIB output.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="lightobj"></A> Light Object</H3>

<P>
<CENTER>
<IMG SRC="pics/lights.gif" HEIGHT=296 WIDTH=478  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Lightsource Examples (l: Distant, m: Point, r: Spot)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Light objects represent light sources.</P>
<P>There are currently four different light types available in Ayam:
<CODE>"Point"</CODE>, <CODE>"Distant"</CODE>, <CODE>"Spot"</CODE>, and <CODE>"Custom"</CODE>
(see also the image above).</P>
<P>Point-, Distant-, and Spotlights:
<A NAME="pdsl"></A> </P>
<P>These standard light sources have well defined parameters that
will be displayed in the <CODE>"LightAttr"</CODE> property.
Please refer to the RenderMan documentation for more information
about these standard light sources (see section
<A HREF="ayam-8.html#secref">References</A>).</P>
<P>Custom Lights:
<A NAME="cul"></A> </P>
<P>Light sources of type <CODE>"Custom"</CODE> use the attached light shader.</P>
<P>Note that Ayam is trying to guess from the names of the light shader
arguments to draw the light.
The names <CODE>"from"</CODE> and <CODE>"to"</CODE> denote location and destination
of the light source. Those names should not be used for other things
in the light shaders.</P>
<P>In contrast to the light sources as defined in the RenderMan
interface, Ayam light sources are always global by default. This
means, regardless of the place of a light source in the scene
hierarchy, it will always light all other objects (unless the
<CODE>"IsLocal"</CODE> attribute is used).</P>
<P>Note that the effect of a light source can not be previewed in
shaded Ayam views, currently. However it is possible to estimate
the effect of a spot light source by simply dropping it into
a perspective view window; the view will then adapt the camera
attributes (from, to, and zoom) of the view to show the objects
lit by the spot.</P>
<P>The following table briefly lists some capabilities of the Light object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Light</TD><TD>Yes</TD><TD>No</TD><TD>N/A</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Light Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="lightattrprop"></A> <A NAME="lip"></A> LightAttr Property</H4>

<P>The parameter <CODE>"Type"</CODE> determines the type of the light source.<BR>
Depending on the type of the light source, the light attribute
property contains different sets of parameters. Parameters that
are not displayed will not be used on RIB export, consequently.
When the type of a light source is changed, the property GUI will
be adapted to show only the options available for the new light
source type. Note that this adaptation happens when the <CODE>"Apply"</CODE>-button
is used.</P>
<P><CODE>"IsOn"</CODE> allows you to switch the light off or on. The default
value is on.</P>
<P><CODE>"IsLocal"</CODE> controls whether the light source should light
just local objects (objects, that are defined in the same level
in the scene hierarchy as the light source object or below it) or
all objects in the scene.
The default is off, all objects in the scene are lit.
The <CODE>"IsLocal"</CODE> attribute is ignored for lights that are
defined in the root level of the scene. Mind also that shadow maps
will always contain shadows from all objects in the scene,
regardless of the <CODE>"IsLocal"</CODE> attribute of the light source.</P>
<P>Using the light attribute <CODE>"Shadows"</CODE> you may determine
whether the light source should cast shadows.
The default is off, no shadows. Note that this option will not
magically enable shadows on renderers that create shadows by
shadow maps. It will merely be interpreted by raytracing
renderers like BMRT.</P>
<P>The parameter <CODE>"Samples"</CODE> determines the number of times to sample
an area light source, independent of pixel samples, the default value
is 1. This attribute is available for custom lights only.</P>
<P><CODE>"UseSM"</CODE> determines, whether shadow maps should be created
and used for this light source. The resolution of the
shadow map may be determined by the attribute <CODE>"SMRes"</CODE>. If
<CODE>"SMRes"</CODE> is 0, a default of 256 by 256 pixels will be used.
These options are for renderers that do not support raytraced
shadows like PRMan or Aqsis only.</P>
<P>For lights of type <CODE>"Distant"</CODE> the <CODE>"Scale"</CODE> attributes
of the <CODE>"Transformations"</CODE> property of the light
object may be used to scale the camera transformation
used for the creation of the corresponding shadow map.
Values of 1 for <CODE>"Scale_X"</CODE> and <CODE>"Scale_Y"</CODE> create
a shadow map that is sized 1 by 1 units in world space.</P>
<P>All other parameters that may appear in the <CODE>"LightAttr"</CODE>
property are the standard parameters for the standard RenderMan
light sources: distant, point, and spot:
<UL>
<LI><CODE>"From"</CODE> and <CODE>"To"</CODE> denote position and target of the light
source as point in space. You may edit both points using standard
point editing actions (see also section
<A HREF="ayam-3.html#iac">Modelling Actions</A>).</LI>
<LI><CODE>"Color"</CODE> is the color of the light emitted by the light source.</LI>
<LI><CODE>"Intensity"</CODE> is the intensity of the light emitted by the
light source. Note that the standard point and spot lights have
a quadratic falloff (with distance), that requires the intensity
to be set to quite high values in order to achieve some
illumination effect (e.g.&nbsp;around 30 for the standard distance of
<CODE>"From"</CODE> and <CODE>"To"</CODE> of a spot light).</LI>
<LI><CODE>"ConeAngle"</CODE> is the angle of the beam of a spot light.</LI>
<LI><CODE>"ConeDAngle"</CODE> (cone delta angle) is the angle that determines a
falloff area at the edge of the beam of a spot light.</LI>
<LI><CODE>"BeamDistrib"</CODE> (beam distribution) determines, how the light
falls off in the beam of the spot light. Larger values result in narrower
lit areas.</LI>
</UL>
</P>
<P>In order to ease the parameterisation of spot lights, the light source
object may be dropped onto a view object or into a view window
(preferably one with a perspective viewing transformation and with equal
width and height) to see what objects of the scene are actually lit
by the light object.</P>

<H4><A NAME="s3"></A> <A NAME="shadowmaps"></A> Using ShadowMaps</H4>

<P>Using shadow maps requires the global preference setting
<CODE>"RIB-Export/ShadowMaps"</CODE> to be switched on.
Furthermore, for each light source for which a shadow map should be
created, the attributes <CODE>"IsOn"</CODE> and <CODE>"UseSM"</CODE> have to be
switched on.</P>
<P><B>Automatic Creation of ShadowMaps</B></P>
<P>If the preference setting <CODE>"RIB-Export/ShadowMaps"</CODE> is set to
<CODE>"Automatic"</CODE>,
Ayam will create a special version of the RIB on export, that creates
all shadow maps automatically upon rendering. This is done by rendering
depth images from the position of every light source that casts shadows.
Special light source shaders later pick up these depth images
and calculate shadows.
This approach implies, that the scene is rendered multiple times.
To reduce the size of the RIB, the objects to be rendered
are written to a second RIB file named <CODE>"&lt;scene&gt;.obj.rib"</CODE>.
This file is read from the main RIB several times via
<CODE>"ReadArchive"</CODE>. The RIB contains multiple frames which may
also be rendered separately if the frame number is known.
To help picking the right frame number for the image
(e.g.&nbsp;to re-render just the final image, when only a material setting was
changed, and no shadow casting lights were moved and no shadow casting
geometry was changed),
a comment with the frame number of the last frame (the image) will be
written as last statement to the RIB.</P>
<P>Because multiple files (RIBs and shadow maps) are used, it is suggested
to change the preference setting <CODE>"RIB-Export/RIBFile"</CODE> to
<CODE>"Scenefile"</CODE>. This will strip the leading absolute path component
from the filenames so that the exported scene may be moved from one
system to another more easily.</P>
<P>Do not render directly from a view window to the display when the
<CODE>"ShadowMaps"</CODE> <CODE>"RIB-Export"</CODE> preference option is set to
<CODE>"Automatic"</CODE>.
Your renderer may not write image files when the command line option
to render directly to the display (-d for rendrib, or -fb for Aqsis) is
in use. Consequently, this may also inhibit writing of the shadow maps,
so that the resulting image will look wrong, or the renderer will only
render the shadow map to the display and then simply stop.</P>
<P><B>Manual Creation of ShadowMaps</B></P>
<P>If the preference setting <CODE>"RIB-Export/ShadowMaps"</CODE> is set to
<CODE>"Manual"</CODE>,
the exported scene will not render the shadow maps but rather
expects them to be present already. They can be created manually
(hence the name <CODE>"Manual"</CODE>) using the view menu entries
<CODE>"View/Create ShadowMap"</CODE>, <CODE>"View/Create All ShadowMaps"</CODE>
or the main menu entries
<CODE>"Special/RIB-Export/Create ShadowMap"</CODE>,
<CODE>"Special/RIB-Export/Create All ShadowMaps"</CODE>.
The manual approach has the advantage, that the shadow maps will not
be re-created each time the scene is rendered.</P>
<P><B>ShadowMap Types</B></P>
<P>Ayam supports three different methods for the creation of shadow maps
for certain types of light sources: point, distant, and spot:</P>
<P>The point method is used with
lights of type <CODE>"Point"</CODE> and custom lights that have a light
shader argument named "from".
Six shadow maps pointing in all possible axis aligned
directions and named <CODE>"&lt;rib&gt;.point&lt;num&gt;_&lt;dir&gt;.shd"</CODE>
(where <CODE>"&lt;rib&gt;"</CODE> is the name of the RIB,
<CODE>"&lt;num&gt;"</CODE> is the number of the light source that makes
use of shadow maps and <CODE>"&lt;dir&gt;"</CODE> is one of
<CODE>"x+"</CODE>, <CODE>"x-"</CODE>, <CODE>"y+"</CODE>, <CODE>"y-"</CODE>, <CODE>"z+"</CODE>, or <CODE>"z-"</CODE>)
will be created.</P>
<P>The distant method is used with lights of type <CODE>"Distant"</CODE>
and custom lights that have a light
shader argument named "from" and a light
shader argument named "to".
One shadow map is created and named
<CODE>"&lt;rib&gt;.dist&lt;num&gt;.shd"</CODE>.
By default, the size of the shadow map is 1 by 1 units in world space,
but this may be adapted using the scale transformation attributes of
the light object.</P>
<P>The spot method is used with lights of type <CODE>"Spot"</CODE>
and custom lights that have a light
shader argument named "from", a light
shader argument named "to", and a light shader argument named "coneangle".
One shadow map is created and named
<CODE>"&lt;rib&gt;.spot&lt;num&gt;.shd"</CODE>.
The spot method uses the cone angle (and additionally the delta cone
angle, if present) argument to determine the size of the shadow map
in world space.</P>
<P>If a light object of type <CODE>"Spot"</CODE>, <CODE>"Distant"</CODE> or
<CODE>"Point"</CODE> is used, Ayam automatically changes the name of the
exported light shader to <CODE>"shadowspot"</CODE>, <CODE>"shadowdistant"</CODE>,
and <CODE>"shadowpoint"</CODE> respectively. Additionally, the shader
will be parameterised to use the created shadow maps.
If the light source is of type <CODE>"Custom"</CODE>, no automatic renaming
and adjusting of the shader takes place. This means, you have
to make sure that the shader really uses the shadow maps, by
selecting the right shader and parameterising it accordingly.
See the discussion above for the names of the shadow map files.
Those file names, most probably, will have to be entered as parameter
to the light shader.</P>
<P>For example, you will not get any shadows if you use a light source of
type <CODE>"Custom"</CODE> with the normal <CODE>"distantlight"</CODE> shader attached,
even though Ayam is able to create the necessary shadow maps. The
normal <CODE>"distantlight"</CODE> shader just makes no use of the shadow maps.
You have to manually switch to a shader that
makes use of the shadow maps (<CODE>"shadowdistant"</CODE> in this case) to
actually get shadows.</P>

<P><B>ShadowMap Mini Tutorial</B></P>
<P>Here is a short example for a scene using a shadow map:
<OL>
<LI>Go to the preferences (section <CODE>"RIB-Export"</CODE>) and set
<CODE>"ShadowMaps"</CODE> to <CODE>"Automatic"</CODE>.</LI>
<LI>Create two boxes.</LI>
<LI>Open the <CODE>"Transformations"</CODE> property of the second box.</LI>
<LI>Translate it by X: 0.0, Y: -1.0, Z: 0.0.</LI>
<LI>Scale it by X: 4.0, Y: 1.0, Z: 4.0.</LI>
<LI>Create a light source.</LI>
<LI>Open the <CODE>"LightAttr"</CODE> property.</LI>
<LI>Change the type to <CODE>"Spot"</CODE>. Press <CODE>"Apply"</CODE>.</LI>
<LI>Now change the parameters of the spot light to <CODE>"IsOn"</CODE>: Yes,
<CODE>"Intensity"</CODE>: 18.0,
<CODE>"UseSM"</CODE>: Yes, <CODE>"ConeAngle"</CODE>: 45.0, <CODE>"BeamDistrib"</CODE>: 3.0,
<CODE>"From"</CODE>: -2, 2, 2, <CODE>"To"</CODE>: 1, 0, -1;
leave all other parameters at their default values.</LI>
<LI>Create a new view and make it perspective (Menu:
<CODE>"Type/Perspective"</CODE>).</LI>
<LI>Export a RIB from that perspective view (Menu:
<CODE>"View/Export RIB"</CODE>).</LI>
<LI>Render the RIB with a RenderMan compliant renderer, that uses
shadow maps, e.g.&nbsp;Photorealistic RenderMan (prman) or Aqsis.</LI>
</OL>
</P>
<P>This scene is distributed with Ayam as an example scene named
<CODE>"shadowmaps.ay"</CODE>, see also the following image from that scene
that was created with an additional point light and Aqsis as renderer:</P>
<P>
<CENTER>
<IMG SRC="pics/shadowmaps.gif" HEIGHT=200 WIDTH=300  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Shadowmaps Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Note that for Aqsis you should add a RiHider hidden,depthfilter,s,midpoint
tag to your Root object if shadow maps are in use. Other renderers might
require additional tweaking using shadow bias RiOption tags.
Please consult the documentation of your renderer on how to achieve
the best results using shadow maps.</P>


<H4><A NAME="s3"></A> <A NAME="alob"></A> Using Area Lights</H4>


<P>The common idealized standard light sources <CODE>"Point"</CODE>, <CODE>"Distant"</CODE>
and <CODE>"Spot"</CODE> have no own geometric extension in space.
This means, shadows resulting from such light sources will have sharp
borders which does not look too natural.
Good looking soft shadows may be generated using area lights.
See also the image below.</P>
<P>Area lights may be created by simply placing a single object as child
object of a <CODE>"Custom"</CODE> light object that has the <CODE>"arealight"</CODE>
shader attached, i.e.&nbsp;the scene hierarchy looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-AreaLight(Light)
 \ AreaLightGeometry(Sphere)
</PRE>
</CODE></BLOCKQUOTE>

This child object determines the geometry (place <EM>and</EM> extension)
of the light source.
According to L. Gritz, Spheres and Cylinders work best as area light
geometry for BMRT, because of special sampling code.</P>
<P>An example:
<UL>
<LI>Create a custom light object.</LI>
<LI>Assign the <CODE>"arealight"</CODE> light shader to it.</LI>
<LI>Create a sphere.</LI>
<LI>Drag and drop the sphere onto the light object so that it becomes
a child of the light object.</LI>
<LI>Transform the sphere object to your hearts content; the position
and size of the object determines the position and size of the light
source.</LI>
</UL>
</P>
<P>There is an example scene named <CODE>"arealight.ay"</CODE> distributed with
Ayam, see also the following images from that scene that
were created with BMRT 2.6 as renderer:</P>









<P>
<CENTER>
<IMG SRC="pics/arealight.gif" HEIGHT=108 WIDTH=149  loading="lazy">
&emsp;
<IMG SRC="pics/pointlight.gif" HEIGHT=108 WIDTH=149  loading="lazy">

</CENTER><P><CENTER><FONT SIZE="-1">Area Light (l) and Point Light (r)</FONT></CENTER><P><CENTER>
</CENTER>
</P>




<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="materialobj"></A> Material Object</H3>

<P>
<CENTER>
<IMG SRC="pics/materials.gif" HEIGHT=283 WIDTH=451  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Material Examples (l: wood, m: ceramic, r: veined marble)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Material objects are used to attach RenderMan attributes and shaders to
geometric objects. See also the image above that was rendered with
BMRT 2.6 and uses materials with the following shaders, which are
distributed with the renderer: wood2, ceramic, veinedmarble.</P>
<P>As long as geometric objects are connected to a material object,
this material object may not be deleted.</P>
<P>The following table briefly lists some capabilities of the Material object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Material</TD><TD>No</TD><TD>N/A</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Material Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="riattributesprop"></A> <A NAME="riattrs"></A> RiAttributes Property</H4>

<P>Using this property standard and BMRT specific RenderMan attributes may be set.
Please refer to the documentation of the RenderMan interface
and the documentation of BMRT for more detailed information about the
RenderMan specific attributes.</P>
<P>
<UL>
<LI><CODE>"Color"</CODE>, the color of the object. If one of the entries is set
to a negative value (e.g.&nbsp;-1), the color will not be set at all
for this object, i.e.&nbsp;no RiColor call will be emitted upon export.</LI>
<LI><CODE>"Opacity"</CODE>, the opacity of the object, the default
(255 255 255) means the object is totally opaque. If one of the entries is
set to a negative value (e.g.&nbsp;-1), the opacity will not be set at all
for this object, i.e.&nbsp;no RiOpacity call will be emitted upon export.</LI>
<LI><CODE>"ShadingRate"</CODE>, determines how often shaders are evaluated for
a sample.</LI>
<LI><CODE>"Interpolation"</CODE>, determines how return values computed
by the shaders are interpolated across a geometric primitive.</LI>
<LI><CODE>"Sides"</CODE>, determines how many sides of the surface of a
geometric primitive should be shaded.</LI>
<LI><CODE>"BoundCoord"</CODE>, sets the coordinate system in which the
displacement bound is expressed.</LI>
<LI><CODE>"BoundVal"</CODE>, displacement bound value.</LI>
<LI><CODE>"TrueDisp"</CODE>, toggles true displacements on or off. Default off.</LI>
<LI><CODE>"CastShadows"</CODE>, determines how the object casts shadows:
the default <CODE>"Os"</CODE> means the object casts shadows according to it's
opacity; <CODE>"None"</CODE> object does not cast any shadows; <CODE>"Opaque"</CODE>
the object is completely opaque and casts shadows; <CODE>"Shade"</CODE>
the object has a complex opacity pattern determined by it's surface
shader, that is used in shadow calculations.</LI>
<LI><CODE>"Camera"</CODE>, <CODE>"Reflection"</CODE>, and <CODE>"Shadow"</CODE> toggle
visibility attributes.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> <A NAME="matshader"></A> Surface, Displacement, Interior, Exterior Property</H4>

<P>These properties let you define shaders for the material object, please
refer to section 
<A HREF="#shd">Shader Properties</A>
for information on how to deal with shader property GUIs.</P>
<P>Surface shaders may be used to procedurally encode lighting models and
textures. Displacement shaders may procedurally deform the object while
rendering. Interior and Exterior shaders are so called volume shaders
that may be used to capture special optical effects, encoding how light
is affected while passing through an object.</P>

<H4><A NAME="s3"></A> <A NAME="materialattrprop"></A> <A NAME="matattr"></A> MaterialAttr Property</H4>

<P>The MaterialAttr property contains attributes related to the
management of material objects:
<UL>
<LI><CODE>"Materialname"</CODE> denotes the name of the material. Note
that material names have to be unique in a scene. If two
materials with the same name exist, only the first material
created with this name is "registered" and thus may be connected
to geometric objects.</LI>
<LI><CODE>"Refcount"</CODE> shows how many geometric objects are connected to
(are of) this material. Note that connected or referring geometric objects
not necessarily have to live in the scene, they may as well temporarily
reside in the object clipboard.</LI>
<LI><CODE>"Registered"</CODE> displays whether this material may be
connected to geometric objects, see the discussion about material names above.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Drag and Drop Support</H4>

<P>When geometric objects are dropped onto a material object
they will be connected to this material object.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Material objects only appear in RIB output if connected to a
geometric object (e.g.&nbsp;a Box).</P>
<P>The exact RIB statements used depend on the configuration of the
material and the preference setting <CODE>"RIB-Export/RIStandard"</CODE>.</P>
<P>If all elements of the MaterialAttr property are left on their default
values, only color and opacity will be written to the RIB:
<BLOCKQUOTE><CODE>
<CODE>RiColor(...);<BR>
RiOpacity(...);</CODE>
</CODE></BLOCKQUOTE>

After the elements of the MaterialAttr property, the surface, displacement,
interior, and exterior shaders (if attached to the material) will
be exported, all shader parameters will be properly declared:
<BLOCKQUOTE><CODE>
<CODE>RiDeclare("Ka", "float");<BR>
...<BR>
RiSurface("Ka", 0.9, ...);<BR>
...</CODE>
</CODE></BLOCKQUOTE>

After the material description custom RiAttributes and texture
coordinates from tags will be exported.</P>
<P>No attempt is being made to re-order or sort objects in a level according
to their attached materials, they will rather be exported in the order of
their appearance in the level and thus each object with a material
will also be prepended by a full material specification as described
above.</P>
<P>Here is a complete example of a material description with the
wood2 surface shader applied to a sphere:
<BLOCKQUOTE><CODE>
<PRE>
...
Color 0.862745 0.862745 0.862745
Opacity 1 1 1
Declare "Ka" "float"
Declare "Kd" "float"
Declare "Ks" "float"
Declare "roughness" "float"
Declare "ringscale" "float"
Declare "txtscale" "float"
Declare "lightwood" "color"
Declare "darkwood" "color"
Declare "grainy" "float"
Surface "wood2" "Ka" [1] "Kd" [0.75] "Ks" [0.4] "roughness" [0.1]
"ringscale" [15] "txtscale" [1] "lightwood" [0.686275 0.439216 0.247059]
"darkwood" [0.34902 0.219608 0.0784314] "grainy" [1]
Sphere 1 -1 1 360
...
</PRE>
</CODE></BLOCKQUOTE>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="levelobj"></A> Level Object</H3>

<P>Level objects may be used to build object hierarchies and perform CSG
operations.</P>
<P>Ayam does not offer a layer concept, but by grouping objects using
levels and the hide/show tools, layer functionality
may be emulated to a certain extent.</P>
<P>Organizing the scene and working in levels also increases the speed
of object tree updates, as only the current level and its sub-levels
are subject to a tree update if something in the object hierarchy changes.</P>
<P>Note that child objects of a level inherit the levels transformations,
material, attributes, and shaders. Inheritance of e.g.&nbsp;transformations
means:<BR>
If you have a NURBS patch in a level that is translated to (10,0,0),
the origin of the local coordinate system of the NURBS patch
will be situated at (10,0,0). If you decide to move the patch by a
value of 5 in X direction by setting a corresponding value in the
Transformations property of the patch object, the local coordinate
system of the patch will be placed at (15,0,0) in world coordinates,
i.e.&nbsp;the control point (1,0,0) will be at (16,0,0).</P>
<P>Note also that since Ayam 1.12, Level objects provide their child
objects to their parent objects as a list. This means the following
hierarchy is now valid:
<BLOCKQUOTE><CODE>
<PRE>
+-Skin
  +-Level
    |-NCurve
    |-NCurve
    |-ICurve
    \-NCurve
</PRE>
</CODE></BLOCKQUOTE>

All NURBS curves and objects that may be converted to NURBS curves
(in this example: the ICurve) will be provided to the Skin by the
Level object. Transformation attributes of the Level will be added
to the provided objects. Objects that do not provide the wanted
type will be silently ignored.</P>
<P>The following table briefly lists some capabilities of the Level object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Level</TD><TD>Any<SUP>+</SUP></TD><TD>Yes</TD><TD>N/A&thinsp;/&thinsp;Children<SUP>+</SUP></TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Level Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="levelattrprop"></A> <A NAME="lep"></A> LevelAttr Property</H4>

<P>Levels do not have many object type specific properties, you may just
modify the type of the level using the attribute <CODE>"Type"</CODE>.</P>
<P>Levels of type <CODE>"Level"</CODE> just group objects and inherit attributes.</P>
<P>Levels of type <CODE>"Union"</CODE>, <CODE>"Intersection"</CODE>, and <CODE>"Difference"</CODE>
are used to build CSG hierarchies. Additionally, they inherit attributes.
Note that Ayam is currently not able to correctly display the results
of CSG operations, all objects are always drawn completely, even though
a CSG operation would cut parts away.</P>
<P>However, since Ayam 1.8 there is a plugin available that is able to
preview the results of CSG operations, see also section
<A HREF="ayam-8.html#aycsg">CSG preview using the AyCSG plugin</A>.</P>
<P>The object hierarchy to cut away a part of a box using a sphere
looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Level_of_Type_Difference(Level)
  |-Box
  \-Sphere
</PRE>
</CODE></BLOCKQUOTE>

More than two objects may be arguments of a CSG operation:
<BLOCKQUOTE><CODE>
<PRE>
+-Level_of_Type_Difference(Level)
  |-Box
  |-Sphere
  \-Sphere
</PRE>
</CODE></BLOCKQUOTE>

In this example, the two spheres would cut away parts of the box.</P>
<P>New solid primitives may be created with levels of type <CODE>"Primitive"</CODE>.
<BLOCKQUOTE><CODE>
<PRE>
+-Level_of_Type_Difference(Level)
  +-Level_of_Type_Primitive(Level)
  | |-Sphere_blue
  | \-Disk_red
  \-Box_grey
</PRE>
</CODE></BLOCKQUOTE>

In this example an open sphere with <CODE>"ThetaMax"</CODE> 180.0 (a hemisphere)
is manually capped by a disk object. The two objects need to be placed
into a level of type <CODE>"Primitive"</CODE> because each object alone is an
open surface and therefore not a valid CSG primitive. Both objects that
form the new primitive use a different material. In addition, a grey box
cuts away a part from the multi colored hemisphere.
The above CSG hierarchy is available as example scene file
<CODE>"multicolcsg.ay"</CODE>.</P>
<P>See also this image:</P>
<P>
<CENTER>
<IMG SRC="pics/multicolcsg.gif" HEIGHT=140 WIDTH=190  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Multicolor CSG Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Note that Ayam is not able to check, whether your new primitive obeys
the rule of total closeness. For instance, if the disk in the above
example would not totally cap the sphere (this happens if the disk
<CODE>"ThetaMax"</CODE> is not 360.0 or if it is not placed exactly at the
sphere) Ayam would not complain upon RIB export.
The rendered image would expose serious errors, however.</P>
<P>Furthermore, it is not necessary to enclose normal child objects
(e.g.&nbsp;quadrics with the <CODE>"Closed"</CODE> attribute set to on) of
CSG levels in primitive levels for RIB export. This is done by Ayam
automatically where needed.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The exact representation of a Level in RIB output depends on
its type.</P>
<P>Normal Level objects appear in RIB output as Transformation
hierarchies:
<BLOCKQUOTE><CODE>
<CODE>RiTransformBegin();<BR>
RiTranslate(...);<BR>
RiRotate(...);<BR>
RiScale(...);<BR><BR>
&laquo;Children RIB output&raquo;<BR><BR>
RiTransformEnd();</CODE>
</CODE></BLOCKQUOTE>
</P>

<P>Level objects of type Union, Difference, or Intersection will
additionally emit a call to SolidBegin, and each child will
be properly declared as primitive, e.g.:
<BLOCKQUOTE><CODE>
<CODE>RiTransformBegin();<BR>
&laquo;Level Transformations&raquo;<BR>
RiSolidBegin(RI_DIFFERENCE);<BR><BR>
RiSolidBegin(RI_PRIMITIVE);<BR>
&laquo;Child #1 RIB output&raquo;<BR>
RiSolidEnd();<BR><BR>
RiSolidBegin(RI_PRIMITIVE);<BR>
&laquo;Child #2 RIB output&raquo;<BR>
RiSolidEnd();<BR><BR>
RiSolidEnd();<BR>
RiTransformEnd();</CODE>
</CODE></BLOCKQUOTE>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="instanceobj"></A> Instance Object</H3>

<P>
<CENTER>
<IMG SRC="pics/instances.gif" HEIGHT=260 WIDTH=494  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Instancing Example</FONT></CENTER><P><CENTER>
</CENTER>

Instance objects are transformed lightweight copies of single or
groups of objects
and can therefore help to save memory consumption in scenes with many
similar or repeating objects. See also the image above, where there is
only one set of patches stored for the three elephants.
The amount of saved space can be very high, depending heavily on the
actual scene and at what levels in the hierarchy instances are used.
If there are no similar objects in the scene, however, instancing
can hardly be utilised. Similar means "the same except for
the transformation property" in this context.</P>
<P>The term instance is unfortunately misleading (and can be very confusing
if you are accustomed to the terminology of object oriented programming),
but it is the term that seems to be used and understood by most
computer graphic artists for this mechanism. A better term would be <EM>link</EM>,
as an instance object has the same basic properties as a link in a Unix
file system.
A link is just a pointer to an original file, the same goes for
an instance object: it is just a pointer to an original object (here
also called master object).
A link can be placed anywhere on the file system,
an instance object can be placed anywhere in the scene hierarchy, and
additionally, it can be transformed.</P>
<P>While the original purpose of instances is to save memory, in the tool
object context instances also serve as a means to transport geometric
data across the scene
hierarchy to make tool objects depend on each other (see also section
<A HREF="ayam-8.html#toolobj">The Modelling Concept Tool-Objects</A>).
Note that in the tool object context, instance objects are the only
objects, that are subject to a second round of provision.</P>
<P>Some simple rules for instancing:</P>
<P>
<UL>
<LI>No instances may be created of objects of the following types:
Root, View, Instance, Material, Light. Do not try to fool
Ayam and create instances of levels that contain aforementioned
types of objects, things will go awry!</LI>
<LI>It is allowed, however, to put some instances
into a level object and create instances of this level
(this is sometimes called <EM>hierarchical instancing</EM>).</LI>
<LI>But instances of a level may not be put into the very same
level or one of its children (this would be <EM>recursive instancing</EM>,
which is not supported by Ayam).</LI>
<LI>The original/master object may not be deleted from
the scene as long as there are instances of that object in the scene or
in the object clipboard.</LI>
</UL>
</P>


<P>If deleting of an object fails, and the error message
complains about the reference counter not being zero, then
the last rule was about to be violated. Clean the clipboard using
the menu <CODE>"Special/Clipboard/Paste (Move)"</CODE> and delete
or resolve all references first.</P>
<P>Ayam can also create instances for complete scenes automatically
(see section 
<A HREF="ayam-8.html#ai">Automatic Instancing</A>).</P>
<P>To easily find the master object of an instance, just select the
instance, then use the main menu entry: <CODE>"Edit/Master"</CODE>.</P>
<P>The following table briefly lists some capabilities of the Instance object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Instance</TD><TD>No</TD><TD>No</TD><TD>Master</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Instance Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="referencing"></A> Instances without Transformations (References)</H4>

<P>Instance objects support the <CODE>"RP"</CODE> tag type
in a special way:
if the <CODE>"Transformations"</CODE> property is removed using a
<CODE>"RP"</CODE> tag, the instance does not provide objects with
an own set of transformation attributes (to ease hierarchy building
with e.g.&nbsp;<CODE>"ExtrNC"</CODE>/<CODE>"ExtrNP"</CODE> objects, where only
pointers to already existing objects are required and where it is
expected, that the instance reflects the master exactly, including
its transformation attributes).<SMALL TITLE="Since 1.16."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The extract curve/surface tools automatically add such a tag to the
instances they create.</P>
<P>To create such a tag manually, select the Instance object and enter
into the Ayam console:
<BLOCKQUOTE><CODE>
<CODE>&raquo;&thinsp;addTag RP Transformations</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>This special case of an instance is sometimes also called <EM>reference</EM>.</P>

<H4><A NAME="s3"></A> <A NAME="instclip"></A> Instances and the Object Clipboard</H4>

<P>This section contains additional information on instances and
what happens to them when they are copied and pasted using the object
clipboard.</P>
<P>All copies of instance objects, that are created by the object clipboard,
always point to the same original master object.
Therefore, it is not possible to copy a master object and some instances
of it, so that the new instances point to the newly created master.</P>
<P>For example, when the following two objects are copied and pasted back to the
scene
<BLOCKQUOTE><CODE>
<PRE>
|-NCurve   &lt;-----.
|                |
|-Instance  -----'
</PRE>
</CODE></BLOCKQUOTE>
</P>


<P>the following scene hierarchy results:
<BLOCKQUOTE><CODE>
<PRE>
|-NCurve   &lt;-----+-.
|                | |
|-Instance  -----' |
|                  | !
|-NCurve           |
|                  |
|-Instance  -------'
</PRE>
</CODE></BLOCKQUOTE>

The new instance still points to the original master and <EM>not</EM>
to the copy of the master.</P>
<P>Nevertheless, it is possible to move complete sets of masters and their
instances through the scene hierarchy using drag and drop in the tree view or
using the object clipboard with
<CODE>"Edit/Cut"</CODE> and then <CODE>"Special/Clipboard/Paste (Move)"</CODE>.</P>


<H4><A NAME="s3"></A> Conversion Support</H4>

<P>An Instance object may be converted to an ordinary object using the
main menu entry <CODE>"Tools/Convert"</CODE>.
This process is also called resolving the instance.</P>
<P>To resolve all instance objects in a scene
to normal objects, also the main menu entry:
<CODE>"Special/Instances/Resolve all Instances"</CODE> can be used.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The RIB export of instances does <EM>not</EM> use the RiInstance facility
of the RenderMan interface, but rather the more flexible ReadArchive
mechanism.</P>
<P>This means, every master object in the scene will be written
in a separate archive (RIB file) on disk, and every instance will
cause that archive file to be read when rendering the RIB file.
The resulting RIB file is not self contained: multiple files
need to be transferred to other systems when rendering shall occur
there.</P>
<P>This behaviour can be changed using the RIB export preference setting
<CODE>"ResInstances"</CODE>: If this option is enabled, all instances
will be resolved temporarily to normal objects before being exported
to RIB. The resulting RIB file will then be self contained but probably
also much larger.</P>


<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cloneobj"></A> Clone Object</H3>

<P>
<CENTER>
<IMG SRC="pics/clone.gif" HEIGHT=250 WIDTH=268  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Clone Object (blue) with Trajectory Curve (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Clone object allows to easily create and control an arbitrary
number of instances of a single object, hereafter called the cloned
object.
The instances can be transformed (each by a certain amount expressed
as difference between two instances) or placed on a trajectory curve
(see also the image above).</P>
<P>If a second object is present as child of the Clone object it is treated
as trajectory (or path) curve automatically.
The process of placing the clones on the trajectory is very similar
to the sweeping operation
(see also section 
<A HREF="#sweepobj">Sweep Object</A>).</P>
<P>Thus, the default object hierarchy of a Clone object looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Clone
  |-Cloned-Object
  \-[Trajectory(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>

If you use a trajectory curve to place the clones, you may want
to hide the cloned object and also add a <CODE>"NoExport"</CODE> tag to it.
Otherwise the original object will appear twice, on the trajectory and
on its normal, untransformed, position. Note that the transformation
attributes of the cloned object will be completely overwritten when
placing the clones on the trajectory curve. If the cloned object has
distinct scale or rotation attributes it should be put inside a level
object like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Clone
  +-Level
  | \-Cloned-Object with non-standard Scale/Rotation
  \-Trajectory(NCurve)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>It is not possible to create clones from objects that may not
be master objects of instance objects, e.g.&nbsp;it is not possible
to clone light objects or material objects. However, (since Ayam 1.7)
it is possible to use instances as parameter objects.</P>
<P>If an instance object is used as cloned object on a trajectory
it can be placed in a level and the <CODE>"NoExport"</CODE> tag can
be added to the level object (as adding tags to Instance objects is
more involved), see the following hierarchy for an example:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
+-Clone
  +-Level with NoExport tag
  | \-Instance
  \-Trajectory(NCurve)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Since Ayam 1.20 the mirror facility of the Clone object is realized
through the new Mirror object (see also
section 
<A HREF="#mirrorobj">Mirror Object</A>).
The mirror facility was integrated into the Clone object before.</P>
<P>The following table briefly lists some capabilities of the Clone object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Clone</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Children<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Clone Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="cloneattrprop"></A> <A NAME="cloneattr"></A> CloneAttr Property</H4>

<P>The following attributes control the cloning process:
<UL>
<LI><CODE>"NumClones"</CODE> is the number of clones to create.</LI>
<LI><CODE>"Rotate"</CODE> is only used, if a trajectory curve is present.
If it is enabled all clones will be aligned according to the normal of
the trajectory curve. Otherwise the rotation attributes will not be
touched when placing the clone on the trajectory.
</LI>
<LI><CODE>"Translate_X"</CODE>, <CODE>"Translate_Y"</CODE>, <CODE>"Translate_Z"</CODE>,
<CODE>"Rotate_X"</CODE>, <CODE>"Rotate_Y"</CODE>, <CODE>"Rotate_Z"</CODE>,
<CODE>"Scale_X"</CODE>, <CODE>"Scale_Y"</CODE>, <CODE>"Scale_Z"</CODE>,
those attributes control the transformation of the instances created by
the Clone object. These attributes specify difference values
between two instances: the clone <CODE>"n+1"</CODE> is offset by <CODE>"Translate_X"</CODE>,
<CODE>"Translate_Y"</CODE>, and <CODE>"Translate_Z"</CODE> from the previous clone <CODE>"n"</CODE>.
It is also rotated by <CODE>"Rotate_X"</CODE>, <CODE>"Rotate_Y"</CODE>, and <CODE>"Rotate_Z"</CODE>
and scaled by <CODE>"Scale_X"</CODE>, <CODE>"Scale_Y"</CODE>, <CODE>"Scale_Z"</CODE> in relation
to the previous clone.
<P>Note however, that the transformation attributes
do not affect the first clone.</P>
<P>The transformation attributes are also in effect if a trajectory
curve is present, they will be applied after moving of the
instance to the trajectory and rotating it.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

</LI>
</UL>

The following table summarizes which transformation attributes are used
in the respective clone modes.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Mode</B></TD><TD><B>Use Child Transform</B></TD><TD><B>Use CloneAttrib Transform</B></TD><TD><B>Use Clone Transform</B></TD></TR><TR><TD>
Clone</TD><TD>No</TD><TD>Yes</TD><TD>Yes</TD></TR><TR><TD>
Trajectory</TD><TD>Yes</TD><TD>Yes</TD><TD>Yes</TD></TR><TR><TD>
Mirror</TD><TD>Yes</TD><TD>N/A</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Clone Parameterisation Examples</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The Clone object may be converted to ordinary objects using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>Upon conversion a Level object will be created, that contains the original
object <EM>and</EM> the clones.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Clone objects appear in RIB output as a number of real
objects, each with different transformation attributes.</P>
<P>As the original objects will also appear in the RIB output,
it is suggested to add a <CODE>"NoExport"</CODE> tag to the original
if the Clone is in trajectory mode.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="mirrorobj"></A> Mirror Object</H3>

<P>
<CENTER>
<IMG SRC="pics/mirror.gif" HEIGHT=167 WIDTH=389  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Mirrored Object (blue) From Curve (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Mirror object allows to easily create and control an arbitrary
number of mirrored instances of a number of
objects.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The original object(s)
<EM>and</EM> their mirrored counterparts will be
provided by the Mirror object to the respective parent object (normally,
tool objects do not provide their unmodified children).
Additionally, the order of the mirrored objects will be reversed so that
it is possible to use a single Mirror object (with one or multiple NURBS
curves as children) as parameter object of e.g.&nbsp;a Skin object:
<BLOCKQUOTE><CODE>
<PRE>
+-Skin
  +-Mirror
    \-NCurve
+-Skin
  +-Mirror
    |-Curve_1(NCurve)
    |-Curve_2(NCurve)
    \-Curve_3(NCurve)
</PRE>
</CODE></BLOCKQUOTE>

The first Skin object in the above example can only work, because also
the unmodified NCurve is provided by the Mirror object. The second Skin
object can only work properly, because the order of the provided objects
is reversed, so that it gets to see the curves in the following sequence:
<CODE>"NCurve_1"</CODE>, <CODE>"NCurve_2"</CODE>, <CODE>"NCurve_3"</CODE>, <CODE>"Mirrored_NCurve_3"</CODE>,
<CODE>"Mirrored_NCurve_2"</CODE>, <CODE>"Mirrored_NCurve_1"</CODE>.</P>
<P>The following table briefly lists some capabilities of the Mirror object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Mirror</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Children<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Mirror Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="mirrorattrprop"></A> <A NAME="mirrorattr"></A> MirrorAttr Property</H4>

<P>The following attributes control the mirror process:
<UL>
<LI><CODE>"Plane"</CODE> allows to select the plane about which the mirroring
should occur (YZ-, XZ-, or XY-plane).</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The Mirror object may be converted to ordinary objects using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>Upon conversion a Level object will be created, that contains the original
objects and the mirrored counterparts (the latter in reverse order).</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Mirror objects appear in RIB output as a number of real
objects, each with different transformation attributes.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="selectobj"></A> Select Object</H3>

<P>The Select object may be used in hierarchies
of tool objects to select one object from a list of provided
objects.<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
Also multiple objects and ranges (even decreasing
ranges that lead to reversed orders) may be
selected.<SMALL TITLE="Since 1.16."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>In the following example hierarchy, a single patch from multiple provided
patches of the Sweep object (the swept surface, a bevel, or a cap)
could be selected by the Select object and delivered upstream to
the ExtrNC object.
<BLOCKQUOTE><CODE>
<PRE>
+-Sweep             &lt;-----------------.
+-Revolve                             |
  +-ExtrNC                            |
    +-Select                          |
      \-Instance_of_Sweep(Instance) --'
</PRE>
</CODE></BLOCKQUOTE>

Note that this example just serves illustrative purpose; the hierarchy
presented is not exactly useful, as the ExtrNC object has a selector
facility built in. Consequently, the Select object should be used in
scenarios, where a selector facility does not exist or is hard to
implement, as e.g.&nbsp;in Script object scripts.</P>
<P>The following table briefly lists some capabilities of the Select object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Select</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>N/A&thinsp;/&thinsp;Children<SUP>+</SUP></TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Select Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="selectattrprop"></A> <A NAME="selectp"></A> SelectAttrib Property</H4>

<P>The following attribute controls the selection process:
<UL>
<LI><CODE>"Indices"</CODE> designates the object(s) to select. The index values
are zero based. Multiple indices must be separated by <CODE>","</CODE>, ranges
can be specified like this <CODE>"1-4"</CODE>, reversed ranges are allowed
(<CODE>"4-1"</CODE>) and will create an object list of reversed order. The special
index <CODE>"end"</CODE> (or abbreviated <CODE>"e"</CODE>) designates the last of all
the provided objects.
An index may appear multiple times, leading to multiple copies of the
selected object to be delivered upstream.
The index space spans over all provided objects of the desired type
from all child objects. This means provided objects from multiple different
child objects of the Select object can be mixed. Syntactically incorrect
ranges and indices are silently ignored.
<P>Examples:
<UL>
<LI><CODE>"0,2"</CODE> &ndash; delivers the first and third provided objects
upstream;</LI>
<LI><CODE>"end-0"</CODE> &ndash; delivers all provided objects in reversed order
upstream;</LI>
<LI><CODE>"0,0,0"</CODE> &ndash; delivers three copies of the first provided
object upstream;</LI>
<LI><CODE>"0,4-end,1"</CODE> &ndash; delivers the first, the fifth (if there are
so many) up to the last, and the second object upstream.</LI>
</UL>
</P>
</LI>
</UL>
</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Select objects never appear in RIB output.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="riincobj"></A> RiInc Object</H3>

<P>
<CENTER>
<IMG SRC="pics/riinc.gif" HEIGHT=197 WIDTH=294  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">RiInc Example</FONT></CENTER><P><CENTER>
</CENTER>

RiInc objects may be used to include objects or whole scene parts into your
scenes that are just available as a piece of RIB, a so called <EM>archive</EM>.
They can therefore help to manage huge scenes that are too cumbersome
to handle in total in Ayam.</P>
<P>RiInc objects draw a simple bounding box with stippled lines instead of the
archive contents; those will only become part of the scene when it is
exported to a RIB. See also the above image.
If a RiInc object has children, they will be drawn instead of the bounding box.
This allows to better convey the actual shape of the objects in the included
archive.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
As the bounding box, also the children never appear in the RIB.</P>
<P>Note that Ayam can not check, wether the bounding box or children
actually match the content of the included archive.</P>
<P>Also note that archives can be created easily using the main menu
entry<BR>
<CODE>"Special/RIB-Export/Selected Objects"</CODE>.</P>
<P>The following table briefly lists some capabilities of the RiInc object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
RiInc</TD><TD>Any</TD><TD>No</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">RiInc Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="riincattrprop"></A> <A NAME="riincp"></A> RiIncAttr Property</H4>

<P>The following attributes control the inclusion process:
<UL>
<LI>Using <CODE>"File"</CODE> the filename of the RIB archive to be
included is specified.</LI>
<LI><CODE>"Width"</CODE>, <CODE>"Height"</CODE>, and <CODE>"Length"</CODE> determine
the size of a box, that will be drawn as a geometric representation of
the RIB archive (if no children are present).</LI>
</UL>
</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>RiInc objects export as single
<BLOCKQUOTE><CODE>
<CODE>ReadArchive &lt;filename&gt;</CODE>
</CODE></BLOCKQUOTE>

statement.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="riprocobj"></A> RiProc Object</H3>

<P>RiProc objects may be used to include procedural objects or external
archives into your scenes. In contrast to archives included via a
RiInc object, these archives will only be included by the RenderMan
renderer when the specified bounding box is visible to the current camera.</P>
<P>The following table briefly lists some capabilities of the RiProc object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
RiProc</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">RiProc Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="riprocattrprop"></A> <A NAME="riprocp"></A> RiProcAttr Property</H4>

<P>The following attributes control the RiProc object:
<UL>
<LI><CODE>"Type"</CODE> defines the type of the procedural object which is
one of <CODE>"DelayedReadArchive"</CODE>, <CODE>"RunProgram"</CODE>, or
<CODE>"DynamicLoad"</CODE>.</LI>
<LI>Using <CODE>"File"</CODE> you specify the filename of the RIB archive,
program, or dynamic shared object (depending on the type of the
procedural object).</LI>
<LI>Using <CODE>"Data"</CODE> additional arguments may be supplied to
procedural objects of type <CODE>"RunProgram"</CODE> and <CODE>"DynamicLoad"</CODE>.</LI>
<LI><CODE>"MinX"</CODE>, <CODE>"MaxX"</CODE>, <CODE>"MinY"</CODE>, <CODE>"MaxY"</CODE>, <CODE>"MinZ"</CODE>,
and <CODE>"MaxZ"</CODE> specify the size of the bounding box of the objects that
the procedural will create or the archive contains.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>RiProc objects export as single
<BLOCKQUOTE><CODE>
<CODE>RiProcedural</CODE>
</CODE></BLOCKQUOTE>

statement.</P>


<H2><A NAME="solids"></A> <A NAME="ss4.3">4.3</A> <A HREF="ayam.html#toc4.3">CSG&thinsp;/&thinsp;Solid Primitives</A>
</H2>

<P>These objects serve as geometric primitives in CSG hierarchies.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="boxobj"></A> Box Object</H3>

<P>A solid box, centered at the origin of the object coordinate system.</P>
<P>The following table briefly lists some capabilities of the Box object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Box</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>&lowast;</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Box Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="boxattrprop"></A> <A NAME="bxp"></A> BoxAttr Property</H4>

<P>The following parameters control the shape of the box:
<UL>
<LI><CODE>"Width"</CODE> is the width of the box (size of the box in
direction of the X-axis of the objects coordinate system).</LI>
<LI><CODE>"Length"</CODE> is the length of the box (size of the box in
direction of the Z-axis of the objects coordinate system).</LI>
<LI><CODE>"Height"</CODE> is the height of the box (size of the box in
direction of the Y-axis of the objects coordinate system).</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A box object may be converted to three NURBS patches
using the main menu entry
<CODE>"Tools/Convert"</CODE>.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See section 
<A HREF="ayam-6.html#cboxtcl">Cylindrical Box</A> for a Script
object that converts to a single NURBS patch.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The box object will always be exported as six bilinear patches.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sphereobj"></A> Sphere Object</H3>

<P>A sphere, centered at the origin of the object coordinate system.</P>
<P>The following table briefly lists some capabilities of the Sphere object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Sphere</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Sphere Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sphereattrprop"></A> <A NAME="spattr"></A> SphereAttr Property</H4>

<P>The following parameters control the shape of the sphere:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the sphere
may be used in CSG operations safely.</LI>
<LI><CODE>"Radius"</CODE> is the radius of the sphere, default is 1.</LI>
<LI><CODE>"ZMin"</CODE> is the lower limit of the sphere on the Z-axis,
default is -1.</LI>
<LI><CODE>"ZMax"</CODE> is the upper limit of the sphere on the Z-axis,
default is 1.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the sphere in degrees, default
is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A Sphere object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the sphere.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the sphere is closed, an enclosing Level object will be
created and the caps follow the sphere in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The Sphere object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiSphere(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"ZMin"</CODE>, <CODE>"ZMax"</CODE>, or
<CODE>"ThetaMax"</CODE> have other than the default values,
as complex CSG hierarchy of at most two spheres, two cylinders, and
eight disks.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="diskobj"></A> Disk Object</H3>

<P>A disk in the XY-plane, centered at the origin of the object coordinate system.</P>
<P>The following table briefly lists some capabilities of the Disk object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Disk</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Disk Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="diskattrprop"></A> <A NAME="dkp"></A> DiskAttr Property</H4>

<P>The following parameters control the shape of the disk:
<UL>
<LI><CODE>"Radius"</CODE> is the radius of the disk, default is 1.</LI>
<LI><CODE>"ZMin"</CODE> displaces the disk along the Z-axis, default is 0.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the disk in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A Disk object may be converted to a NURBS patch
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the disk.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The Disk object will always be exported as simple disk:
<BLOCKQUOTE><CODE>
<CODE>RiDisk(...);</CODE>
</CODE></BLOCKQUOTE>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="coneobj"></A> Cone Object</H3>

<P>A cone, centered at the origin of the object coordinate system,
with the base in the XY-plane.</P>
<P>The standard cone is always pointed.
See section 
<A HREF="ayam-6.html#tconetcl">Truncated Cone</A> for a Script
object that implements a truncated cone.</P>
<P>The following table briefly lists some capabilities of the Cone object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Cone</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Cone Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="coneattrprop"></A> <A NAME="cnp"></A> ConeAttr Property</H4>

<P>The following parameters control the shape of the cone:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the cone
may be used in CSG operations safely.</LI>
<LI><CODE>"Radius"</CODE> is the radius of the cone at the base, default is 1.</LI>
<LI><CODE>"Height"</CODE> is the height of the cone, default is 1.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the cone in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A Cone object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the cone.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the cone is closed, an enclosing Level object will be
created and the caps follow the cone in the following order:
disk-shaped cap at the base, cap at theta 0,
cap at thetamax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The Cone object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiCone(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"ThetaMax"</CODE> has a different than
the default value, as complex CSG hierarchy of at most one cone, one disk, and
two polygons.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cylinderobj"></A> Cylinder Object</H3>

<P>A cylinder, centered at the origin of the object coordinate system.</P>
<P>The following table briefly lists some capabilities of the Cylinder object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Cylinder</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Cylinder Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="cylinderattrprop"></A> <A NAME="cyp"></A> CylinderAttr Property</H4>

<P>The following parameters control the shape of the cylinder:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the cylinder
may be used in CSG operations safely.</LI>
<LI><CODE>"Radius"</CODE> is the radius of the cylinder, default is 1.</LI>
<LI><CODE>"ZMin"</CODE> determines the Z location of the base, default is -1.</LI>
<LI><CODE>"ZMax"</CODE> determines the Z location of the top, default is 1.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the cylinder in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A cylinder object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the cylinder.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the cylinder is closed, an enclosing Level object will be
created and the caps follow the cylinder in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The cylinder object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiCylinder(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"ThetaMax"</CODE> has a different than
the default value, as complex CSG hierarchy of at most one cylinder, two disks,
and two polygons.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="torusobj"></A> Torus Object</H3>

<P>A torus, centered at the origin of the object coordinate system.
A torus is a donut like shape, that results from sweeping
a small circle (that has been displaced along X sufficiently)
around the Z-axis.</P>
<P>The following table briefly lists some capabilities of the Torus object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Torus</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Torus Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="torusattrprop"></A> <A NAME="top"></A> TorusAttr Property</H4>

<P>The following parameters control the shape of the torus:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the torus
may be used in CSG operations safely.</LI>
<LI><CODE>"MajorRad"</CODE> is the radius of the torus, measured
from the Z-axis to the center of the swept smaller circle, default is 0.75.</LI>
<LI><CODE>"MinorRad"</CODE> is the radius of the swept circle, default is 0.25.</LI>
<LI><CODE>"PhiMin"</CODE> determines an angle to limit the swept circle,
default is 0.</LI>
<LI><CODE>"PhiMax"</CODE> determines an angle to limit the swept circle,
default is 360.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the torus in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A torus object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the torus.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the torus is closed, an enclosing Level object will be
created and the caps follow the torus in the following order:
disk-shaped cap at theta 0, disk-shaped cap at thetamax, ring-shaped
cap at phimin 0, ring-shaped cap at phimax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The torus object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiTorus(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"PhiMin"</CODE>, <CODE>"PhiMax"</CODE>, or
<CODE>"ThetaMax"</CODE> have different than the default values, as complex
CSG hierarchy of at most one one torus, two disks, and two hyperboloids.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="paraboloidobj"></A> Paraboloid Object</H3>

<P>A paraboloid, centered at the origin of the object coordinate system.</P>
<P>The following table briefly lists some capabilities of the Paraboloid object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Paraboloid</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Paraboloid Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="paraboloidattrprop"></A> <A NAME="pap"></A> ParaboloidAttr Property</H4>

<P>The following parameters control the shape of the paraboloid:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the paraboloid
may be used in CSG operations safely.</LI>
<LI><CODE>"RMax"</CODE> is the radius of the paraboloid at a Z of <CODE>"ZMax"</CODE>,
the base of the paraboloid surface, default is 1.</LI>
<LI><CODE>"ZMin"</CODE> limits the paraboloid surface on the Z-axis,
must be positive, default is 0.</LI>
<LI><CODE>"ZMax"</CODE> limits the paraboloid surface on the Z-axis and
determines the Z location of the base, must be positive, default is 1.</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the paraboloid in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A paraboloid object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the paraboloid.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the paraboloid is closed, an enclosing Level object will be
created and the caps follow the paraboloid in the following order:
disk-shaped cap at zmin, disk-shaped cap at zmax, cap at theta 0,
cap at thetamax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The paraboloid object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiParaboloid(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"ZMin"</CODE>, <CODE>"ZMax"</CODE>, or
<CODE>"ThetaMax"</CODE> have different than the default values, as complex
CSG hierarchy of at most one paraboloid, two disks, and two bicubic patches.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="hyperboloidobj"></A> Hyperboloid Object</H3>

<P>A hyperboloid, centered at the origin of the object coordinate system.
The shape of the hyperboloid will be created by sweeping a line specified
by two points in space around the Z-axis. Thus, disk, cylinder, and cone are
special cases of the hyperboloid.</P>
<P>The following table briefly lists some capabilities of the Hyperboloid object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Hyperboloid</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Hyperboloid Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="hyperboloidattrprop"></A> <A NAME="hyp"></A> HyperboloidAttr Property</H4>

<P>The following parameters control the shape of the hyperboloid:
<UL>
<LI><CODE>"Closed"</CODE> toggles whether the object should
be automatically sealed (closed by matching cap surfaces).<BR>
Only when this option is enabled, the hyperboloid
may be used in CSG operations safely.</LI>
<LI><CODE>"P1_X"</CODE>, <CODE>"P1_Y"</CODE> and <CODE>"P1_Z"</CODE>, define point one,
default is (0, 1, -0.5).</LI>
<LI><CODE>"P2_X"</CODE>, <CODE>"P2_Y"</CODE> and <CODE>"P2_Z"</CODE>, define point two,
default is (1, 0, 0.5).</LI>
<LI><CODE>"ThetaMax"</CODE> is the sweeping angle of the hyperboloid in degrees,
default is 360.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A hyperboloid object may be converted to NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>. This conversion
obeys all parameters of the hyperboloid.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If the hyperboloid is closed, an enclosing Level object will be
created and the caps follow the hyperboloid in the following order:
disk-shaped cap at P1, disk-shaped cap at P2, non-planar cap at theta 0,
non-planar cap at thetamax.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>The hyperboloid object appears in RIB output as simple
<BLOCKQUOTE><CODE>
<CODE>RiHyperboloid(...);</CODE>
</CODE></BLOCKQUOTE>

or, if <CODE>"Closed"</CODE> is enabled and <CODE>"ThetaMax"</CODE> has a different than
the default value, as complex CSG hierarchy of at most one hyperboloid,
two disks, and two bilinear patches.</P>
<P>Note that due to a bug in BMRT that is still present in V2.3.6
the <CODE>"Closed"</CODE> option does not work properly when
<CODE>"ThetaMax"</CODE> has a different than the default value and the
hyperboloid has no displacement shader. In fact, using a displacement
shader with a km (amount of displacement) of 0.0 is a work-around
for this bug (found by T. E. Burge).</P>



<H2><A NAME="curves"></A> <A NAME="ss4.4">4.4</A> <A HREF="ayam.html#toc4.4">Freeform Curve Objects</A>
</H2>

<P>These objects are mainly used as child objects for the surface
generating tool objects.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ncurveobj"></A> NCurve (NURBS Curve) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/ncurve.gif" HEIGHT=242 WIDTH=364  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">A simple NURBS Curve</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The NCurve object is the most used basic object for NURBS modelling
in Ayam because NURBS curves are used to build more complex smoothly
shaped surfaces using operations like extrude, revolve, sweep or skin.
NURBS curves can be open or closed and used to emulate Bezier and
B-Spline curves easily. In addition, for easier modelling, they
support multiple points, as explained in section
<A HREF="#ncurvemp">Multiple Points</A>.</P>
<P>The following table briefly lists some capabilities of the NCurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
NCurve</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">NCurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>NCurve objects may be created via the toolbox, the main menu, several
tools as documented in
section 
<A HREF="ayam-5.html#cctools">Curve Creation Tools</A>, or the
scripting interface, see also
section 
<A HREF="ayam-6.html#sccrtnc">Creating Objects</A>.</P>
<P>Tools that process NCurve objects are documented in
<A HREF="ayam-5.html#cmtools">Curve Modification Tools</A>.</P>
<P>The next section details the NCurve object property.</P>

<H4><A NAME="s3"></A> <A NAME="ncurveattrprop"></A> <A NAME="ncattr"></A> NCurveAttr Property</H4>

<P>The first section of the NCurveAttr property contains curve specific
settings:
<UL>
<LI><CODE>"Type"</CODE>: This attribute replaces the <CODE>"Closed"</CODE>
attribute since Ayam 1.9.

<P>The type <CODE>"Open"</CODE> is for the standard open NURBS curve.</P>

<P>If the type is <CODE>"Closed"</CODE>, the first and last control point of
the curve will be made identical. This will close the curve but
without any guaranteed continuity.
Such a closed curve will e.g.&nbsp;be created by the NURBS circle tool.
It is important to know, that identical start/end control points
alone can not guarantee that the curve is closed if the knot vector
is not clamped. If in doubt, use the clamp tool or a knot vector
of type <CODE>"NURB"</CODE>, <CODE>"Chordal"</CODE>, or <CODE>"Centripetal"</CODE>.</P>

<P>If the type is <CODE>"Periodic"</CODE>, the last <EM>p</EM> control points of the curve
will be made identical to the first <EM>p</EM> where <EM>p</EM> is the degree of the
curve (read order-1). This will close the curve with guaranteed continuity.
Note that for a cubic spline (order 4) you will need at least 6 control
points to make it periodic. It is important to know, that the multiple control
points alone can not guarantee that the curve is closed if the knot vector
has no periodic extensions. If in doubt, switch the curve to
knot type <CODE>"B-Spline"</CODE>, <CODE>"Chordal"</CODE>, or <CODE>"Centripetal"</CODE>.</P>

<P>You may also want to enable the creation of multiple points using the
<CODE>"CreateMP"</CODE> attribute (see below) for closed and periodic curves so that
single point editing actions modify all multiple control points.</P>

</LI>
<LI><CODE>"Length"</CODE> is the number of control points of the curve.
</LI>
<LI><CODE>"Order"</CODE> is the order of the curve.</LI>
<LI><CODE>"Knot-Type"</CODE>: Using <CODE>"Knot-Type"</CODE> you may select from
<CODE>"NURB"</CODE>, <CODE>"Bezier"</CODE>, <CODE>"B-Spline"</CODE>, <CODE>"Custom"</CODE>, <CODE>"Chordal"</CODE>,
and <CODE>"Centripetal"</CODE> knot types.

<P>The knot type <CODE>"NURB"</CODE> will generate uniformly distributed knot values
ranging from 0.0 to 1.0, where the multiplicity of the knots at the
ends will be of order of the curve (the knot vector will be clamped).
This guarantees that the curve will touch the control points at the ends
of the curve.
An example <CODE>"NURB"</CODE> knot vector for a curve of length 5 and order 4
would be:</P>

<P><CODE>{ 0.0 0.0 0.0 0.0 0.5 1.0 1.0 1.0 1.0 }</CODE>.</P>

<P>The knot type <CODE>"Bezier"</CODE> will generate just 0.0 and 1.0 values. Note that
the order of the curve has to be equal to the length of the curve if
<CODE>"Bezier"</CODE> knots are generated. Otherwise, the generated knot sequence is
illegal. The resulting curve looks and behaves exactly like a real
Bezier curve, interpolating the control points at the ends and so on.
An example <CODE>"Bezier"</CODE> knot vector for a curve of length 5 and order 5
would be:</P>

<P><CODE>{ 0.0 0.0 0.0 0.0 0.0 1.0 1.0 1.0 1.0 1.0 }</CODE>.</P>

<P>The knot type <CODE>"B-Spline"</CODE> will generate uniformly distributed knot values
(without any multiple knots). The resulting curve looks and behaves like a
B-Spline curve. It is <EM>not</EM> interpolating the control end points.
An example <CODE>"B-Spline"</CODE> knot vector for a curve of length 5 and order 4
would be:</P>

<P><CODE>{ 0.0 0.125 0.25 0.375 0.5 0.625 0.75 0.875 1.0 }</CODE>.</P>

<P>The knot types <CODE>"Chordal"</CODE> and <CODE>"Centripetal"</CODE> will generate knot
values whose distribution reflect the distances of the control points.
This only works, if there are free knots in the knot vector,
i.e.&nbsp;knots that are not subject to clamping or periodic extensions
(the default NURBS curve with 4 control points and order 4 has
<EM>none</EM>).
For open curves, the generated knot vector will be clamped, for periodic
curves, proper periodic extensions will be created.
Those knot types are mainly useful for curves with unevenly distributed
control points that will be sampled uniformly (in parametric space) later
on and where it is expected, that the uniform sampling in parameter space
results in evenly distributed sample points in coordinate space, e.g.&nbsp;if
the curves are used as Sweep, Birail, or Clone trajectory, or surfaces
are created from them that use implicit texture coordinates or a uniform
tesselation strategy.
The <CODE>"Chordal"</CODE> and <CODE>"Centripetal"</CODE> knots will ensure a more uniform
distribution of the sample points on the curve in such cases (see also the
example image below).
An example <CODE>"Chordal"</CODE> knot vector for an open curve of length 5 and
order 4 would be:</P>

<P><CODE>{ 0.0 0.0 0.0 0.0 0.388889 1.0 1.0 1.0 1.0 }</CODE>.</P>
<P>The image below illustrates the use of two curves with uniform (NURB)
vs.&nbsp;chordal knot vectors as Sweep trajectories.
The upper Sweep with the uniform knot vector has much more unevenly
distributed/sized sections and exhibits more severe self intersection
problems.
Please note that the shapes of the curves differ slightly.</P>
<P>
<CENTER>
<IMG SRC="pics/chordalex.gif" HEIGHT=269 WIDTH=269  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Sweeps Created From Curves With Uniform (upper) And
Chordal (lower) Knot Vectors</FONT></CENTER><P><CENTER>
</CENTER>
</P>

</LI>
<LI><CODE>"Knots"</CODE> allows to enter own custom knot sequences.
Note that this only works if the <CODE>"Knot-Type"</CODE> (above)
is <CODE>"Custom"</CODE>. Otherwise, the <CODE>"Knots"</CODE> parameter just displays
the automatically generated knot sequence and changes to the values
have no effect.

<P>Each knot vector has l+o knot values, where l is the
length of the curve and o its order.
The knot values must be strictly monotonous (increasing) and the maximum
number of equal values in a row must not exceed the order of the curve.</P>

</LI>
<LI><CODE>"CreateMP"</CODE> toggles, whether multiple points should be
created for this curve. See also the discussion in
section 
<A HREF="#ncurvemp">Multiple Points</A>.
</LI>
<LI><CODE>"IsRat"</CODE> informs, whether the curve
is rational (has any weight values different from
1.0).<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
</UL>
</P>
<P>The GLU-parameters control the appearance of the curve when
curve/surface display is enabled.
<UL>
<LI><CODE>"Tolerance"</CODE> is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering a curve.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<CODE>"Drawing/Tolerance"</CODE> should be used.
</LI>
<LI><CODE>"DisplayMode"</CODE> determines how the curve should
be drawn. The control hull (control polygon) or the curve or a
combination of both may be displayed. The setting <CODE>"Global"</CODE>
means, that the global preference setting
<CODE>"Drawing/NCDisplayMode"</CODE> should be used.
</LI>
</UL>
</P>
<P>When changing more than one of the above values the changes will be
applied in the order of the values in the property. The
sum of the changed values should describe a valid NURBS curve.
It is perfectly legal to change the length of the curve,
it's order, and switch to a custom knot vector (be sure to actually
enter a valid new knot vector) at once. Ayam will check your changes
and fall back to certain default values if e.g.&nbsp;your knot sequence is wrong.
Check the console for any messages after pressing the <CODE>"Apply"</CODE> button!</P>
<P>When the curve type is changed using the NCurveAttr property
Ayam may also have to change the position of some control points
as follows:
<UL>
<LI>When the type is changed from <CODE>"Open"</CODE> to <CODE>"Closed"</CODE>,
the last control point is moved to be identical to the first one.
In addition, if the current knot type of the curve is <CODE>"B-Spline"</CODE>,
it will be reset to knot type <CODE>"NURB"</CODE>.</LI>
<LI>When the type is changed from <CODE>"Open"</CODE> or <CODE>"Closed"</CODE> to
<CODE>"Periodic"</CODE>, the last
p control points will be moved to be identical to the first p, where
p is the degree of the curve (order-1). For a cubic curve (order 4),
consequently, the last three control points will be moved. In addition,
if the current knot type of the curve is <CODE>"NURB"</CODE> or <CODE>"Bezier"</CODE>
it will be changed to <CODE>"B-Spline"</CODE> automatically.</LI>
</UL>

When changing the order of a periodic curve (and not
touching the length) Ayam will automatically add or remove control
points to/from the curve so that the shape of the curve remains
largely intact and the periodic extensions
plausible.<SMALL TITLE="Since 1.18."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<H4><A NAME="s3"></A> <A NAME="ncurvemp"></A> Multiple Points</H4>

<P>
<CENTER>
<IMG SRC="pics/multip.gif" HEIGHT=206 WIDTH=204  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">A NURBS Curve with Multiple Points (big handles)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The NURBS curves of Ayam support so called multiple points.
A multiple point is made of a number of different control points
that have the same coordinates. Multiple points will be drawn with a
bigger handle than normal points (see image above).<BR>
Single point interactive modelling actions (e.g.&nbsp;edit) will always
modify all the control points that make up a multiple point.<BR>
Selecting/tagging a multiple point will always select all control points
of that multiple point.<BR>
Modelling actions that work with selected points (e.g.&nbsp;translate)
will only modify all control points of a multiple point, if it is
completely selected. This selection state is conveyed by drawing
a completely filled bigger handle.<SMALL TITLE="Since 1.28."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Individual points of a multiple point may be selected by
<UL>
<LI>turning off the <CODE>"CreateMP"</CODE> property of the curve,</LI>
<LI>using the <CODE>"selPnts"</CODE> scripting interface command<BR>
(see also section
<A HREF="ayam-6.html#scselpnts">selPnts command</A>), or</LI>
<LI>using the <CODE>"CVView"</CODE> property<BR>
(see also section
<A HREF="ayam-6.html#cvviewtcl">CVView property</A>).</LI>
</UL>

Note that the control
points that make up a multiple point do not have to be consecutive
(in the control point vector of the NURBS curve).</P>
<P>Multiple points may also be created using the collapse tool,
and split up again using the explode tool (see sections
<A HREF="ayam-5.html#collt">Collapse Tool</A> and
<A HREF="ayam-5.html#explt">Explode Tool</A> for more information regarding
those tools).</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>NCurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="icurveobj"></A> ICurve (Interpolating Curve) Object</H3>

<P>The ICurve object creates a global interpolating NURBS curve from n
3D non-rational ordered data points.
The curve may be open or closed, the order of the curve may be configured,
the parameterisation may be adapted, and end derivatives may be specified.
The open versions create n+2 NURBS control points, and the closed ones
n+3.</P>
<P>
<CENTER>
<IMG SRC="pics/icurves.gif" HEIGHT=256 WIDTH=256  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Different ICurves resulting from identical data point configurations
(Upper Left: Open, Order 3; Upper Right: Open, Order 4; Lower Left: Closed, Order 3; Lower Right: Closed, Order 4)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The image above shows some interpolating curves, the left ones
are of order 3 (quadratic curves), the right ones are of order 4 (cubic
curves), the upper open, and the lower closed ones. The interpolation
fidelity for the closed curves was tuned by adjusting the <CODE>"SDLen"</CODE>
and <CODE>"EDLen"</CODE> parameters (all set to 0.2), see also the discussion
of the parameters below.</P>
<P>In all parameterisation modes, knot averaging will be used
to determine the knot vector of the interpolating curve.</P>
<P>Note that the axis of symmetry for closed interpolating curves
crosses the first data point (in contrast to open interpolating
or closed approximating curves, where it crosses between the last
and first data point).
For example, the closed interpolating curves in the above example
image are indeed both symmetric, but the axis of symmetry is crossing
the first and third data point and is, thus, rotated by 45 degrees.</P>
<P>This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g.&nbsp;revolve, sweep, extrude, and skin) are
able to work with an ICurve object instead of an object
of type NCurve.</P>
<P>The following table briefly lists some capabilities of the ICurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ICurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ICurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>ICurve objects may be created via the toolbox, the main menu, or the
scripting interface, see also 
<A HREF="ayam-6.html#sccrtic">Creating Objects</A>.</P>

<H4><A NAME="s3"></A> <A NAME="icurveattrprop"></A> <A NAME="icp"></A> ICurveAttr Property</H4>

<P>The following parameters control the interpolation process:
<UL>
<LI>The <CODE>"Type"</CODE> parameter controls whether the interpolated
curve should be open or closed.
</LI>
<LI><CODE>"Length"</CODE> is the number of data points to interpolate.
</LI>
<LI>The next parameter <CODE>"Order"</CODE> determines the desired order of the
interpolating curve. If the specified order is bigger than the number of
control points used by the interpolating NURBS curve, then the order is
silently changed to match the number of control points.
</LI>
<LI>The parameter <CODE>"ParamType"</CODE> switches the parameterisation
between <CODE>"Chordal"</CODE> (default), <CODE>"Centripetal"</CODE>, and <CODE>"Uniform"</CODE>.
The centripetal method generates a better parameterisation than
the default (chordal) if the input data contains sharp turns.
The uniform method is available since Ayam 1.20 and generates
worse parameterisations (that lead to wiggles and overshooting)
in the general case but it might help in some edge cases.
</LI>
<LI><CODE>"Derivatives"</CODE> allows to choose between automatic and
manual derivatives.

<P>If automatic derivatives are switched on, the direction of the derivatives
will be determined from the first, second, second to last, and last
data points for open curves and from the second and second to last data
points for closed curves. In addition, the respective derivative
vector will be scaled by <CODE>"SDLen"</CODE> and <CODE>"EDLen"</CODE>.</P>
<P>If manual derivatives are switched on, two more
editable points appear in the single point editing modes. Those
additional points directly control the derivatives for the
endpoints of the interpolating curve. The parameters <CODE>"SDLen"</CODE> and
<CODE>"EDLen"</CODE> do not influence those derivatives.</P>

</LI>
<LI>The parameters <CODE>"SDLen"</CODE> and <CODE>"EDLen"</CODE> are used to control
the length of the first and last derivative (if automatically
generated from the data points, i.e.&nbsp;when <CODE>"Derivatives"</CODE> above is
switched to automatic).
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the created NURBS curve.</LI>
</UL>
</P>
<P>The parameters <CODE>"Mode"</CODE>, <CODE>"Closed"</CODE>, and <CODE>"IParam"</CODE> are gone
since Ayam 1.16. <CODE>"Closed"</CODE> was replaced by <CODE>"Type"</CODE>, <CODE>"IParam"</CODE>
by <CODE>"SDLen"</CODE> and <CODE>"EDLen"</CODE>, and the <CODE>"Mode"</CODE> is now determined
automatically from the desired order.</P>
<P>See also the related tool to create interpolating NURBS curves:
<A HREF="ayam-5.html#interpnct">Interpolate Tool</A>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The interpolating curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ICurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="acurveobj"></A> ACurve (Approximating Curve) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/acurves.gif" HEIGHT=266 WIDTH=304  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Different ACurves (Upper Left: ALength 3, Order 3; Upper Right: ALength 4, Order 4; Lower Left: ALength 4, Order 4; Lower Right: ALength 6, Order 3)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The ACurve object creates an approximating NURBS curve with m control
points from n 3D non-rational ordered data points (see image
above).<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The number of desired output control points must be smaller than
or equal to the number of data points to approximate (m&le;n).
The approximation algorithm used is of
the least squares variety. If the number of control points approaches the
number of data points, undesired wiggles in the output curve may occur.</P>
<P>This object makes use of the provide mechanism. It marks itself
as providing a NCurve object (it creates and uses NURBS curves
internally anyway) and all other objects that work with
the provide mechanism (e.g.&nbsp;Revolve, Sweep, Extrude, and Skin) are
able to work with an ACurve object instead of an object
of type NCurve.</P>
<P>The following table briefly lists some capabilities of the ACurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ACurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ACurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>ACurve objects may be created via the main menu or the
scripting interface, see also 
<A HREF="ayam-6.html#sccrtac">Creating Objects</A>.</P>

<H4><A NAME="s3"></A> <A NAME="acurveattrprop"></A> <A NAME="acp"></A> ACurveAttr Property</H4>

<P>The following parameters control the approximation process:
<UL>
<LI><CODE>"Length"</CODE> determines the number of data points to
approximate.
</LI>
<LI><CODE>"ALength"</CODE> is the number of (distinct)
control points to use for the approximating NURBS curve.
The total number of distinct control points must be smaller than or equal
to the number of data points.
</LI>
<LI>The curve can be closed with the parameter <CODE>"Closed"</CODE>.
For closed approximations, the total number of control points will
be <CODE>"ALength + Order - 1"</CODE>.
The following table illustrates this relationship.

<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Length</B></TD><TD><B>ALength</B></TD><TD><B>Order</B></TD><TD><B>Closed</B></TD><TD><B>Output Length</B></TD></TR><TR><TD>
10</TD><TD>5</TD><TD>3</TD><TD>No</TD><TD>5</TD></TR><TR><TD>
10</TD><TD>5</TD><TD>3</TD><TD>Yes</TD><TD>8</TD></TR><TR><TD>
10</TD><TD>4</TD><TD>4</TD><TD>Yes</TD><TD>8</TD></TR><TR><TD>
5</TD><TD>4</TD><TD>3</TD><TD>No</TD><TD>4</TD></TR><TR><TD>
5</TD><TD>4</TD><TD>3</TD><TD>Yes</TD><TD>7
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ACurve Parameterisation Examples</FONT></CENTER><P><CENTER>
</CENTER>
</P>


</LI>
<LI>For symmetric data point configurations, the approximating curve
is not necessarily symmetric. With the parameter <CODE>"Symmetric"</CODE>
a symmetric result can be enforced (see image below), albeit at the
cost of about double runtime and a slightly worse parameterisation.
<P>
<CENTER>
<IMG SRC="pics/acurve-sym.gif" HEIGHT=195 WIDTH=389  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Left: asymmetric ACurve, Right: symmetric ACurve</FONT></CENTER><P><CENTER>
</CENTER>
</P>

</LI>
<LI>The parameter <CODE>"Order"</CODE> specifies the desired order
of the approximating NURBS curve. Currently, only orders higher than
2 are supported.
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the created NURBS curve.</LI>
</UL>
</P>
<P>See also the related tool to approximate existing NURBS curves:
<A HREF="ayam-5.html#approxnct">Approximate Tool</A>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The approximating curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ACurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ncircleobj"></A> NCircle (NURBS Circle) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/ncircles.gif" HEIGHT=158 WIDTH=418  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Different NCircle Objects (l: default, m: TMax 180, r: Radius 0.5, TMax -200)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The NCircle object creates a circular NURBS curve or a circular arc in
the XY-plane centered at the origin with designated radius and start/end
angles (see image above).<SMALL TITLE="Since 1.12."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>A full circle is created using nine rational control points in a rectangular
configuration, circular arcs are created with fewer control points. See
section 
<A HREF="ayam-6.html#tcircletcl">NURBS Circle with Triangular Base</A> for
a Script object that implements a circle with less control points.</P>
<P>In order to revert the created NURBS curve
the start/end angles may be used, e.g.&nbsp;<CODE>"TMin"</CODE> 0.0,
<CODE>"TMax"</CODE> -360.0 for a reverse full circle.<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The following table briefly lists some capabilities of the NCircle object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
NCircle</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">NCircle Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="ncircleattrprop"></A> NCircleAttr Property</H4>

<P>The following parameters control the shape of the circle or
arc.
<UL>
<LI><CODE>"Radius"</CODE> is the radius of the circle.
</LI>
<LI><CODE>"TMin"</CODE> (ThetaMin) controls the starting angle of the circle
or arc to be created. Negative values are allowed.
</LI>
<LI><CODE>"TMax"</CODE> (ThetaMax) controls the end angle of the circle
or arc to be created. Negative values are allowed.
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the created NURBS curve.</LI>
</UL>
</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The circular curve/arc may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>NCircle objects never directly appear in RIB output (only indirectly as trim
curve).</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>More Curve Types</H3>

<P>More basic curve types are available via plugins and scripts, those are:
<UL>
<LI>Basis Curve: 
<A HREF="#bcurveobj">BCurve object</A>,</LI>
<LI>Subdivison Curve: 
<A HREF="#sdcurveobj">SDCurve object</A>,</LI>
<LI>Superformula Curve: 
<A HREF="#sfcurveobj">SFCurve object</A>,</LI>
<LI>NURBS circle with triangular
base: 
<A HREF="ayam-6.html#tcircletcl">TCircle script object</A>,</LI>
<LI>Helix Curve: 
<A HREF="ayam-6.html#helixtcl">Helix script object</A>, and</LI>
<LI>Spiral Curve: 
<A HREF="ayam-6.html#spiraltcl">Spiral script object</A>.</LI>
</UL>
</P>



<H2><A NAME="ctobjs"></A> <A NAME="ss4.5">4.5</A> <A HREF="ayam.html#toc4.5">Curve Tool Objects</A>
</H2>

<P>These objects modify existing curves or create new curves.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="concatncobj"></A> ConcatNC (Concatenate NURBS Curves) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/concatnc.gif" HEIGHT=230 WIDTH=230  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">ConcatNC Object (blue) from a Linear Curve and 3 Instances (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The ConcatNC object concatenates all child objects (which should be
NURBS curves or provide NURBS curves) to a single NURBS curve. Since
the ConcatNC object also provides a NURBS curve, it is possible to
use it as child object for another ConcatNC object (with possibly
different parameters) or as a parameter object for a tool object that
works with NURBS curves such as Revolve or Extrude.</P>
<P>The concatenation process works as follows:
<OL>
<LI>The orders of all parameter curves will be elevated to the maximum
order of all the parameter curves (see also section
<A HREF="ayam-5.html#elevt">elevate tool</A> for more information on elevation)
and all curves will be clamped (see also section
<A HREF="ayam-5.html#clat">clamp tool</A> for more information on clamping).</LI>
<LI>If the parameter <CODE>"FillGaps"</CODE> is enabled, fillet curves will be
created for every gap between the parameter curves of the ConcatNC object.
If <CODE>"Closed"</CODE> and <CODE>"FillGaps"</CODE> are enabled, an additional fillet
is created to close the curve.</LI>
<LI>Now the control points of all parameter curves and fillets are simply
copied into a new big control point vector, without checking for double
points. This means that for parameter curves that touch at their
respective ends, at least double control points in the new concatenated
curve will result.</LI>
<LI>If <CODE>"Closed"</CODE> is enabled, the curve will be closed.</LI>
</OL>
</P>
<P>The knot sequence of the new concatenated curve will be of type
<CODE>"NURB"</CODE> or a custom knot vector will be computed (depending
on the setting of <CODE>"Knot-Type"</CODE>).<BR>
If <CODE>"Knot-Type"</CODE> is <CODE>"NURB"</CODE>, the shape of the concatenated curve
will differ from the parameter curves if any of the parameter curves has
a custom knot vector with non equidistant knots.<BR>
If <CODE>"Knot-Type"</CODE> is <CODE>"Custom"</CODE>, the shape of the parameter curves
will be preserved completely, but the knot vector of the concatenated
curve will then contain internal multiple knots.</P>
<P>Attributes like display mode and tolerance for the new concatenated curve
are simply taken from the first parameter curve.</P>
<P>For best results, only clamped curves should be used as parameter objects.</P>


<P>The following table briefly lists some capabilities of the ConcatNC object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ConcatNC</TD><TD>NCurve<SUP>+</SUP></TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ConcatNC Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="concatncattrprop"></A> <A NAME="concatncp"></A> ConcatNCAttr Property</H4>

<P>The following parameters control the concatenation process:
<UL>
<LI>Using <CODE>"Closed"</CODE> a closed concatenated curve may be created,
even if the parameter curves do not touch.
If also <CODE>"FillGaps"</CODE> (see below) is enabled, an additional fillet will
be created for the last and the first child curve to close
the concatenated curve. If <CODE>"FillGaps"</CODE> is not enabled,
the concatenated curve will be closed with the same algorithm
that is also used by the close curve tool (possibly changing
its shape).
</LI>
<LI>If <CODE>"Revert"</CODE> is enabled, the orientation of the concatenated
curve will be reversed.
</LI>
<LI><CODE>"FillGaps"</CODE> creates fillet curves for all gaps between
the parameter curves of the ConcatNC object. No fillet will be created
if the end points of two parameter curves match.

<P>The fillet curves will initially be created from four control
points. The outer fillet control points are the parameter curve end points
and the inner fillet control points will be positioned on the tangent
of the respective parameter curve end point (see also the discussion
of <CODE>"FTLength"</CODE> below). Thus, the transitions between parameter
curve and fillet should be at least G1 continuous.
Degree elevation will be used to raise the degree of the fillet to
that of the concatenated curve; this may introduce additional
control points in the fillet but its shape does not change and the
transition continuity is also not affected.</P>
<P>If the order of the resulting concatenated curve is 2, only simple
fillets, connecting the parameter curves by straight lines, will
be generated.</P>

</LI>
<LI><CODE>"FTLength"</CODE> determines the distance of the inner fillet
control points from their respective end points. This value can
be adapted for smaller/larger gaps between parameter
curves.

If the <CODE>"FTLength"</CODE> parameter is 0.0, C1 continuous fillets will
be created by global curve interpolation instead of the G1 fillets
outlined above.
</LI>
<LI><CODE>"Knot-Type"</CODE> sets the knot type of the concatenated curve:
<UL>
<LI>If <CODE>"Knot-Type"</CODE> is <CODE>"NURB"</CODE> a simple knot vector
with equidistant knots is generated, which leads to a concatenated curve
that does not exactly preserve the shapes of the original curves if any
of the parameter curves has a custom knot vector with non equidistant knots.
Furthermore, all transitions between parameter curves are always smoothed
out.
</LI>
<LI>If <CODE>"Knot-Type"</CODE> is <CODE>"Custom"</CODE>, the knot vector is composed from
the knot vectors of the original curves, and thus, their
shapes may be preserved completely. Note, that potential discontinuities
of any level, even gaps between the parameter curves are also fully
preserved.
<P>However, this comes at the price of internal multiple knots. A problem
with these knots is, that the resulting curve is <EM>not</EM> differentiable
in these places anymore, which in turn can be problematic for operations
like sweeps.</P>
</LI>
</UL>
</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the created NURBS curve.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The concatenated curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ConcatNC objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="extrncobj"></A> ExtrNC (Extract NURBS Curve) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/extrnc.gif" HEIGHT=209 WIDTH=555  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Extracted Curves (white) from Arbitrarily Shaped Surface (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The ExtrNC object extracts a NURBS curve from a NURBS patch object,
for use as parameter object for other tool objects, like
e.g.&nbsp;Revolve (see image above).
It also works with NURBS patch providing objects, so that
the following example hierarchy is valid:
<BLOCKQUOTE><CODE>
<PRE>
|-NPatch   &lt;-------------------------.
+-Skin                               |
  +-ExtrNC                           |
  | \-Instance_of_NPatch(Instance) --'
  \-NCurve
</PRE>
</CODE></BLOCKQUOTE>

Depending on the parameters of the ExtrNC object, the Skin object
above will have one boundary in common with a boundary or an iso-curve
of the NPatch object.
Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNC object. Therefore, the main menu entry
<CODE>"Tools/Create/ExtrNC"</CODE>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNC object.</P>
<P>As the geometry of the extracted curve is completely defined by
the master surface, ExtrNC objects do not support own transformation
attributes.<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Note that the extraction of any curves currently completely ignores
potentially present trimming information of the NPatch object, i.e.&nbsp;the
extracted curves will not be trimmed.<BR>
However, complete trim boundaries may be
extracted.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The following table briefly lists some capabilities of the ExtrNC object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ExtrNC</TD><TD>NPatch</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ExtrNC Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> <A NAME="extrncattrprop"></A> <A NAME="extrncp"></A> ExtrNCAttr Property</H4>

<P>The extraction process is controlled by the following attributes:
<UL>
<LI><CODE>"Side"</CODE> controls which curve should be extracted from the
surface.
Available values are:
<UL>
<LI><CODE>"U0"</CODE>, <CODE>"Un"</CODE>: extract upper or lower
boundary curve (along width);</LI>
<LI><CODE>"V0"</CODE>, <CODE>"Vn"</CODE>: extract left or right
boundary curve (along height);</LI>
<LI> <CODE>"U"</CODE>, <CODE>"V"</CODE>
extract curve along width and height respectively at specified parametric
value (see below).<SMALL TITLE="Since 1.8.1."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI><CODE>"Boundary"</CODE>: extract the complete boundary curve of the
patch, by extracting four boundary curves, automatically selecting the
proper method depending on the knot type of the surface
(e.g.&nbsp;<CODE>"U0"</CODE> or <CODE>"U"</CODE>), reversing two and concatenating all non
degenerated curves to the result.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
Note that if the surface has differing orders, the partial curves in the
direction with the lower order will be elevated to the higher order before
concatenation and therefore those parts of the resulting boundary curve will
<EM>not</EM> be compatible to the underlying surface anymore.</LI>
<LI><CODE>"Middle_U"</CODE>, <CODE>"Middle_V"</CODE>: create a curve from the patch
data that is the "middle axis" (simply the medium of all control points
of a patch in the designated
dimension).<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
This option is e.g.&nbsp;useful to re-engineer swept surfaces, delivered
as simple patches.</LI>
<LI><CODE>"Trim"</CODE>, all trim curves and loops of the current patch will
appear here.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Note, that their extraction will result in an approximation
of the 3D representation of the corresponding trim boundary only. In
particular, the extracted curve will not be compatible to the trim curve.
The approximation quality can be adjusted using <CODE>"Parameter"</CODE> (see below).</LI>
</UL>

Note that if <CODE>"Side"</CODE> is <CODE>"U0"</CODE>, <CODE>"Un"</CODE>, <CODE>"V0"</CODE>, or <CODE>"Vn"</CODE>
the extraction process just copies the respective boundary control points,
which is fast but only works correctly for clamped knot vectors. To extract
a boundary from a surface with e.g.&nbsp;a B-Spline knot vector, <CODE>"U0"</CODE> should
<EM>not</EM> be used but rather <CODE>"U"</CODE> with <CODE>"Parameter"</CODE> set to 0.0 and
<CODE>"Relative"</CODE> enabled as <CODE>"U"</CODE> uses a different, more expensive,
extraction process (which involves knot insertion).
</LI>
<LI><CODE>"Parameter"</CODE> controls the parametric value in U or V
direction in the parameter space of the NURBS patch object where the
curve should be extracted or the approximation quality of extracted
trim curves. Consequently, this parameter is only used when <CODE>"Side"</CODE>
is <CODE>"U"</CODE>, <CODE>"V"</CODE> or <CODE>"Trim"</CODE>.
The valid range of parameter values depends
on the knot vectors of the NURBS patch.<BR>
If a trim boundary is to be extracted, this parameter controls the
sampling just like the preference setting <CODE>"Drawing/Tolerance"</CODE>:
smaller values lead to dense sampling and higher quality, the useful
range of values is 0.01 to 100.
</LI>
<LI><CODE>"Relative"</CODE> controls whether or not the parametric value delivered
via <CODE>"Parameter"</CODE> above should be interpreted in a relative way.
If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector&thinsp;/&thinsp;surface,
regardless of the actual knot values, and the valid range
for <CODE>"Parameter"</CODE> is
then consequently 0.0-1.0.<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
</LI>
<LI><CODE>"Revert"</CODE> immediately reverts the extracted curve.
</LI>
<LI><CODE>"CreatePVN"</CODE> controls creation of a PV or NT tag that contains
just the normals or normals and tangents on the surface.
These tags can then be used to e.g.&nbsp;control a 3D offset curve.
The normals and tangents will be derived from the surrounding
surface control points except for trim boundary extraction where
the underlying surface will be evaluated exactly.

Note that the tag will be present on provided/converted curve objects only.

When extracting a middle axis, this option is ignored.
</LI>
<LI><CODE>"PatchNum"</CODE> allows to select a patch from a list of
patches delivered e.g.&nbsp;by a beveled Extrude object as child
of the ExtrNC object.
This way it is possible to extract a curve from a bevel or cap
surface of e.g.&nbsp;said Extrude object.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the extracted NURBS curve.</LI>
</UL>
</P>
<P>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The extracted curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ExtrNC objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="offsetncobj"></A> OffsetNC (Offset NURBS Curves) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/offnc.gif" HEIGHT=256 WIDTH=513  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Offset Curves (white) from NURBS Curves (blue) with Offset 0.2, -0.2, and 0.3</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The OffsetNC object creates offset curves from planar NURBS curves using
four different algorithms.<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
See also the image above.</P>
<P>The offset curve will always match the original curve in type, length, order,
and knots. No attempt is made to prevent collisions or self intersections.
Rational curves are not supported well.</P>
<P>The available offset algorithms are:</P>
<P><B><CODE>Point</CODE></B><BR>
offsets each control point along the normal derived from the surrounding
control points; the offset curve created by this algorithm may come too
near the original curve at sharp convex features whose exact forms are
not preserved well either,</P>
<P><B><CODE>Section</CODE></B><BR>
this algorithm offsets all control polygon sections in the direction of their
normal and places new control points at intersection points of the lines
defined by the offset sections; this algorithm is better in avoiding self
intersections of the offset curve but the offset curve may be too far away
from the original curve at sharp convex or concave features
(regions of high curvature),</P>
<P><B><CODE>Hybrid</CODE></B><BR>
this algorithm offsets the curve two times using the Point and Section
algorithms and then mixes the results so that the bad
features of the two algorithms cancel out each
other,<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P><B><CODE>3DPVN</CODE></B>&thinsp;<SMALL TITLE="Since 1.18."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
this algorithm
creates true three dimensional offsets from non planar curves using
a primitive variable tag that contains normal information for the curve
(vertex normals). Such tags can be created manually or automatically
e.g.&nbsp;when extracting curves from surfaces using the <CODE>"ExtrNC"</CODE> object.</P>
<P><B><CODE>3DPVNB</CODE></B><BR>
Three dimensional offset like <CODE>3DPVN</CODE> above, but offsets in the
direction of the binormal.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>As the geometry of the offset curve is completely defined by the master
curve and the offset parameter, OffsetNC objects do not support own
transformation attributes.<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The <CODE>"Bevel3D"</CODE> offset algorithm has been removed since Ayam 1.19.</P>


<P>The following table briefly lists some capabilities of the OffsetNC object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
OffsetNC</TD><TD>NCurve</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">OffsetNC Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="offsetncattrprop"></A> <A NAME="offsetncp"></A> OffsetNCAttr Property</H4>

<P>The following parameters control the offsetting process:
<UL>
<LI>The first parameter <CODE>"Mode"</CODE> determines, which algorithm
to use for the offsetting process.
</LI>
<LI>Using <CODE>"Revert"</CODE> the direction of the offset curve may be reversed.
</LI>
<LI><CODE>"Offset"</CODE> determines the distance between original curve and
offset curve. Negative values are allowed.
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NCInfo"</CODE> field informs about the actual configuration
of the created NURBS curve.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The offset curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>OffsetNC objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<H2><A NAME="surfaces"></A> <A NAME="ss4.6">4.6</A> <A HREF="ayam.html#toc4.6">Freeform Surface Objects</A>
</H2>

<P>These objects enable direct manipulation of freeform surfaces.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="npatchobj"></A> NPatch (NURBS Patch) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/npatch.gif" HEIGHT=248 WIDTH=450  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">NURBS Patch: Surface (blue) from Control Polygon (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The NPatch object allows to model NURBS surfaces in a direct way, e.g.&nbsp;by
modifying control points (see also the image above). Note that using
NPatch objects should be seen as last resort, only to be used when the
flexibility of all the NURBS surface creating tool objects is not
sufficient to achieve a certain shape.</P>
<P>Like NCurve objects, NPatch objects mark their last control point with
a small arrow. Note that the arrow points in the V direction (height).</P>
<P>NPatch objects also support the concept of multiple points, see section
<A HREF="#ncurvemp">Multiple Points</A>
for more information regarding this.<SMALL TITLE="Since 1.10."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The following table briefly lists some capabilities of the NPatch object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
NPatch</TD><TD>NCurve<SUP>+</SUP>/&thinsp;Level<SUP>+</SUP></TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">NPatch Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>NPatch objects may be created via the toolbox, the main menu, some tools
as documented in section 
<A HREF="ayam-5.html#sctools">Surface Creation Tools</A>,
or the scripting interface, see
also 
<A HREF="ayam-6.html#sccrtnp">Creating Objects</A>.</P>
<P>Tools that process NPatch objects are documented in section
<A HREF="ayam-5.html#smtools">Surface Modification Tools</A>.</P>

<H4><A NAME="s3"></A> <A NAME="npatchattrprop"></A> <A NAME="npattr"></A> NPatchAttr Property</H4>

<P>The first section of the NPatchAttr property contains patch specific
settings:
<UL>
<LI><CODE>"Width"</CODE> and <CODE>"Height"</CODE> control the dimensions of the patch.
Similar to the <CODE>"Length"</CODE> parameter of the NCurve object, changes to
<CODE>"Width"</CODE> or <CODE>"Height"</CODE> add or remove internal control points
(i.e.&nbsp;to double the resolution of a 4 by 4 NURBS patch in U direction,
change the <CODE>"Width"</CODE> from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).
</LI>
<LI><CODE>"Order_U"</CODE> and <CODE>"Order_V"</CODE> set the orders of the patch.
</LI>
<LI><CODE>"Knot-Type_U"</CODE>/<CODE>"Knot-Type_V"</CODE> and
<CODE>"Knots_U"</CODE>/<CODE>"Knots_V"</CODE>: For a discussion of the
<CODE>"Knot-Type"</CODE> and <CODE>"Knots"</CODE> parameters,
please see section 
<A HREF="#ncattr">NCurveAttr</A>.
</LI>
<LI><CODE>"CreateMP"</CODE> toggles, whether multiple points should be
created for this surface. See also the discussion in
section
<A HREF="#ncurvemp">Multiple Points</A>.<SMALL TITLE="Since 1.10."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
</LI>
<LI><CODE>"IsRat"</CODE> informs, whether the patch
is rational (has any weight values different from
1.0).<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
</UL>
</P>
<P>The next parameters control the appearance of the patch for display
in Ayam:
<UL>
<LI><CODE>"Tolerance"</CODE> is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<CODE>"Drawing/Tolerance"</CODE> should be used.
</LI>
<LI><CODE>"DisplayMode"</CODE> sets the display mode, either the control
hull is drawn (<CODE>"ControlHull"</CODE>), or just the outlines of the polygons
created by the tesselation (<CODE>"OutlinePolygon"</CODE>), or just the
outlines of the patch (<CODE>"OutlinePatch"</CODE>). The default setting
(<CODE>"Global"</CODE>) means, that the value of the global preference setting
<CODE>"Drawing/NPDisplayMode"</CODE> should be used instead.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> <A NAME="trim"></A> Trim Curves</H4>

<P>
<CENTER>
<IMG SRC="pics/tnpatch.gif" HEIGHT=267 WIDTH=431  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">A Trimmed NURBS Patch</FONT></CENTER><P><CENTER>
</CENTER>

Trim curves may be used to cut out certain parts of a NURBS patch (see
also the image above).
They are simple 2D NURBS curves defined in the parametric space
of the associated NURBS patch. Trim curves have to be defined as child
objects of the NURBS patch object they belong to. In contrast to other
child objects, however, they do not inherit the transformation attributes
of the parent object. Trim curve editing can take place in views
of type <CODE>"Trim"</CODE>, that draw the boundaries of the parametric
space of the corresponding NURBS patch as rectangle, but otherwise
act as normal <CODE>"Front"</CODE> views.</P>
<P>Note that the direction of the trim curve determines which part of
the NURBS patch should be cut out. The <CODE>Revert</CODE> tool
(<CODE>"Tools/Curve"</CODE> menu) can be used to easily change the direction
of a trim curve.</P>
<P>Some special restrictions apply to trim curves:
<UL>
<LI>All trim curves should entirely lie in the (u,v) parameter
space of the NURBS patch (remember the rectangle in the <CODE>Trim</CODE> view).
Note that this restriction does not apply to the control points,
but the curves! It is ok to have control points outside the
rectangle if the defined curve is inside the rectangle.
</LI>
<LI>The last point of a trim curve must be identical
to the first point.
</LI>
<LI>Trim loops (multiple trim curves that form loops) are possible too;
the last point of each curve in the loop must be identical to the first
point of the next curve in the loop and the first point of the first curve
of a loop must be identical to the last point of the last curve of that
loop.
</LI>
<LI>To mark a set of curves to be a loop, they must be placed in a level
object. The order of the curves in this level is the order of the loop.
The transformation attributes of this level object are fully ignored for
trimming.
</LI>
<LI>Drawing trimmed NURBS patches with certain implementations of
OpenGL may require a special trim curve (a rectangular piecewise linear
curve that encloses the whole NURBS patch) to be present. Such a curve
may be generated with the <CODE>TrimRect</CODE> tool. This tool can be found in
the <CODE>"Tools/Create"</CODE> menu. This curve is needed if you want to cut
out a hole with a single trim curve. This curve is generally not needed
if you want to render the patch with BMRT but it should not hurt if it
is present.
</LI>
<LI>If there are nested trim curves, their direction must alternate.
</LI>
<LI>Trim curves may not intersect each other or them self.</LI>
</UL>

Note that Ayam is not checking whether the trim curves
follow these rules.</P>
<P>Warning: Certain OpenGL implementations may be easily crashed
drawing trimmed NURBS patches with trims that do not follow the
aforementioned rules. When in doubt or while heavy modelling,
switch to wire-frame drawing and switch off shading temporarily
and you will be on the safe side.</P>
<P>NURBS curve providing objects are also supported as trim
curves.<SMALL TITLE="Since 1.5."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
When objects provide multiple NURBS curves, those do <EM>not</EM>
form a single loop, but are seen as individual loops.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The NPatch object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>
<P>Integration is not supported; the corresponding option is silently
ignored.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>A NPatch object may be converted to a PolyMesh object using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>This process is also called tesselation and thus, the tesselation
parameters from TP tags will be used in the conversion process (if present)
(see also section 
<A HREF="#tptag">TP Tag</A>).</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the tesselated bevels or caps follow the tesselated NPatch in the
following order: U0, U1, V0, V1.</P>



<H4><A NAME="s3"></A> RIB Export</H4>

<P>NPatch objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are supported and also trim curves may appear.</P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ipatchobj"></A> IPatch (Interpolating Patch) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/ipatch.gif" HEIGHT=248 WIDTH=450  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Interpolating surface (blue) from data points (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>An IPatch forms a surface defined by interpolating a regular grid
of three dimensional and non rational data points (see also the
image above).</P>
<P>The following table briefly lists some capabilities of the IPatch object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
IPatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">IPatch Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>IPatch objects may be created via the main menu or the
scripting interface, see also 
<A HREF="ayam-6.html#sccrtip">Creating Objects</A>.</P>

<H4><A NAME="s3"></A> <A NAME="ipatchattrprop"></A> <A NAME="ipattr"></A> IPatchAttr Property</H4>

<P>The IPatchAttr property contains the following elements:
<UL>
<LI><CODE>"Width"</CODE> and <CODE>"Height"</CODE> control the dimensions of the patch.
Similar to the <CODE>"Length"</CODE> parameter of the NCurve object, changes to
<CODE>"Width"</CODE> or <CODE>"Height"</CODE> add or remove internal control points
(i.e.&nbsp;to double the resolution of a 4 by 4 interpolating patch in U direction,
change the <CODE>"Width"</CODE> from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).
</LI>
<LI><CODE>"Order_U"</CODE> and <CODE>"Order_V"</CODE> set the desired interpolation
orders of the patch. If any of these values is set to 2, no explicit
interpolation will take place in this dimension (the surface will
implicitly interpolate the data points due to the low order).
</LI>
<LI><CODE>"Close_U"</CODE> and <CODE>"Close_V"</CODE> allow to create closed
surfaces in the respective dimension.
</LI>
<LI><CODE>"Knot-Type_U"</CODE> and <CODE>"Knot-Type_V"</CODE> switches the parameterisation
between <CODE>"Chordal"</CODE> (default), <CODE>"Centripetal"</CODE>, and <CODE>"Uniform"</CODE>.
The centripetal method generates a better parameterisation than
the default (chordal) if the input data contains sharp turns.
The uniform method generates worse parameterisations (that lead to
wiggles and overshooting)
in the general case but it might help in some edge cases.
</LI>
<LI><CODE>"Deriv_U"</CODE> and <CODE>"Deriv_V"</CODE> toggle whether

<UL>
<LI><CODE>"None"</CODE>: no end derivatives,
</LI>
<LI><CODE>"Automatic"</CODE>: automatically created (from data points)
derivatives, scaled by the additional parameters
<CODE>"SDLen_U"</CODE>, <CODE>"EDLen_U"</CODE>, <CODE>"SDLen_V"</CODE>, and<CODE>"EDLen_V"</CODE>,
</LI>
<LI><CODE>"Manual"</CODE>: completely manually controlled end derivatives
(appearing as additional control points in point editing, if enabled)</LI>
</UL>

should be used in the interpolation.</LI>
</UL>
</P>
<P>The next parameters control the appearance of the patch for display
in Ayam:
<UL>
<LI><CODE>"Tolerance"</CODE> is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<CODE>"Drawing/Tolerance"</CODE> should be used.
</LI>
<LI><CODE>"DisplayMode"</CODE> sets the display mode, either the control
hull is drawn (<CODE>"ControlHull"</CODE>), or just the outlines of the polygons
created by the tesselation (<CODE>"OutlinePolygon"</CODE>), or just the
outlines of the patch (<CODE>"OutlinePatch"</CODE>). The default setting
(<CODE>"Global"</CODE>) means, that the value of the global preference setting
<CODE>"Drawing/NPDisplayMode"</CODE> should be used instead.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NPInfo"</CODE> field informs about the actual configuration
of the created NURBS patch.</LI>
</UL>
</P>
<P>See also the related tool to create interpolating NURBS surfaces:
<A HREF="ayam-5.html#interpnpt">Interpolate Surface Tool</A>.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The IPatch object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The interpolated surface may be converted to an ordinary NURBS patch
using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>IPatch objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are currently not supported.</P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="apatchobj"></A> APatch (Approximating Patch) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/apatch.gif" HEIGHT=244 WIDTH=439  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Approximating surface (blue) from data points (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>An APatch forms a surface defined by approximating a regular grid
of three dimensional and non rational data points (see also the
image above).<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
The approximation will occur first in U then in V direction,
first in V then in U direction, just in U, or just in V direction.</P>
<P>The following table briefly lists some capabilities of the APatch object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
APatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">APatch Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>APatch objects may be created via the main menu or the
scripting interface, see also 
<A HREF="ayam-6.html#sccrtap">Creating Objects</A>.</P>

<H4><A NAME="s3"></A> <A NAME="apatchattrprop"></A> <A NAME="apattr"></A> APatchAttr Property</H4>

<P>The APatchAttr property contains the following elements:
<UL>
<LI><CODE>"Width"</CODE> and <CODE>"Height"</CODE> control the number of data
points of the patch to approximate.
Similar to the <CODE>"Length"</CODE> parameter of the NCurve object, changes to
<CODE>"Width"</CODE> or <CODE>"Height"</CODE> add or remove internal control points
(i.e.&nbsp;to double the resolution of a 4 by 4 interpolating patch in U direction,
change the <CODE>"Width"</CODE> from 4 to 7; this will lead to an additional
control point inserted into every section of the original patch).
</LI>
<LI><CODE>"Mode"</CODE> determines the order in which the partial approximations
occur.
</LI>
<LI><CODE>"AWidth"</CODE> and <CODE>"AHeight"</CODE> set the desired number of
NURBS control points. Both values must be smaller or equal to
<CODE>"Width"</CODE> and <CODE>"Height"</CODE> respectively.
</LI>
<LI><CODE>"Order_U"</CODE> and <CODE>"Order_V"</CODE> set the desired approximation
orders of the patch.
</LI>
<LI><CODE>"Knot-Type_U"</CODE> and <CODE>"Knot-Type_V"</CODE> switches the parameterisation
between <CODE>"Chordal"</CODE> (default) and <CODE>"Centripetal"</CODE>.
The centripetal method generates a better parameterisation than
the default (chordal) if the input data contains sharp turns.
If the approximation mode is <CODE>"U"</CODE> or <CODE>"V"</CODE> more knot types will
be available for the dimension where no approximation occurs.
Those knot types are: <CODE>"Bezier"</CODE>, <CODE>"B-Spline"</CODE>, and <CODE>"NURB"</CODE>.
See section 
<A HREF="#ncattr">NCurveAttr Property</A> for their
documentation.
</LI>
<LI><CODE>"Close_U"</CODE> and <CODE>"Close_V"</CODE> allow to create closed
surfaces in the respective dimension.
</LI>
</UL>
</P>
<P>The next parameters control the appearance of the patch for display
in Ayam:
<UL>
<LI><CODE>"Tolerance"</CODE> is in fact the GLU sampling tolerance used to
control the quality of the sampling when rendering the patch.
Smaller tolerance settings lead to higher quality but also
slower display.
A setting of 0.0 means, that the global preference setting
<CODE>"Drawing/Tolerance"</CODE> should be used.
</LI>
<LI><CODE>"DisplayMode"</CODE> sets the display mode, either the control
hull is drawn (<CODE>"ControlHull"</CODE>), or just the outlines of the polygons
created by the tesselation (<CODE>"OutlinePolygon"</CODE>), or just the
outlines of the patch (<CODE>"OutlinePatch"</CODE>). The default setting
(<CODE>"Global"</CODE>) means, that the value of the global preference setting
<CODE>"Drawing/NPDisplayMode"</CODE> should be used instead.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NPInfo"</CODE> field informs about the actual configuration
of the created NURBS patch.</LI>
</UL>
</P>
<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The APatch object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The approximating surface may be converted to an ordinary NURBS patch
using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>APatch objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are currently not supported.</P>
<P>Multiple TC tags are also supported.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bpatchobj"></A> BPatch (Bilinear Patch) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/bpatch.gif" HEIGHT=220 WIDTH=240  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Bilinear Patch</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>A BPatch is a simple bilinear patch defined by four control
points. BPatch objects are e.g.&nbsp;used internally to build box objects,
see also 
<A HREF="#boxobj">Box Object</A>.</P>
<P>The following table briefly lists some capabilities of the BPatch object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
BPatch</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">BPatch Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="bpatchattrprop"></A> <A NAME="bpattr"></A> BPatchAttr Property</H4>

<P>The BPatchAttr property allows to directly control the
four points defining the geometry of the patch:
<UL>
<LI><CODE>"P1_X"</CODE>, <CODE>"P1_Y"</CODE>, <CODE>"P1_Z"</CODE>, first point.</LI>
<LI><CODE>"P2_X"</CODE>, <CODE>"P2_Y"</CODE>, <CODE>"P2_Z"</CODE>, second point.</LI>
<LI><CODE>"P3_X"</CODE>, <CODE>"P3_Y"</CODE>, <CODE>"P3_Z"</CODE>, third point.</LI>
<LI><CODE>"P4_X"</CODE>, <CODE>"P4_Y"</CODE>, <CODE>"P4_Z"</CODE>, fourth point.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The bilinear patch may be converted to an ordinary NURBS patch
using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>BPatch objects will be exported as bilinear patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiPatch(RI_BILINEAR, ...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are supported.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="patchmeshobj"></A> PatchMesh Object</H3>

<P>
<CENTER>
<IMG SRC="pics/pamesh.gif" HEIGHT=242 WIDTH=655  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Bicubic (left) and Bilinear (right) PatchMesh Surfaces (blue) from their Respective Control Polygons (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The PatchMesh object may be used to model with bicubic and
bilinear patch meshes, see the image above for two examples.</P>
<P>Like NCurve objects, PatchMesh objects mark their last control point with
a small arrow. Note that the arrow points in the V direction (height).</P>
<P>The following table briefly lists some capabilities of the PatchMesh object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
PatchMesh</TD><TD>No</TD><TD>Yes</TD><TD>NPatch</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">PatchMesh Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="patchmeshattrprop"></A> <A NAME="pmattr"></A> PatchMeshAttr Property</H4>

<P>The first section of the PatchMeshAttr property contains patch specific
settings:
<UL>
<LI><CODE>"Type"</CODE> may be set to <CODE>"Bicubic"</CODE> or <CODE>"Bilinear"</CODE>.</LI>
<LI><CODE>"Width"</CODE> and <CODE>"Height"</CODE> control the dimensions of the patch.
Note that for bicubic patch meshes, the basis type may impose restrictions
on the valid values for width and height; e.g.&nbsp;for the
basis type <CODE>"Bezier"</CODE> (with step size 3) valid values are: 4, 7,
10, .... Another basis type that imposes this restriction is
<CODE>"Hermite"</CODE> (with step size 2), where valid values are: 4, 6,
8, ....<BR>
Closing the surface complicates the matter a bit further. A valid
width for a closed bicubic patch mesh of basis type <CODE>"Bezier"</CODE> is e.g.&nbsp;6;
it is actually still 7, but the last point is equal to the first and
will be omitted.<BR>
The arrow buttons of the dimension entry fields add/subtract the current
step size of the patch to/from the respective value when the
<CODE>&lt;Control&gt;</CODE> key is held down.<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
</LI>
<LI><CODE>"Close_U"</CODE> and <CODE>"Close_V"</CODE> determine, whether the patch
mesh should be closed in U and V direction respectively.</LI>
<LI><CODE>"IsRat"</CODE> informs, whether the patch mesh
is rational (has any weight values different from
1.0).<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI><CODE>"BType_U"</CODE> and <CODE>"BType_V"</CODE> control the basis type
for bicubic patches. The following basis types are available:
<CODE>"Bezier"</CODE>, <CODE>"B-Spline"</CODE>, <CODE>"Catmull-Rom"</CODE>,
<CODE>"Hermite"</CODE>, <CODE>"Power"</CODE>, and <CODE>"Custom"</CODE>.
In the latter case (<CODE>"Custom"</CODE>), additional parameters may be set.
Those are <CODE>"Step_U"</CODE>/<CODE>"Step_V"</CODE> (the step size of the basis) and
<CODE>"Basis_U"</CODE>/<CODE>"Basis_V"</CODE> the basis itself.<BR>
When a basis type is changed to <CODE>"Custom"</CODE>, the
initial values of the basis matrix will be of those of
the previous type.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
Also note, that changing a basis type via the property GUI is not the
same as converting a patch mesh via the <CODE>tobasisPM</CODE> command,
see also section 
<A HREF="ayam-6.html#sctobasispm">tobasisPM command</A>.<BR>
Please see the RenderMan Companion for a more in depth discussion of
the different basis types.</LI>
</UL>

The parameters <CODE>"BType_U"</CODE>, <CODE>"BType_V"</CODE>, <CODE>"Step_U"</CODE>,
<CODE>"Step_V"</CODE>, <CODE>"Basis_U"</CODE>, and <CODE>"Basis_V"</CODE> are
only available to bicubic patch meshes.</P>
<P>The next parameters control the appearance of the patch for display
in Ayam:
<UL>
<LI><CODE>"Tolerance"</CODE> is in fact GLU sampling tolerance, used to
control the quality of the sampling when rendering the patch.
A setting of 0.0 means, that the global preference setting
<CODE>"Drawing/Tolerance"</CODE> should be used.</LI>
<LI><CODE>"DisplayMode"</CODE> sets the display mode, either the control
hull is drawn, or just the outlines of the polygons created by
the tesselation (OutlinePolygon), or just the
outlines of the patch (OutlinePatch). The default setting
(Global) means, that the global preference setting
<CODE>"Drawing/DisplayMode"</CODE> should be used.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The PatchMesh object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>
.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The patch mesh may be converted to an ordinary NURBS patch
using the main menu entry <CODE>"Tools/Convert"</CODE>.
In Ayam versions prior to 1.21, conversion (and shaded display)
did not work for patch meshes with the basis types Catmull-Rom, Hermite,
or Custom. This is no longer the case.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>PatchMesh objects will be exported as patch mesh primitives:
<BLOCKQUOTE><CODE>
<CODE>RiPatchMesh(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are supported.</P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<H2><A NAME="stobjs"></A> <A NAME="ss4.7">4.7</A> <A HREF="ayam.html#toc4.7">Surface Tool Objects</A>
</H2>

<P>These objects create freeform surfaces from curves or other surfaces.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="revolveobj"></A> Revolve Object</H3>

<P>
<CENTER>
<IMG SRC="pics/revolve.gif" HEIGHT=274 WIDTH=320  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Revolve Object (left: Curve, right: Surface of Revolution)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Revolve object forms a surface of revolution from a NURBS curve,
see the image above for an example.</P>
<P>The Revolve object has the generating NURBS curve as child object
and watches its changes and adapts to it automagically.</P>
<P>The axis of revolution is always the Y-axis.
The parameter curve should be defined in the XY-plane.
If not, the curve will be projected to this plane before revolving.</P>
<P>The following table briefly lists some capabilities of the Revolve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Revolve</TD><TD>NCurve</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Revolve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="revolveattrprop"></A> <A NAME="rep"></A> RevolveAttr Property</H4>

<P>The parameter <CODE>"ThetaMax"</CODE> specifies the
sweeping angle of the revolution just like for an ordinary
RenderMan quadric primitive.</P>
<P>The Revolve object also supports a B-Spline mode
that may be enabled by setting the parameter <CODE>"Sections"</CODE>
to a value higher than 0.<SMALL TITLE="Since 1.8."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>In this mode, a circular B-Spline is
used as basis for the surface of revolution instead of the
standard NURBS circle. Depending on the number of sections
chosen, the surface of revolution does not exactly interpolate
the parameter curve, but the surface may be edited more easily
after a possible conversion to an ordinary NURBS patch object,
because the control points will not be rational if the revolved
curve is also not rational.<BR>
Note that also the B-Spline mode can realize arbitrary
<CODE>"ThetaMax"</CODE> values.<SMALL TITLE="Since 1.18."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>In addition to the number of sections, in B-Spline mode it is
possible to control the order of the surface of revolution
using the parameter <CODE>"Order"</CODE>. If <CODE>"Order"</CODE> is 0,
a standard value of 3 will be used.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Revolve object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Upper</CODE> &ndash; curve formed by revolving the start
point of the cross section,<BR>
<CODE>Lower</CODE> &ndash; curve formed by revolving the
end point of the cross section,<BR>
<CODE>Start</CODE> &ndash; cross section, and<BR>
<CODE>End</CODE> &ndash; cross section at end of revolution.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The surface of revolution and the bevels and caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels or caps follow the surface of revolution in the following
order: upper, lower, start, end.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Revolve object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Revolve objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If bevels or caps are present, those follow as potentially trimmed NURBS
patch primitives in the following order: upper, lower, start, end.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="extrudeobj"></A> Extrude Object</H3>

<P>
<CENTER>
<IMG SRC="pics/extrude.gif" HEIGHT=143 WIDTH=381  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Extrude Object (left: Curve, middle: normal Extrusion,
right: Extrusion with Caps)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Extrude object forms a linear extrusion from a number of planar NURBS
curves, see the image above for an example.</P>
<P>The first curve determines the outline and the other curves determine
holes in the extrusion object. Holes may be used by objects that form
e.g.&nbsp;letters.</P>
<P>The object has the generating NURBS curves as child objects,
watches them and adapts to them automagically.</P>
<P>Consequently, the object hierarchy of an Extrude object may look like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Extrude
  |-Outline(NCurve)
  |-[Hole_1(NCurve)
  | ...
  \-Hole_n(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The Extrude object can generate caps, if the generating
curves are closed. Cap generation may fail, if the outer
curve has weights and the curve itself leaves the convex
hull of the control polygon. Be careful when using curves
with weights!</P>
<P>The sharp corners between caps and extrusion may be beveled.</P>
<P>The axis of the extrusion is always the Z-axis.
The parameter curves should be defined in the XY-plane.
If not, they will be squashed down to this plane.
See section
<A HREF="ayam-5.html#toxyt">To XY Tool</A> for information on
how to easily achieve curves in the XY-plane.</P>
<P>The dimensions and orders of the extruded surface(s) will be taken from the
respective parameter curves as follows: width and order in U direction
will be 2, height and order in V direction are taken from the parameter
curve.</P>
<P>The following table briefly lists some capabilities of the Extrude object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Extrude</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Extrude Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> <A NAME="extrudeattrprop"></A> <A NAME="extrattr"></A> ExtrudeAttr Property</H4>

<P>The parameter <CODE>"Height"</CODE> determines how
big in Z direction the extrusion should be. Note that
the height of the bevels will not be taken into account here,
if the extrusion height is 1.0 and beveling (upper and lower) is
switched on with radius 0.1 the resulting object extends 1.2 units in
Z direction.</P>
<P>The Extrude object can automatically generate caps,
that are trimmed NURBS patches. Using <CODE>"StartCap"</CODE> and
<CODE>"EndCap"</CODE> you determine whether such caps should be generated,
default is off (no caps). Note that this feature does only work
properly, if the generating NURBS curves are closed and not self
intersecting, this is because the generating curves themselves are
used as trim curves for the caps. Warning, Ayam will not check whether
the parameter curves conform to these criteria. Ayam, however,
automatically detects the correct orientation of the curves (and
reverts them if necessary).</P>
<P>Since Ayam 1.10 the bevel parameters of the Extrude object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <CODE>"LowerBevel"</CODE>,
<CODE>"UpperBevel"</CODE>, <CODE>"BevelType"</CODE>, and <CODE>"BevelRadius"</CODE> are no
longer available. They were replaced with new dynamic tag creating
bevel property GUI sections that are accessible through the new
command entries <CODE>"Add Start Bevel!"</CODE> and <CODE>"Add End Bevel!"</CODE>
respectively. If one of those entries is used, a corresponding bevel
parameter tag is created and more options will be made available in the
property GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section 
<A HREF="#bevelp">BevelAttr Property</A>.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>

<H4><A NAME="s3"></A> <A NAME="handb"></A> Using Holes and Bevels</H4>

<P>All curves forming holes in the extruded object must be defined inside
(geometrically) the first curve (the outline curve). Additionally,
they may not intersect each other or them self and there can not be hole
curves inside hole curves. If there are bevels and caps, allow some extra
spacing between the curves (for the bevels).
Ayam will not check whether the parameter curves conform to these criteria.</P>
<P>With the direction of the curve, the direction of the bevel is determined
as well (should it round outwards or inwards?).
If the bevels of the holes look wrong try to revert the generating
curves of the holes.
Note that beveling does not work well with open curves. It is suggested
to always use closed curves for beveling.
Beveling may lead to self intersecting trim curves in sharp corners of an
extrusion. Decrease the bevel radius or round the corners of the extruded
curve (using insertion of additional control points) if cap generation
fails due to self intersecting bevels.</P>
<P>Another special issue shall be noted: If there are holes, the
corresponding bevels will be scaled with the hole curve object
transformation values. Thus, to achieve equally sized bevels for outline
and holes, possible scale transformations should be carried out on the
hole curve control points, rather than on the hole curve object
transformation attributes.</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The extruded surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the extruded surface in the following
order: end bevel, end cap, start bevel, start cap.</P>
<P>The Extrude object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Extrude objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.</P>
<P>PV tags are supported but all NURBS patch primitives will get
the same set of tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="swingobj"></A> Swing Object</H3>

<P>
<CENTER>
<IMG SRC="pics/swing.gif" HEIGHT=270 WIDTH=436  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Swing Object (left: Curves, right: Resulting Swung Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Swing object forms a surface that results from rotating a NURBS curve
(called <EM>cross section</EM> or <EM>profile</EM>) around an axis while
scaling it according to a second NURBS curve (called <EM>trajectory</EM> or
<EM>path</EM>).<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
This process is sometimes also called <EM>rotational sweep</EM>.
See the image above for an example.</P>
<P>The Swing object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory.</P>
<P>The object hierarchy of a Swing object, thus, looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Swing
  |-Cross_Section(NCurve)
  \-Trajectory(NCurve)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The swing operation will occur around the Y-axis, i.e.&nbsp;the
trajectory should be defined in the XZ-plane.</P>
<P>The cross section curve should be defined in the YZ-plane and the
trajectory should start here. See also the image below.</P>
<P>
<CENTER>
<IMG SRC="pics/swingc.gif" HEIGHT=264 WIDTH=365  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Swing Cross Section (l), Trajectory (r), Surface (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<P>Note that the swing create tool will automatically modify the
control points of NCurve, ICurve, and ACurve objects so that they
are defined in the proper plane. For all other object types, the
transformation attributes will be set (Rotate_Y is set to
90 if currently set to 0).<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The dimensions and orders of the swung surface will be taken from the
respective parameter curves as follows: width and order in U direction
from the trajectory, height and order in V direction from the cross
section.</P>
<P>The following table briefly lists some capabilities of the Swing object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Swing</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Swing Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="swingattrprop"></A> SwingAttr Property</H4>

<P>The swung surface is completely controlled by the parameter curves.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the swung surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Swing object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; cross section,<BR>
<CODE>End</CODE> &ndash; cross section at end of sweep,<BR>
<CODE>Upper</CODE> &ndash; curve formed by sweeping the start point of the
cross section, and<BR>
<CODE>Lower</CODE> &ndash; curve formed by sweeping the end point of the
cross section.</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The swung surface and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels or caps follow the swung surface in the following
order: upper, lower, start, end.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Swing object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Swing objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If bevels or caps are present, those follow as potentially trimmed NURBS
patch primitives in the following order: upper, lower, start, end.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sweepobj"></A> Sweep Object</H3>

<P>
<CENTER>
<IMG SRC="pics/sweep.gif" HEIGHT=269 WIDTH=283  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Object (left: Curves, right: Resulting Swept Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Sweep object forms a surface that results from moving a NURBS curve
(called <EM>cross section</EM> or <EM>profile</EM>) along a second NURBS curve
(called <EM>trajectory</EM> or <EM>path</EM>).
See the image above for an example.</P>
<P>The cross section may be scaled while sweeping using a third curve, the
<EM>scaling function</EM>. Swept surfaces may be closed in the direction of the
trajectory and they may also be periodic.<SMALL TITLE="Since 1.10."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The Sweep object has the generating NURBS curves as child objects
and watches their movements and adapts to them automagically.
The first curve is the cross section, the second is the trajectory,
and the third curve represents the scaling function.</P>
<P>The object hierarchy of a Sweep object, thus, looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Sweep
  |-Cross_Section(NCurve)
  |-Trajectory(NCurve)
  \-[Scaling_Function(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Note that the <CODE>"Translate"</CODE> attributes of the cross section curve
will be fully ignored. All other transformation attributes
(of cross section and trajectory) will be used to determine
place, orientation, and size of the Sweep object.
The cross section curve has to be defined in the YZ-plane of the
Sweep objects coordinate system. See also the image below.</P>
<P>
<CENTER>
<IMG SRC="pics/sweepc.gif" HEIGHT=206 WIDTH=314  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Cross Section (l), Trajectory (r), Surface (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>This means that a simple circular
curve as e.g.&nbsp;created with the toolbox has to be rotated by 90 degrees
around the Y-axis. This can be done either by modifying the control points,
or by setting the transformation attributes accordingly.
Later editing of this curve has to be done in a Side view.
Note that the sweep create tool will automatically modify the
control points of NCurve, ICurve, and ACurve objects so that they
are defined in the proper plane. For all other object types, the
transformation attributes will be set (Rotate_Y is set to
90 if currently set to 0).<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The scaling function is sampled for each section and the Y-component
of the coordinates of the current curve point will be used as
scale factor that is applied to the cross section in Y-direction.</P>
<P>If any sample point of the scaling function has a Z-component different
from zero, the Z-component will be used to independently scale the
cross section in X-direction, otherwise the Y-component will be used
to also scale the cross section in X-direction.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>This implies, that e.g.&nbsp;a scaling function that does nothing should be
a linear curve from (0,1,1) to (1,1,1).
Scale components that are less than or equal to zero will be silently ignored.</P>
<P>
<CENTER>
<IMG SRC="pics/ssweep.gif" HEIGHT=248 WIDTH=388  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Object (blue) with Scaling Function (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Here is a short example for the creation of a sweep:
<OL>
<LI>Create a circular B-Spline curve using the toolbox. (This will be our
cross section.)</LI>
<LI>Create a simple NURBS curve using the toolbox. (This will be our
trajectory.)</LI>
<LI>Select both curves. (Select the first curve, hold down
the <CODE>"Shift"</CODE> key and select the other curve.)</LI>
<LI>Create the Sweep object using the toolbox.</LI>
<LI>Observe that the cross section curve was rotated automatically
to the YZ-plane.</LI>
<LI>Now you may enter the Sweep object and modify
e.g.&nbsp;the second curve, the trajectory. (Press <CODE>&lt;e&gt;</CODE>,
then drag some control points around.)</LI>
<LI>To modify the cross section you would need to switch to a
view of type <CODE>"Side"</CODE>. (Use the views <CODE>"Type"</CODE> menu or
the <CODE>&lt;PgDwn&gt;</CODE> keyboard shortcut while the view has the input focus.)</LI>
</OL>
</P>
<P>Section 
<A HREF="ayam-6.html#scexsweep">Easy Sweep</A> has an example
script that automates creation and parameterisation of
a suitable cross section curve.</P>
<P>Translational surfaces are a similar creation algorithm,
see also section 
<A HREF="ayam-6.html#tsurftcl">Translational Surface</A>.</P>
<P>The following table briefly lists some capabilities of the Sweep object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Sweep</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sweepattrprop"></A> <A NAME="swp"></A> SweepAttr Property</H4>

<P>The <CODE>"Type"</CODE> attribute controls whether the
swept surface should be open, closed, or periodic in the direction
of the trajectory curve.<SMALL TITLE="Since 1.10."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>If <CODE>"Interpolation"</CODE> is enabled, an additional interpolation
will be run on the swept surface in U direction so that all section
curves will be interpolated by the swept surface. Instead of a
NURBS knot vector, the swept surface will then get a
Chordal knot vector (calculated by knot averaging) and the
swept surface will follow the trajectory more closely.
See the image below for an example.</P>
<P>
<CENTER>
<IMG SRC="pics/sweepinterp.gif" HEIGHT=252 WIDTH=471  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Along a Quarter Circle without (left) and with (right) Interpolation Enabled</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The third parameter, <CODE>"Sections"</CODE>, determines how many
control points (in U direction) should be used, when generating the
sweep NURBS patch. The sweep NURBS patch has sections+1 control
points in U direction for open and closed sweeps, whereas
sections+order control points will be created for periodic sweeps.<BR>
Zero is a valid setting for the <CODE>"Sections"</CODE> parameter and used as
default value.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
In this case the number of sections is directly derived from the length
of the trajectory curve plus one (except for trajectory curves of length
2, where the number of sections is 1).<BR>
For example, if <CODE>"Sections"</CODE> is zero, for a standard NURBS curve of
length 4, the number of sections used is 5 and the width of the created
NURBS patch is 6, for a curve with just 2 control points, the number of
sections used is 1 and the width of the resulting patch is 2.
See the table below for more examples.<BR>
Moreover, if <CODE>"Sections"</CODE> is zero, the order of the sweep in U direction
is taken from the trajectory curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.</P>
<P>If <CODE>"Rotate"</CODE> is enabled, the cross sections will be
rotated so that they are always perpendicular to the trajectory,
this option is enabled by default.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the swept surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>
<P>The following table shows some example parameter configurations for
the Sweep object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Sections</B></TD><TD><B>Trajectory Length</B></TD><TD><B>Trajectory Order</B></TD><TD><B>Sweep Length</B></TD><TD><B>Sweep Order</B></TD></TR><TR><TD>
0</TD><TD>2</TD><TD>2</TD><TD>2</TD><TD>2</TD></TR><TR><TD>
0</TD><TD>5</TD><TD>4</TD><TD>6</TD><TD>4</TD></TR><TR><TD>
0</TD><TD>6</TD><TD>5</TD><TD>7</TD><TD>5</TD></TR><TR><TD>
4</TD><TD>6</TD><TD>5</TD><TD>5</TD><TD>4</TD></TR><TR><TD>
10</TD><TD>6</TD><TD>5</TD><TD>11</TD><TD>4
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Sweep Parameterisation Examples</FONT></CENTER><P><CENTER>
</CENTER>
</P>


<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Sweep object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; cross section,<BR>
<CODE>End</CODE> &ndash; cross section at end of sweep,<BR>
<CODE>Left</CODE> &ndash; curve formed by sweeping the start point of the
cross section, and<BR>
<CODE>Right</CODE> &ndash; curve formed by sweeping the end point of the
cross section.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The swept surface, the bevels and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the swept surface in the following
order: start bevel, start cap, end bevel, end cap, left bevel, left cap,
right bevel, right cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Sweep object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Sweep objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: start bevel, start cap,
end bevel, end cap, left bevel, left cap,
right bevel, right cap.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="birail1obj"></A> Birail1 Object</H3>

<P>
<CENTER>
<IMG SRC="pics/birail1.gif" HEIGHT=164 WIDTH=468  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Birail1 Object (left: Curves, right: Resulting Swept Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Birail1 object forms a surface by sweeping a <EM>cross section</EM>
(or <EM>profile</EM>) curve along two so called <EM>rail</EM> curves.
See the image above for an example.</P>
<P>The object hierarchy of a Birail1 object, thus, looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Birail1
  |-Cross_Section(NCurve)
  |-Rail1(NCurve)
  \-Rail2(NCurve)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>When the cross section touches the rail curves in their respective starting
points, the resulting surface will interpolate the rail curves.
The direction of the cross section curve will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curve and the number of sections, respectively.</P>
<P>
<CENTER>
<IMG SRC="pics/birail1vc.gif" HEIGHT=261 WIDTH=334  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Valid Configuration of Parameter Curves (white) for Birail1 (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The image above shows a valid configuration of parameter curves for
the Birail1 object. Mind the direction of the rail curves (R1 and R2)
with regard to the cross section curve (CS) and the fact that the
cross section curve touches the starting points of the rail curves.</P>
<P>Note that the cross section curve does not have to be two dimensional, and,
in contrast to the normal Sweep object, it also does not have to be
defined in a special plane. Also note that the precision with which the
resulting surface will interpolate the rail curves depends on the
number of sections chosen.</P>
<P>The Birail1 object watches the child objects and adapts to them
automatically via the notification mechanism.</P>
<P>See also section 
<A HREF="ayam-6.html#dualsweeptcl">DualSweep</A> for a script
object that creates a similar surface.</P>
<P>The following table briefly lists some capabilities of the Birail1 object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Birail1</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Birail1 Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="birail1attrprop"></A> <A NAME="birail1p"></A> Birail1Attr Property</H4>

<P>The following parameters control the birailing process.</P>
<P>Similar to the Sweep object, the <CODE>"Type"</CODE> attribute controls whether the
birailed surface should be open, closed, or periodic in the direction
of the rail curves.</P>
<P>The parameter <CODE>"Sections"</CODE> determines how many
sections (in U direction) should be used, when generating the
birailed NURBS patch. The birailed NURBS patch always has sections+1 control
points in U direction.<BR>
Also zero is a valid setting for
the <CODE>"Sections"</CODE> parameter and used as default
value.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
If <CODE>"Sections"</CODE> is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.<BR>
Moreover, if <CODE>"Sections"</CODE> is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the birailed surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>


<P>The following table shows some example parameter configurations for
the Birail1 object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Sections</B></TD><TD><B>Rail1 Length</B></TD><TD><B>Rail1 Order</B></TD><TD><B>Birail1 Length</B></TD><TD><B>Birail1 Order</B></TD></TR><TR><TD>
0</TD><TD>2</TD><TD>2</TD><TD>2</TD><TD>2</TD></TR><TR><TD>
0</TD><TD>5</TD><TD>4</TD><TD>6</TD><TD>4</TD></TR><TR><TD>
0</TD><TD>6</TD><TD>5</TD><TD>7</TD><TD>5</TD></TR><TR><TD>
4</TD><TD>6</TD><TD>5</TD><TD>5</TD><TD>4</TD></TR><TR><TD>
10</TD><TD>6</TD><TD>5</TD><TD>11</TD><TD>4
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Birail1 Parameterisation Examples</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Birail1 object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; cross section,<BR>
<CODE>End</CODE> &ndash; cross section at end of sweep,<BR>
<CODE>Left</CODE> &ndash; curve formed by sweeping the start point of the
cross section, and<BR>
<CODE>Right</CODE> &ndash; curve formed by sweeping the end point of the
cross section.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The birailed surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the birailed surface in the following
order: end bevel, end cap, start bevel, start cap, left bevel, left cap,
right bevel, right cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Birail1 object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Birail1 objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap, left bevel, left cap, right bevel, right cap.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="birail2obj"></A> Birail2 Object</H3>

<P>
<CENTER>
<IMG SRC="pics/birail2.gif" HEIGHT=168 WIDTH=484  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Birail2 Object (left: Curves, right: Resulting Swept Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Birail2 object forms a surface by sweeping a <EM>cross section</EM>
(or <EM>profile</EM>) curve along two so called <EM>rail</EM> curves, while
morphing it into a second cross section (or profile) curve.
See also the image above for an example.</P>
<P>The morphing process may be controlled by a fifth parameter curve,
the <EM>interpolation control</EM> curve.
The object hierarchy of a Birail2 object, thus, looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Birail2
  |-Cross_Section1(NCurve)
  |-Rail1(NCurve)
  |-Rail2(NCurve)
  |-Cross_Section2(NCurve)
  \-[Interpolation_Control(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>When the cross sections touch the rail curves in their respective starting
or end points, the resulting surface will interpolate the rail curves.
The direction of the cross section curves will be parallel to the V
parametric dimension (height) and the direction of the rail curves will be
parallel to the U parametric dimension (width) of the resulting surface.
Height and width of the surface will be derived from the length of the
cross section curves and the number of sections, respectively.</P>
<P>
<CENTER>
<IMG SRC="pics/birail2vc.gif" HEIGHT=261 WIDTH=316  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Valid Configuration of Parameter Curves (white) for Birail2 (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The image above shows a valid configuration of parameter curves for
the Birail2 object. Mind the direction of the rail curves (R1 and R2)
with regard to the two cross section curves (CS1 and CS2) and the
fact, that all curves touch at their respective end points.</P>
<P>Note that the cross section curves do not have to be two dimensional, and,
in contrast to the normal Sweep object, they also do not have to be
defined in a special plane. Furthermore, they do not have to be compatible
in terms of length, order, and knots. Incompatible curves will be made
compatible before birailing automatically; the height of the resulting
surface, however, is not easily predictable anymore in this case.
Also note that the precision with which the resulting surface will
interpolate the rail curves depends on the number of sections chosen.</P>
<P>If a fifth curve is present as parameter object, this curve will
control the morphing (interpolation) process. The y coordinate
of this curve at a specific point, which should have a value between
0 and 1, determines the ratio of control of the first cross section
(0) and the second cross section (1) over the interpolated curve.
Thus, a straight line running from point (0,0) to (1,1) will be equivalent
to the standard linear interpolation that would be carried out if no
interpolation control curve were present. Note, however, that the
interpolation control curve has no influence on the first and last
copy of the respective cross section curve, unless the <CODE>"InterpolCtrl"</CODE>
option is used.<SMALL TITLE="Since 1.10."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The Birail2 object watches the child objects and adapts to them
automatically via the notification mechanism.</P>
<P>The following table briefly lists some capabilities of the Birail2 object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Birail2</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Birail2 Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="birail2attrprop"></A> <A NAME="birail2p"></A> Birail2Attr Property</H4>

<P>The following parameters control the birailing process.</P>
<P>The parameter <CODE>"Sections"</CODE> determines how many sections (in U direction)
should be used, when generating the birailed NURBS patch. The birailed
NURBS patch always has sections+1 control points in U direction.<BR>
Also zero is a valid setting for
the <CODE>"Sections"</CODE> parameter and used as default
value.<SMALL TITLE="Since 1.13."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
If <CODE>"Sections"</CODE> is zero the number of sections is directly derived from
the length of the first rail curve plus one (except for curves of length 2,
where it is 1). See the table below for examples.<BR>
Moreover, if <CODE>"Sections"</CODE> is zero, the order of the birail in U direction
is taken from the first rail curve. Otherwise, the order of the created
patch depends on the number of sections as follows: for 1 and 2 sections
the order will be 2 and 3 respectively, in all other cases it will be 4.</P>
<P>The parameter <CODE>"InterpolCtrl"</CODE> allows the interpolation controlling
curve full influence on the birailed surface.
If <CODE>"InterpolCtrl"</CODE> is disabled, the first and last border of the
resulting surface will always exactly match the parameter curves (CS1 and
CS2 respectively), regardless of the interpolation control curve.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the birailed surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>
<P>The following table shows some example parameter configurations for
the Birail2 object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Sections</B></TD><TD><B>Rail1 Length</B></TD><TD><B>Rail1 Order</B></TD><TD><B>Birail2 Length</B></TD><TD><B>Birail2 Order</B></TD></TR><TR><TD>
0</TD><TD>2</TD><TD>2</TD><TD>2</TD><TD>2</TD></TR><TR><TD>
0</TD><TD>5</TD><TD>4</TD><TD>6</TD><TD>4</TD></TR><TR><TD>
0</TD><TD>6</TD><TD>5</TD><TD>7</TD><TD>5</TD></TR><TR><TD>
4</TD><TD>6</TD><TD>5</TD><TD>5</TD><TD>4</TD></TR><TR><TD>
10</TD><TD>6</TD><TD>5</TD><TD>11</TD><TD>4
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Birail2 Parameterisation Examples</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Birail2 object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; first cross section,<BR>
<CODE>End</CODE> &ndash; second cross section,<BR>
<CODE>Left</CODE> &ndash; curve formed by sweeping the start point of the
first cross section, and<BR>
<CODE>Right</CODE> &ndash; curve formed by sweeping the end
point of the first cross section.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The birailed surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the birailed surface in the following
order: end bevel, end cap, start bevel, start cap, left bevel, left cap,
right bevel, right cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Birail2 object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Birail2 objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap, left bevel, left cap, right bevel, right cap.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="skinobj"></A> Skin Object</H3>

<P>
<CENTER>
<IMG SRC="pics/skin.gif" HEIGHT=320 WIDTH=472  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Skin Object (left: Curves, right: Resulting Skinned Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Skin object forms a surface defined by a set of <EM>cross section</EM> curves,
where the first and last curve will always be interpolated by the surface
(this process is sometimes also called <EM>lofting</EM>).
See also the image above.</P>
<P>When only two parameter curves are used, the skin forms a so called
<EM>ruled surface</EM>.</P>
<P>The complete template for the Skin object hierarchy, consequently,
looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Skin
  |-Curve_1(NCurve)
  |-Curve_2(NCurve)
  |-[...
  \-Curve_n(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Note that in contrast to the build from curves tool,
the curves may be of arbitrary length and order. It is e.g.&nbsp;possible to
use a parameter curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points.
If the curves are of different length or order, they will all be
converted internally until they are compatible. Be warned, that
this process may consume a considerable amount of time
because all unclamped curves have to be converted to
clamped ones; then, for every curve with low order degree elevation
has to be done; then a uniform knot vector has to be found; then all
curves have to be refined using this new knot vector; interpolation
adds another dimension of complexity. If you experience
lags when editing the child curves of a Skin object try to switch
to lazy notification.</P>
<P>A Skin object will also use all the curves of a
tool object, that provides multiple curves, e.g.&nbsp;a Clone object
in mirror mode.<SMALL TITLE="Since 1.9."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The direction of the parameter curves will be parallel to the V
dimension (height) of the skinned surface. The number of the parameter
curves will define the U dimension (width) of the skinned surface.</P>
<P>Also note that the resulting patch may be quite complex, even though
the curves are not, if the orders or knot vectors of the curves do not
match.
For example, a skinned patch from two curves of length 4 but one with
order 4 and the other with order 2 will result in a patch with
a width of 2 and a height of 10.</P>
<P>The Skin object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.</P>
<P>The following table briefly lists some capabilities of the Skin object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Skin</TD><TD>NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Skin Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="skinattrprop"></A> <A NAME="skp"></A> SkinAttr Property</H4>

<P>The following parameters control the skinning process.</P>
<P>The first parameter <CODE>"Interpolation"</CODE> controls
whether the inner curves should also be interpolated by the
skinning surface.</P>
<P>The second parameter <CODE>"Order_U"</CODE> determines the order
of the resulting surface in U direction (the order in V direction is
determined by the curves). The order may not be higher than the
number of curves used. If the specified value is higher than the number
of curves, the order of the generated surface will be silently
set to the number of curves.
If <CODE>"Order_U"</CODE> is 0, a default value equal to the number of parameter
curves but not higher than 4 will be used.</P>
<P>Using the next parameter <CODE>"Knot-Type_U"</CODE>, the type of the knot vector
that should be used in the U direction of the skinned surface can be
adapted. If the knot type is <CODE>"Bezier"</CODE> and the specified
order (see above) does not exactly match the number of skinned curves,
then the order will be silently adapted to the number of skinned curves.
The knot type <CODE>"Custom"</CODE> creates a chord length
parameterisation.<SMALL TITLE="Since 1.7."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
If interpolation is enabled, the knot types <CODE>"Chordal"</CODE>,
<CODE>"Centripetal"</CODE>, and <CODE>"Uniform"</CODE> will be used in the interpolation,
all other types will lead to a chordal parameterisation of the
interpolation.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the skinned surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Skin object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; first parameter curve,<BR>
<CODE>End</CODE> &ndash; last parameter curve,<BR>
<CODE>Left</CODE> &ndash; curve through start points of parameter curves, and<BR>
<CODE>Right</CODE> &ndash; curve through end points of parameter curves.</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The skinned surface, the bevels, and the caps
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the skinned surface in the following
order: start bevel, start cap, end bevel, end cap, left bevel, left cap,
right bevel, right cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Skin object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Skin objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: start bevel, start cap,
end bevel, end cap, left bevel, left cap,
right bevel, right cap.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="gordonobj"></A> Gordon Object</H3>

<P>
<CENTER>
<IMG SRC="pics/gordon-hood.gif" HEIGHT=256 WIDTH=400  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Gordon Object (left: Curves, right: Resulting Gordon
Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Gordon object forms a surface defined by two sets of intersecting
curves (a network of curves), where all curves will always be interpolated
by the surface (see image above). The image below shows the simplest
configuration of such a network, consisting of four parameter curves.
Note the arrangement and the direction of the curves.
Also note that this configuration is in fact equivalent to a Coons patch.</P>
<P>
<CENTER>
<IMG SRC="pics/sgordon.gif" HEIGHT=258 WIDTH=325  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Gordon Surface with Parameter Curves (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The curves may be of arbitrary length and order. It is e.g.&nbsp;possible
to use a first curve of order 2 and length 6 with a second curve
of order 4 and length 4 and a third curve with order 3 and 5
control points for the U parametric dimension.</P>
<P>Note that all intersection points of a curve with other curves have
to have the same parametric value in each of the other curves in the
same set/direction.
All curves are so called isoparametric curves.</P>
<P>Also note, that in the general case only non-rational curves can be used
as parameter curves for a Gordon surface.
If the parameter curves are rational, the weight information
of the curves will simply be ignored.
However, since Ayam 1.13 there is a special case allowed: if
exactly four parameter curves are present, their weight
information will be used properly. Mind that for a correct
surface interpolation the curves weights have to match in the
respective end points.</P>
<P>The Gordon object has the generating NURBS curves as child objects
and watches their changes and adapts to them automagically.
Separation of the two sets of curves has to be done using an
empty Level object. The first set of curves determines the U
direction and the second set of curves the V direction of the
Gordon surface. For the example surface in the image above, the
child objects of the Gordon object would have to look like this
in the Ayam object tree view:
<BLOCKQUOTE><CODE>
<PRE>
+-Gordon
  |-U1(NCurve)
  |-U2(NCurve)
  |-Level
  |-V1(NCurve)
  \-V2(NCurve)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The creation of a Gordon surface is computationally
expensive. It involves (interpolated) skinning of the two sets of
parameter curves, finding the intersection points of the two sets
of parameter curves, interpolating the matrix of intersection points,
making the three resulting surfaces compatible, and finally combining
the three surfaces into the resulting Gordon surface. If there are lags
while editing the parameter curves of a Gordon surface, consider
switching to lazy notification.</P>
<P>In order to ease the computationally intensive intersection
detection for Ayam an additional parameter object, separated
from the two sets of parameter curves by a second empty Level object,
may be specified.
This parameter object should be a NURBS patch object that describes
all intersection points by its control points.
If this object is present, no intersection points will be calculated
internally and the points specified via this object will be used instead.
A <CODE>"NoExport"</CODE> tag should be added to this patch, to prevent
it from appearing in RIB output.</P>
<P>The object hierarchy of a Gordon object using such a patch may look
like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Gordon
  |-U1(NCurve)
  |-U2(NCurve)
  |-Level
  |-V1(NCurve)
  |-V2(NCurve)
  |-Level
  \-Intersections(NPatch)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The complete template for the Gordon object hierarchy, consequently,
is as follows:
<BLOCKQUOTE><CODE>
<PRE>
+-Gordon
  |-U1(NCurve)
  |-U2(NCurve)
  |-[...
  |-Un(NCurve)]
  |-Level
  |-V1(NCurve)
  |-V2(NCurve)
  |-[...
  |-Vn(NCurve)]
  |-[Level
  \-Intersections(NPatch)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The Gordon object watches the child objects and adapts to them
automatically via the notification mechanism.</P>
<P>The following table briefly lists some capabilities of the Gordon object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Gordon</TD><TD>NCurve<SUP>&lowast;</SUP>/&thinsp;Level&thinsp;/&thinsp;NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Gordon Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="gordonattrprop"></A> <A NAME="gop"></A> GordonAttr Property</H4>

<P>The following parameters of the Gordon object control
the creation of the Gordon surface.</P>
<P>If the parameter <CODE>"WatchCorners"</CODE> is switched on, Ayam will
check for all four outer parameter curves, whether they touch in their
endpoints. If not, the endpoints will be corrected. If Ayam can
determine which curve was modified last, the other curve that should
meet at the endpoint in question will be modified.
If Ayam finds no information on modifications, the U curves take
precedence (i.e.&nbsp;the V curves will be modified).
Note that this works only properly with clamped curves.
Furthermore, only NCurve, ICurve, or ACurve objects will be modified,
but end point data will be derived from any objects providing a
NCurve (e.g.&nbsp;ExtrNC).<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The parameters <CODE>"Order_U"</CODE> and <CODE>"Order_V"</CODE> determine the
desired order of the resulting surface in U and V direction.
However, depending on the number and configuration of curves used
in the U or V direction, it may not be possible to create a Gordon
surface of the desired order.
If <CODE>"Order_U"</CODE> or <CODE>"Order_V"</CODE> are 0, a default value
of 4 will be used.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>
<P>To help in the exact configuration of the Gordon surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The Gordon object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>U0</CODE> &ndash; first curve of first set,<BR>
<CODE>U1</CODE> &ndash; last curve of first set,<BR>
<CODE>V0</CODE> &ndash; first curve of second set, and<BR>
<CODE>V1</CODE> &ndash; last curve of second set.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The Gordon surface, the bevels, and the caps may be converted to
ordinary NURBS patches using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the Gordon surface in the following
order: u0 bevel, u0 cap, u1 bevel, u1 cap, v0 bevel, v0 cap,
v1 bevel, v1 cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The Gordon object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Gordon objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: u0 bevel, u0 cap,
u1 bevel, u1 cap, v0 bevel, v0 cap, v1 bevel, v1
cap.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<H4><A NAME="s3"></A> Triangular Gordon Surfaces</H4>

<P>
<CENTER>
<IMG SRC="pics/tgordon.gif" HEIGHT=321 WIDTH=385  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Triangular Gordon Surface (blue) From Three Curves (white)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Apart from the Coons patch mode, Gordon objects also support another
special mode where a triangular surface is formed from three parameter
curves.<SMALL TITLE="Since 1.30."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
See also the image above. In this mode the three parameter curves do not have
to be separated by a Level object. The created NURBS surface is degenerate
at v = 1.0, however, a special tesselation is used for shading these
surfaces so that no artefacts should be visible.<BR>
This tesselation can also be accessed using the scripting interface
command <CODE>"convOb PolyMesh"</CODE>.<BR>
As they are a special case of Coons patches, triangular Gordon surfaces
also support rational coordinates.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bevelobj"></A> Bevel Object</H3>

<P>
<CENTER>
<IMG SRC="pics/bevel.gif" HEIGHT=150 WIDTH=312  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Bevel Object (left: Curve, right: Resulting Bevelled Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Bevel object forms a bevelled surface from a single parameter
curve. See also the image above. The bevel cross section shape may be
defined by a second curve.
Consequently, the template for the object hierarchy of a Bevel object
looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Bevel
  |-NCurve
  \-[NCurve]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Bevels are also available as properties of different tool objects
(e.g.&nbsp;Extrude or Sweep). In fact, Bevel objects use the same creation
algorithm as bevel properties but offer increased flexibility in terms of
e.g.&nbsp;material settings. Surfaces created from bevel properties always
share the material settings of the progenitor tool object. In contrast,
Bevel objects may have their own material settings. Bevel objects are
available in Ayam since version 1.10.</P>
<P>Note that the parameter curve of a Bevel object should be closed and
planar to achieve best results;
see section
<A HREF="ayam-5.html#toxyt">To XY Tool</A> for information on
how to easily achieve this. If the curve is closed or periodic,
the appropriate curve type should be set in the curve object,
otherwise the bevelled surface may expose defects.</P>
<P>Since Ayam 1.19 the Bevel object supports a second parameter curve
that defines the bevels cross section shape. It should be defined in the
XY-plane and run from
(0, 0) to (1, 1).
If this curve is present, the Bevel type parameter is ignored as the shape
of the bevel is already completely defined.
Note that even though the curve should end at (1, 1), this is not
mandatory and therefore allows for bevels of differing width and height
to be created.</P>
<P>The Bevel object watches the child object and adapts to it automatically
via the notification mechanism.</P>
<P>The following table briefly lists some capabilities of the Bevel object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Bevel</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Bevel Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> <A NAME="bevelattrprop"></A> <A NAME="bevelp"></A> BevelAttr Property</H4>

<P>The following parameters of the Bevel object control
the creation of the bevelled surface:
<UL>
<LI><CODE>"BevelType"</CODE> determines the shape of the bevel by choosing
from a set of cross section curves:
<UL>
<LI><CODE>"Round"</CODE> a quarter circle,
</LI>
<LI><CODE>"Linear"</CODE> a straight bevel,
</LI>
<LI><CODE>"Ridge"</CODE> a more complex ridged surface,
</LI>
<LI><CODE>"RoundToCap"</CODE> a surface that starts in the direction of a
progenitor surface tangent and rounds off to a cap surface (tangents
must be present as tag on the parameter curve), this types provides a
smoother transition from the progenitor surface to the bevel than a
round bevel, see also the image below,
</LI>
<LI><CODE>"RoundToNormal"</CODE> a surface that starts in the direction of a
progenitor surface tangent and rounds off to a mean normal,
see also the image below, normals and tangents must be present as tag
on the parameter curve, the mean normal can also be provided by a MN tag,
see section 
<A HREF="#mntag">MN (Mean Normal) Tag</A>,
</LI>
<LI>Any curves defined in a global level named <CODE>"Bevels"</CODE>
also appear as potential bevel type. Those curves should follow
the rules laid out above for the second parameter curve of the
Bevel object.</LI>
</UL>


See also the following image for a comparison of some bevel types.
<P>
<CENTER>
<IMG SRC="pics/btypes.gif" HEIGHT=227 WIDTH=716  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Bevel Types (l: Round, m: RoundToCap, r: RoundToNormal)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Note that the bevel types <CODE>"RoundCapped"</CODE> and <CODE>"LinearCapped"</CODE>
are no longer available<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>,
use the <CODE>"Caps"</CODE> property to create caps.</P>

</LI>
<LI><CODE>"Radius"</CODE> controls the size and direction of the bevelled
surface when seen from the top of the parameter curve. Note that the
size of the bevel is expressed in units defined by the object coordinate
system of the controlling object. Scale values of the controlling object
also affect the bevel size. Negative values are allowed and reverse the
surface.
</LI>
<LI><CODE>"Revert"</CODE> allows to revert the sense of the bevelled surface,
should it round inwards or outwards? The sense may also be controlled
using the direction of the parameter curve and, additionally, the sense
in a different dimension may also be affected by using negative values
for the bevel radius.
</LI>
<LI><CODE>"Force3D"</CODE> switches to 3D mode for all bevel types; if this
is enabled, non-planar parameter curves are supported, but normals
and tangents must be present as PV tag on the parameter curve.
However, when bevels are created via the Bevels property, the normals and
tangents will be extracted from the progenitor surface automatically and no
PV tags need to be created.</LI>
</UL>
</P>

<P>To create the tag with the normal and tangent information,
the <CODE>"Extract"</CODE> option of the ExtrNC object can be used.
Otherwise PV tags of appropriate name, storage class, and data type
must be created manually or with the help of the scripting interface.
Consider the following example script:
<BLOCKQUOTE><CODE>
<PRE>
crtOb NCurve -length 4 -order 2 -cv {0 0 0 1  1 0 0 1  0 1 0 1  0 0 0 1}
uS;sL
addTag PV "N,varying,n,4, -1,0,0, 1,0,0, 0,1,0, -1,0,0"
addTag PV "T,varying,n,4, 0,0,1, 0,0,1, 0,0,1, 0,0,1"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Also note that the planarity and exact shape defined by rational
coordinate values (e.g.&nbsp;circular arcs) will not be preserved by
the bevel types that support non-planar curves with one exception:
RoundToCap bevels on fully planar curves/boundaries do preserve
the boundary shape fully (unless overridden by
<CODE>"Force3D"</CODE>).<SMALL TITLE="Since 1.23."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>
of the <CODE>"BevelAttr"</CODE> property.</P>
<P>To help in the exact configuration of the bevel surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>

<H4><A NAME="s3"></A> Caps</H4>

<P>The Bevel object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>.</P>
<P>The boundary names are:<BR>
<CODE>Start</CODE> &ndash; start of bevel cross section,<BR>
<CODE>End</CODE> &ndash; end of bevel cross section.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The bevelled surface may be converted to an ordinary NURBS patch using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>If caps are present, an enclosing Level object will be created
and the caps follow the bevel surface in the following order:
start cap, end cap.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Bevel objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>If caps are present, those follow as potentially trimmed
NURBS patch primitives in the following order: start cap, end cap.</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="capobj"></A> Cap Object</H3>

<P>
<CENTER>
<IMG SRC="pics/cap.gif" HEIGHT=242 WIDTH=418  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Cap Object (left: Curve, right: Resulting Cap Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Cap object forms a surface that fills a closed NURBS curve.
See also the image above.</P>
<P>Four different types of cap surfaces with different
characteristics and parameter curve requirements are supported:
<EM>Trim</EM>, <EM>Gordon</EM>, <EM>Simple</EM>, and
<EM>Simple3D</EM>.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The <B>Trim</B> cap type requires planar parameter curves but they may be concave.
Furthermore, if multiple curves are present as child objects, the curves
following the first curve define holes in the cap surface, similar to the
parameter curves of an extruded surface (see also section
<A HREF="#handb">Using Holes and Bevels</A>).</P>
<P>Consequently, the template for the object hierarchy of a Cap object
in Trim mode looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Cap
  |-Outline(NCurve)
  |-[Hole1(NCurve)]
  +-[Hole2(Level)
    |-Part1(NCurve)
    \-Part2(NCurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Note that the cap generation may fail, if the control points of the
first curve have weights and the curve leaves the convex hull of the
control polygon.</P>
<P>The <B>Gordon</B> cap type supports only a single parameter curve but this curve
may be non planar. Internally the Cap object will split the
parameter curve into four sections and build a Gordon surface from
the four sections (see the following image for an example).
<CENTER>
<IMG SRC="pics/gordoncap.gif" HEIGHT=202 WIDTH=387  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Cap from Non-Planar Curve (left: Curve, right: Resulting Cap Surface)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The <B>Simple</B> cap type just extends the parameter curve linearly to a middle
point, not supporting non planar curves well and not supporting concave curves
at all but ensuring compatibility with the progenitor curve/surface
(which may be important for tesselation or further surface processing).</P>
<P>The <B>Simple3D</B> cap type extends the parameter curve to a middle point via
an additional planar and circular
ring of control points, therefore rounding more smoothly to the middle
(especially useful for non planar parameter curves or parameter curves
with discontinuities), and retains all other
characteristics of the Simple type.</P>
<P>A MP tag can be set to the Cap object to control the middle point
in both simple modes (see section
<A HREF="#mptag">MP (Mean Point) Tag</A>).</P>
<P>See also the following table for an overview on the available cap types:
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Planar</B></TD><TD><B>Concave</B></TD><TD><B>Holes</B></TD><TD><B>Compatibility&thinsp;/&thinsp;Integration</B></TD></TR><TR><TD>
Trim</TD><TD>Yes</TD><TD>Yes</TD><TD>Yes</TD><TD>No</TD></TR><TR><TD>
Gordon</TD><TD>No</TD><TD>No</TD><TD>No</TD><TD>No</TD></TR><TR><TD>
Simple</TD><TD>Yes</TD><TD>No</TD><TD>No</TD><TD>Yes</TD></TR><TR><TD>
Simple3D</TD><TD>No</TD><TD>No</TD><TD>No</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Cap Types Overview</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Cap object watches the child objects and adapts to them automatically
via the notification mechanism.</P>
<P>The following table briefly lists some capabilities of the Cap object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Cap</TD><TD>NCurve<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Cap Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="capattrprop"></A> <A NAME="capp"></A> CapAttr Property</H4>

<P>The following parameters control the cap creation process.</P>
<P>The attribute <CODE>"Type"</CODE> allows to select one of the following
cap creation methods:
<UL>
<LI><CODE>"Trim"</CODE>: a trimmed NURBS surface,</LI>
<LI><CODE>"Gordon"</CODE>: an untrimmed Gordon surface,</LI>
<LI><CODE>"Simple"</CODE>: a simple cap that extends linearly to a middle
point,</LI>
<LI><CODE>"Simple3D"</CODE>: a simple cap with an additional ring of control
points that therefore rounds more smoothly to the middle especially for
non planar parameter curves.</LI>
</UL>

See also the general discussion about the Cap object above.</P>
<P>The <CODE>"Fraction"</CODE> parameter allows to adjust the placement of the
additional control point ring in Simple3D mode.</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>
of the <CODE>"CapAttr"</CODE> property.</P>
<P>To help in the exact configuration of the cap surface, the <CODE>"NPInfo"</CODE>
field always displays the parameters of the created NURBS patch.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The cap surface may be converted to an ordinary NURBS patch using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Cap objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>
</P>
<P>PV tags are supported.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="concatnpobj"></A> ConcatNP (Concatenate NURBS Patches) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/concatnp.gif" HEIGHT=233 WIDTH=494  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">ConcatNP Object (white) From Two NURBS Patches (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The ConcatNP object concatenates all child objects, which should be NURBS
patches or provide NURBS patches to a single NURBS patch (see also the
image above).<SMALL TITLE="Since 1.16."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The concatenation simply breaks all surfaces into curves, makes
the curves compatible, and joins them to the concatenated surface.</P>
<P>Also NURBS curves or objects that provide NURBS curves can be used
as parameter objects.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Eventually present trim curves will be copied and transformed to the
appropriate place and orientation in the concatenated surface, according
to the new knot domain.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Attributes like display mode and tolerance for the new concatenated patch
are simply taken from the first parameter patch.</P>
<P>Since the ConcatNP object also
provides a NURBS patch, it is possible to use it as child object for
another ConcatNP object (with possibly different parameters).
This way, a hierarchy of ConcatNP objects can be used to emulate
patch based modelling to certain extents.</P>
<P>For best results, only clamped surfaces should be used as parameter objects.</P>
<P>The following table briefly lists some capabilities of the ConcatNP object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ConcatNP</TD><TD>NPatch<SUP>&lowast;</SUP>/&thinsp;NCurve<SUP>&lowast;</SUP></TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ConcatNP Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="concatnpattrprop"></A> <A NAME="concatnpp"></A> ConcatNPAttr Property</H4>

<P>The following parameters control the concatenation process.
<UL>
<LI>Using <CODE>"Type"</CODE>, open, closed, or periodic concatenated patches may
be created.
If a closed surface is to be created and also <CODE>"FillGaps"</CODE> (see below) is
enabled, an additional fillet will be created for the last and the first
child surface to close the concatenated surface.
</LI>
<LI><CODE>"Order"</CODE> is the desired order of the concatenated surface
(in U direction), the default value (0) leads to a cubic surface.
If the desired order is 1, the respective order from the first
of the parameter surfaces is taken.
If the desired order is higher than the number of curves (i.e.&nbsp;the
total number of control points of all surfaces in their desired
directions plus the number of eventually present parameter curves),
it will be lowered to the number of curves silently.
</LI>
<LI><CODE>"FillGaps"</CODE> creates fillet surfaces for all gaps between
the parameter surfaces of the ConcatNP object. No fillet will be created
if the end curves of two parameter surfaces match or if parameter
curves are present between the parameter surfaces in question.

<P>Similar to the fillets for concatenated curves, the fillet surface
will be constructed from four control points (in U direction).
However, the tangent vectors will not be calculated directly, but
instead derived from the respective control points.</P>

</LI>
<LI><CODE>"FTLength"</CODE> determines the distance of the inner fillet
control points from their respective end points. This value can
be adapted for smaller/larger gaps between parameter
surfaces. If this parameter is negative, the distance between the
two surfaces in the respective border points will be multiplied in so
that a more pleasing fillet shape results in configurations where the
distances between the respective border points vary a lot (see also the
image below).
<P>
<CENTER>
<IMG SRC="pics/concatnpfillets.gif" HEIGHT=348 WIDTH=590  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Concatenated Surfaces (blue) with Fillets (left: FTLength 0.3, right: FTLength -0.3)</FONT></CENTER><P><CENTER>
</CENTER>
</P>

</LI>
<LI>If <CODE>"Revert"</CODE> is enabled, the orientation of the concatenated
surface will be reversed (in U direction).
</LI>
<LI>The <CODE>"Knot-Type"</CODE> parameter allows to choose a knot vector for
the concatenated surface in U direction. Similar to the
ConcatNC object, only <CODE>"Custom"</CODE> knots allow to preserve the shapes
of the parameter surfaces completely, but this comes at the price of multiple
internal knots (see also 
<A HREF="#concatncp">ConcatNCAttr Property</A>).
In addition, for <CODE>"Custom"</CODE> knots, all parameter surfaces will be
elevated to a common maximum order or at least be clamped in the
respective direction prior to the splitting to curves but after
the fillet creation. Furthermore trim curves of the progenitor surfaces
will only be copied to the resulting surface, if the <CODE>"Knot-Type"</CODE>
parameter is <CODE>"Custom"</CODE>.
</LI>
<LI>The <CODE>"UVSelect"</CODE> option is a string that can be used to
control the splitting direction for each parameter surface
individually. Valid characters in this string are <CODE>"u"</CODE>, <CODE>"U"</CODE>,
<CODE>"v"</CODE>, and <CODE>"V"</CODE>.
The uppercase variants lead to a reverted surface in the respective
direction.<BR>
To connect two surfaces that share the same orientation "over a corner"
<CODE>"UVSelect"</CODE> should be set to <CODE>"uV"</CODE>
(see also the image below).<BR>
The default value for <CODE>"UVSelect"</CODE>, an empty string, is equivalent
to <CODE>"u"</CODE> for all patches. Also incomplete strings will lead to <CODE>"u"</CODE>
for all remaining patches. There is no need to specify a value for fillets,
those will always be created in a way so that they can be split along the
U direction.
<P>
<CENTER>
<IMG SRC="pics/concatnpuv.gif" HEIGHT=292 WIDTH=292  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Concatenating two Surfaces with UVSelect == "uV"</FONT></CENTER><P><CENTER>
</CENTER>
</P>

</LI>
<LI><CODE>"Compatible"</CODE> controls whether the curves should be
made compatible before the concatenated surface is built from
them. If this option is turned off (the default), the curves
are made compatible. Turn this option on if the surfaces to be
concatenated are already compatible and their knot vectors are unclamped.
The output surface will then also be unclamped (in V direction).
</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NPInfo"</CODE> field informs about the actual configuration
of the created NURBS patch.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The ConcatNP object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The concatenated surface may be converted to an ordinary NURBS patch using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels and caps follow the concatenated surface in the following
order: U0 bevel, U0 cap, U1 bevel, U1 cap, V0 bevel, V0 cap,
V1 bevel, V1 cap.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The ConcatNP object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ConcatNP objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: U0 bevel, U0 cap,
U1 bevel, U1 cap, V0 bevel, V0 cap, V1 bevel, V1
cap.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>PV tags are supported but all NURBS patch primitives will get
the same set of tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="extrnpobj"></A> ExtrNP (Extract NURBS Patch) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/extrnp.gif" HEIGHT=221 WIDTH=284  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Extracted Surface (white) from Progenitor Surface (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The ExtrNP object extracts a NURBS patch from
another NURBS patch object, for use as parameter object for other tool
objects (see image above).<SMALL TITLE="Since 1.14."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>It also works with NURBS patch providing objects, so that the following
example hierarchy is valid:
<BLOCKQUOTE><CODE>
<PRE>
--NPatch
+-ExtrNP
 \ Instance_of_NPatch(Instance)
</PRE>
</CODE></BLOCKQUOTE>

Note that using an instance object of some other surface object
(as shown in the above example) is in fact the recommended way of using
the ExtrNP object. Therefore, the main menu entry
<CODE>"Tools/Create/ExtrNP"</CODE>
will automatically create an instance of the currently selected object
and move it to the newly created ExtrNP object.</P>
<P>As the geometry of the extracted surface is completely defined by
the master surface, ExtrNP objects do not support own transformation
attributes.<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
However, if a NP tag makes the Transformation property available
again, the transformation attributes will be
employed as usual.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Also note that eventually present trim curves will <EM>not</EM> be honored
properly.</P>
<P>The following table briefly lists some capabilities of the ExtrNP object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
ExtrNP</TD><TD>NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">ExtrNP Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="extrnpattrprop"></A> <A NAME="extrnpp"></A> ExtrNPAttr Property</H4>

<P>The extraction process is controlled by the following attributes:
<UL>
<LI><CODE>"UMin"</CODE>, <CODE>"UMax"</CODE>, <CODE>"VMin"</CODE>, and <CODE>"VMax"</CODE> are
parametric values that control which part of the original surface
is to be extracted. The valid range of parameter values depends
on the knot vectors of the original surface.
</LI>
<LI><CODE>"Relative"</CODE> controls whether the parametric values should
be interpreted in a relative way.<SMALL TITLE="Since 1.15."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
If enabled, a parametric value of 0.5
always extracts from the middle of the knot vector, regardless of the
actual knot values, and the valid range for the parametric values is
then consequently 0.0-1.0.
</LI>
<LI><CODE>"PatchNum"</CODE> allows to select a patch from a list of
patches delivered e.g.&nbsp;by a beveled Extrude object as child
of the ExtrNP object.
This way it is possible to extract a patch from a bevel or cap
surface of e.g.&nbsp;a Revolve object.
</LI>
<LI>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NPInfo"</CODE> field informs about the actual configuration
of the extracted NURBS surface.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The ExtrNP object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The extracted surface may be converted to an ordinary NURBS patch using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels or caps follow the extracted surface in the following
order: U0, U1, V0, V1.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The ExtrNP object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>ExtrNP objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If bevels or caps are present, those follow as potentially trimmed NURBS
patch primitives in the following order: U0, U1, V0, V1.</P>
<P>PV tags are supported but all NURBS patch primitives will get
the same set of tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="offsetnpobj"></A> OffsetNP (Offset NURBS Surfaces) Object</H3>

<P>
<CENTER>
<IMG SRC="pics/offnp.gif" HEIGHT=250 WIDTH=288  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Offset Surface (white) from NURBS Surface (blue) with Offset 0.2</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The OffsetNP object creates offset surfaces from
NURBS surfaces using a simple algorithm: each control point is moved
along a normal vector obtained by all direct neighboring control
points.<SMALL TITLE="Since 1.17."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
See also the image above.</P>
<P>The offset surface will always match the original surface in width, height,
orders, and knots.</P>
<P>The offsetting also works for closed and periodic surfaces in any
possible combinations in the two dimensions.<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Degenerate surfaces are supported.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
However note that rational surfaces are still not supported.
No attempt is made to prevent collisions or self intersections.</P>
<P>Trim curves are copied verbatim from the parameter surface to the
offset surface.</P>
<P>As the geometry of the offset surface is completely defined by the master
surface and the offset parameter, OffsetNP objects do not support own
transformation attributes.<SMALL TITLE="Since 1.19."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The following table briefly lists some capabilities of the OffsetNP object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
OffsetNP</TD><TD>NPatch</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">OffsetNP Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="offsetnpattrprop"></A> <A NAME="offsetnpp"></A> OffsetNPAttr Property</H4>

<P>The following parameters control the offsetting process:
<UL>
<LI><CODE>"Offset"</CODE> determines the distance between original surface and
offset surface. Negative values are allowed.
</LI>
<LI>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</LI>
</UL>

<UL>
<LI>Finally, a <CODE>"NPInfo"</CODE> field informs about the actual configuration
of the created NURBS surface.</LI>
</UL>
</P>



<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>The OffsetNP object supports the standard caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<BR>
The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The offset surface may be converted to an ordinary NURBS patch using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the bevels or caps follow the offset surface in the following
order: U0, U1, V0, V1.</P>
<P>Integrated bevels or caps do not appear as extra objects.</P>
<P>The OffsetNP object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>OffsetNP objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If bevels or caps are present, those follow as potentially trimmed NURBS
patch primitives in the following order: U0, U1, V0, V1.</P>
<P>PV tags are supported but all NURBS patch primitives will get
the same set of tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Multiple TC tags are also supported.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="textobj"></A> Text Object</H3>

<P>
<CENTER>
<IMG SRC="pics/text-ayam.gif" HEIGHT=175 WIDTH=400  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Text Object set in Verdana</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Text objects may be used to easily create objects that form letters or
even whole words in very high quality. For that, they parse TrueType font
description files, extract the Bezier curves from the font description,
sort the curves, connect them properly and finally extrude them.
As with the Extrude objects, caps and bevels may be created automatically.</P>
<P>Parsing of TrueType font descriptions is quite tricky. For the sake
of brevity and ease of the implementation, Ayam does not support elaborate
TrueType features like kerning tables, that e.g.&nbsp;control distances between
certain letters (You are not going to typeset a book with Ayam anyway,
aren't you?). Therefore you might experience wrong letter distances
from time to time. If this happens, just create a Text object for each
letter, and arrange the objects as you like.</P>
<P>The Text object can be converted to ordinary NURBS patches
using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>The following table briefly lists some capabilities of the Text object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Text</TD><TD>No</TD><TD>Yes</TD><TD>NPatch<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Text Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="textattrprop"></A> <A NAME="textattr"></A> TextAttr Property</H4>

<P>The following attributes control the creation of the text objects.
<UL>
<LI>Using <CODE>"FontName"</CODE> a TrueType font description file is
specified.
Those files usually have the file name extension <CODE>".ttf"</CODE>.
Only real TrueType font files, containing Bezier curve font descriptions,
are supported. There are also rastered, bitmap containing TrueType
font description files, those will not work.
</LI>
<LI>Using <CODE>"String"</CODE> you specify the letters to be created.
This entry (and the corresponding data structures) are Unicode clean.
This means you can put any Unicode letters into this entry. You should
of course make sure, that the specified letters are included in the
selected font file.
</LI>
<LI><CODE>"Height"</CODE> controls the height of the extruded object.
</LI>
<LI><CODE>"Revert"</CODE> reverts the sense of inside-outside detection
mechanism for the cap generation. Depending on the actual font description
file (or even letter) you may need to toggle this to get caps.
</LI>
<LI><CODE>"UpperCap"</CODE>, <CODE>"LowerCap"</CODE>, work like for the Extrude object
(see section 
<A HREF="#extrattr">ExtrudeAttr Property</A> for a more
exhaustive description of those parameters).
</LI>
<LI><CODE>"Add Lower Bevel!"</CODE>, <CODE>"Add Upper Bevel!"</CODE>:
Since Ayam 1.10 the bevel parameters of the text object are saved
in bevel parameter tags and the property GUI changed to conform to
all other bevel supporting tool objects. The old options <CODE>"LowerBevel"</CODE>,
<CODE>"UpperBevel"</CODE>, <CODE>"BevelType"</CODE>, <CODE>"BevelRadius"</CODE>, and
<CODE>"RevertBevels"</CODE> are no longer available. They were replaced with
new dynamic tag creating bevel property GUI sections that are accessible
through the new command entries <CODE>"Add Lower Bevel!"</CODE> and
<CODE>"Add Upper Bevel!"</CODE>
respectively. If one of those entries is used, a bevel parameter tag
is created and more options will be made available in the property
GUI to adjust the bevel parameters or remove the tag again.
A more thorough discussion of those options is available in
section 
<A HREF="#bevelp">BevelAttr Property</A>.
<P>Just one note: for some fonts, the bevel radius has to be set to really
small values (about 0.001) to get proper bevels and caps. This is
because of sharp corners in some letters that lead to self overlapping
borders of the bevel surfaces with otherwise perfectly normal values
for the bevel radius.</P>
</LI>
</UL>
</P>
<P>See section 
<A HREF="#npattr">NPatchAttr</A> for a description
of the other two attributes <CODE>"DisplayMode"</CODE> and <CODE>"Tolerance"</CODE>.</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The extruded surfaces, the bevels, and the caps,
may be converted to ordinary NURBS patches using the main menu entry
<CODE>"Tools/Convert"</CODE>.</P>
<P>If bevels or caps are present, an enclosing Level object will be created
and the caps follow the extruded surfaced in the following
order: end bevel, end cap, start bevel, start cap.</P>
<P>The Text object provides a list of NURBS patch objects in the
same order as created upon conversion.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Text objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

If caps or bevels are present, those follow as potentially trimmed
NURBS patch primitives in the following order: end bevel, end cap,
start bevel, start cap.</P>
<P>PV tags are supported but all NURBS patch primitives will get
the same set of tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="trimobj"></A> Trim Object</H3>

<P>
<CENTER>
<IMG SRC="pics/trimo.gif" HEIGHT=243 WIDTH=339  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Trimmed Swing Object Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The Trim object may be used in hierarchies
of tool objects to trim NURBS patch providing objects otherwise
unavailable to trimming like e.g.&nbsp;a Revolve
object.<SMALL TITLE="Since 1.16."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>See also the image above which depicts the swung surface example object
further trimmed by a Trim object.</P>
<P>The first child of the Trim object is the NURBS patch providing object
and the second object is the trim curve (defined in the parametric
space of the NURBS surface). More curves and loops may follow.
All parameter curves must obey the rules for trimming as outlined in section
<A HREF="#trim">Trim Curves</A>.
The surface may already be trimmed and there may be multiple provided
patches, however, only one of them will be trimmed by the Trim object.</P>
<P>The object hierarchy of a Trim object, thus, looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-Trim
  |-Surface(Revolve)
  |-Trim_1(NCurve)
  +-[Trim_2(Level)
  | |-NCurve
  | \-NCurve
  | ...
  \-Trim_n(ICurve)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The following table briefly lists some capabilities of the Trim object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Trim</TD><TD>NPatch&thinsp;/&thinsp;NCurve<SUP>+</SUP>/&thinsp;Level<SUP>+</SUP></TD><TD>Yes</TD><TD>NPatch</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Trim Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> <A NAME="trimattrprop"></A> <A NAME="trimp"></A> TrimAttrib Property</H4>

<P>The following parameters control the trimming process:
<UL>
<LI><CODE>"PatchNum"</CODE> allows to select a patch, should the NURBS
patch providing object deliver a list. This way, a bevel of an
extrusion might be trimmed.</LI>
<LI><CODE>"ScaleMode"</CODE> controls how the trim curve is scaled
to the NURBS patch parameter space:<BR>
In mode <CODE>"Absolute"</CODE> no scaling happens.<BR>
In mode <CODE>"Relative"</CODE> the trim curves are expected to be defined
between 0 and 1 (in x <EM>and</EM> y dimension) and
will be scaled to the patch appropriately, no matter how the
parametric space of the patch actually looks like (i.e.&nbsp;it works
the same for a patch where the knots range from 0 to 1, 0 to 2,
or even 3 to 3.5).</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>The trimmed surface may be converted to an ordinary NURBS patch
using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Trim objects will be exported as NURBS patch primitives:
<BLOCKQUOTE><CODE>
<CODE>RiNuPatch(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are currently not supported.</P>



<H2><A NAME="polys"></A> <A NAME="ss4.8">4.8</A> <A HREF="ayam.html#toc4.8">Polygonal and Subdivision Objects</A>
</H2>

<P>These objects complement the Ayam feature set and allow
objects modelled in the polygonal or subdivision modelling
paradigms to be included in Ayam scenes.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="polymeshobj"></A> PolyMesh Object</H3>

<P>
<CENTER>
<IMG SRC="pics/pomesh.gif" HEIGHT=188 WIDTH=195  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">PolyMesh Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The PolyMesh object may be used to include objects that
have been modeled using the polygonal modelling paradigm
in Ayam scenes. See the image above for a simple example.</P>
<P>There are just a few special modelling actions for this type of object
(see section 
<A HREF="ayam-2.html#polymeshtools">PolyMesh tools</A>), but
its control points can be selected and modified as it can be done with
other object types, e.g.&nbsp;curves.</P>
<P>The PolyMesh object is equivalent to the general points polygons
primitive of the RenderMan interface. This means, each PolyMesh
object may contain multiple general (convex or concave) polygons,
which in turn may consist of an outer loop and an arbitrary number
of inner loops that describe holes in the polygon (see also the
image above, showing a polygonal mesh with one pentagonal face and
a triangular hole). The loops use a point indexing scheme to
efficiently reuse coordinate values.
This general approach requires a so called tesselation to be carried
out, in order for the PolyMesh object to be shaded.
For the tesselation, Ayam uses routines of the GLU library.</P>
<P>Ayam is able to automatically create face normals for PolyMeshes.
They will be calculated while tesselating the PolyMesh and be
perpendicular to the plane determined by the first three vertices
of the outer loop of a polygon.
Furthermore, Ayam supports vertex normals (normals stored for every
control point).</P>
<P>Note that storing single triangles in PolyMesh
objects will lead to a real waste of memory. The
merge tool (main menu <CODE>"Tools/PolyMesh/Merge"</CODE>) can be used
to combine many PolyMesh objects into a single PolyMesh object.</P>
<P>The following table briefly lists some capabilities of the PolyMesh object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
PolyMesh</TD><TD>No</TD><TD>Yes</TD><TD>SDMesh</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">PolyMesh Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="polymeshattrprop"></A> <A NAME="pomattr"></A> PolyMeshAttr Property</H4>

<P>The PolyMeshAttr GUI just displays some information about the
PolyMesh object:
<UL>
<LI><CODE>"NPolys"</CODE> the number of polygons.</LI>
<LI><CODE>"NControls"</CODE> the total number of control points
defined.</LI>
<LI><CODE>"HasNormals"</CODE> is 1 if the object uses vertex normals,
else it is 0.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>PolyMesh objects may be converted to SDMesh
objects using the main menu entry
<CODE>"Tools/Convert"</CODE>.<SMALL TITLE="Since 1.11."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Note that no verification of the usability of the
mesh as base mesh for a subdivision surface is carried out.
Usually, such meshes have to be manifold and may not contain
T-junctions.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>PolyMesh objects will be exported as <CODE>RiPointsGeneralPolygons</CODE> primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.&nbsp;a <CODE>RiGeneralPolygon</CODE>).</P>
<P>PV tags are supported.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sdmeshobj"></A> SDMesh Object</H3>

<P>
<CENTER>
<IMG SRC="pics/sdmesh.gif" HEIGHT=320 WIDTH=400  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">SDMesh object with original polygonal mesh (blue)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The SDMesh object may be used to include objects that
have been modeled using the subdivision modelling paradigm
in Ayam scenes (see also the image above).</P>
<P>There are no special modelling actions for this type of object, but
its control points can be selected and modified as it can be done with
other object types, e.g.&nbsp;curves.</P>
<P>The SDMesh object is equivalent to the Subdivision Mesh
primitive of the RenderMan interface. This means, each SDMesh
object may contain multiple faces with arbitrary number
of vertices that form a polygonal mesh. This polygonal mesh is
then successively refined using a subdivision scheme and, depending
on the number of refinement (or subdivision) steps, results in
a more or less smooth surface. There are several different
subdivision schemes, but the scheme currently supported
by most RenderMan compliant renderers is named "Catmull-Clark".</P>
<P>Tags may be specified for faces, edges, or vertices
to control the subdivision process (e.g.&nbsp;to create sharp corners or edges
in the resulting surface). All tags known from the RenderMan interface
(hole, crease, corner, and interpolateboundary) are supported by Ayam,
but they may currently not be changed by the user.</P>
<P>Unless the <CODE>"subdiv"</CODE> plugin (available since Ayam 1.19) is loaded,
Ayam is not able to do the subdivision and show the resulting smooth
surface. All that is shown in wire-frame and shaded views is the original
polygonal mesh.</P>
<P>The following table briefly lists some capabilities of the SDMesh object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
SDMesh</TD><TD>No</TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">SDMesh Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sdmeshattrprop"></A> <A NAME="sdmattr"></A> SDMeshAttr Property</H4>

<P>The SDMeshAttr GUI just displays some information about the
SDMesh object:
<UL>
<LI><CODE>"Scheme"</CODE>, is the subdivision scheme, currently available
schemes are Catmull-Clark and Loop.<SMALL TITLE="Since 1.11."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></LI>
<LI><CODE>"Level"</CODE> is the number of subdivision steps that should
be carried out when subdividing the mesh for preview. This subdivision
needs the <CODE>"subdiv"</CODE> plugin.</LI>
<LI><CODE>"DrawSub"</CODE> allows to switch between the control polygon
and the subdivided polygon outlines when drawing the mesh.</LI>
<LI><CODE>"NFaces"</CODE>, the number of faces.</LI>
<LI><CODE>"NControls"</CODE>, the total number of control points
defined.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>SDMesh objects may be converted to PolyMesh
objects.<SMALL TITLE="Since 1.11."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Note however that only the original, unrefined, control
polygon (i.e.&nbsp;the base mesh) will be converted unless the <CODE>"Level"</CODE>
attribute is not zero <EM>and</EM> the <CODE>"subdiv"</CODE> plugin is loaded.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>SDMesh objects will be exported as subdivision mesh primitives:
<BLOCKQUOTE><CODE>
<CODE>RiSubdivisionMesh(...);</CODE>
</CODE></BLOCKQUOTE>

PV tags are supported.</P>



<H2><A NAME="scobjs"></A> <A NAME="ss4.9">4.9</A> <A HREF="ayam.html#toc4.9">Script and Custom Objects</A>
</H2>

<P>These objects create/modify arbitrary other objects from
scripts or define entirely new object types via the custom object plugin
mechanism.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="scriptobj"></A> Script Object</H3>





























<P>
<CENTER>
<DM>
<TABLE ALIGN="CENTER" BORDER="0"><TR><TD>
<PRE>

crtOb NCurve -l 30 -kt 1
sL
for {set i 0} {$i &lt; 30} {incr i} {
    set x [expr $i*cos($i*20.0)/10.0]
    set y [expr $i*sin($i*20.0)/10.0]
    setPnt $i $x $y 0 1
}
</PRE>
</TD><TD>
<PRE>
     
</PRE>
</TD><TD>
<IMG SRC="pics/spiral.gif" HEIGHT=184 WIDTH=213  loading="lazy">
</TD></TR></TABLE>
 
</DM>
</CENTER><P><CENTER><FONT SIZE="-1">Script Object Example: Tcl Code (l), Resulting Curve (r)</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<P>Script objects are the most flexible object type of Ayam.
They may be used to create new objects, modify existing objects,
or realise mechanisms like constraints using small scripts
that are embedded in the Script objects themselves.</P>
<P>Those small embedded scripts may employ functionality from Tcl and
the Tcl scripting interface of Ayam
(see also section 
<A HREF="ayam-6.html#script">Scripting Interface</A>).
See also the table above, depicting a simple example script object
that creates a NURBS curve and puts the control points of the curve
in a spiral in the XY-plane. This example is also distributed with Ayam.</P>
<P>Script objects may also use arbitrary, plugin provided,
scripting languages, like JavaScript, provided by the
<CODE>"jsinterp"</CODE> plugin (see also:
<A HREF="ayam-6.html#jsinterp">JavaScript Scripting Interface</A>).<SMALL TITLE="Since 1.18."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The binary and source distributions of Ayam contain several example
scripts for Script objects in the <CODE>"ayam/bin/scripts"</CODE> and
<CODE>"ayam/src/scripts"</CODE> directories, respectively. In addition,
there are example scene files using Script objects in the
<CODE>"ayam/scn/scripts"</CODE> directory, see also
section 
<A HREF="ayam-6.html#scriptobjs">Distributed Script Objects</A>.</P>
<P>The following table briefly lists some capabilities of the Script object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
Script</TD><TD>Any<SUP>+</SUP></TD><TD>No</TD><TD>Any<SUP>+</SUP></TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Script Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<H4><A NAME="s3"></A> Script Object Usage</H4>

<P>The script of a Script object will be run each time the script is
modified and each time the notification callback of the Script object
is called (e.g.&nbsp;because one of the children of the Script object changed).
As long as the script of a Script object is executed, Ayam will
not process any events except for checking whether the script emergency
hotkey <CODE>&lt;Ctrl+C&gt;</CODE>, that may also be used to
escape from infinite loops in the Ayam console, is pressed.
Calling commands and procedures that lead to the processing of
events or that are slow because they manipulate or update the
GUI of Ayam should be avoided. In particular, the following
procedures and commands should <EM>not</EM> be used: <CODE>uS</CODE>, <CODE>uCR</CODE>,
<CODE>uCL</CODE>, <CODE>selOb</CODE>, <CODE>plb_update</CODE>, <CODE>undo</CODE>!</P>
<P>As a Script objects script is fired with the notification of said
object, and recursive notification is blocked by the Ayam core,
the script can not rely on automatic multilevel notification when
creating hierarchies of objects, e.g.&nbsp;for tool objects. Instead,
the notification of a tool object created by the script has to be
triggered manually by the script.</P>
<P>If a script fails, the Script object will be disabled by means
of the <CODE>"Active"</CODE> attribute.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Furthermore, the script line where the error occurred will be
highlighted in the script editor.</P>
<P>Script objects may also create their own property
GUIs for e.g.&nbsp;script parameters.<SMALL TITLE="Since 1.8.2."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
This may be accomplished by adding tags of type <CODE>"NP"</CODE> with the
name of the new property as value to the Script object (menu entry
<CODE>"Special/Tags/Add Property"</CODE>).
The script itself is responsible for data
management and property GUI creation (see section
<A HREF="#scriptattr">ScriptAttr Property</A>
below).</P>
<P>There is also a tag type to remove properties
(<CODE>"RP"</CODE>).<SMALL TITLE="Since 1.12."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Using this tag, the actual script code can be hidden
and thus users are blocked from unintentionally changing it.</P>
<P>Starting with Ayam 1.16, the environment for running Script objects scripts
has been refined to allow more complex scripts (that traverse the scene or
use the clipboard) to be written. When a script is running,
<UL>
<LI>the current level is initially the child level
of the respective Script object,</LI>
<LI>the object clipboard is saved
and cleared before running the script and also re-established after
the script finished, and</LI>
<LI>the <CODE>"CreateAt"</CODE> and <CODE>"CreateIn"</CODE> options are
both disabled (i.e.&nbsp;objects will be created with default transformation
attributes).</LI>
</UL>
</P>



<H4><A NAME="s3"></A> <A NAME="scriptattrprop"></A> <A NAME="scriptattr"></A> ScriptAttr Property</H4>

<P>This section discusses the available Script object types and
additional controlling parameters.
<UL>
<LI>If <CODE>"Active"</CODE> is disabled, the script will not be run.
</LI>
<LI><CODE>"Type"</CODE> is the type of the Script object.
Three types of Script objects are currently available:
<PRE>
</PRE>

<UL>
<LI><CODE>"Run"</CODE>, the script will be run and no special action will
take place.

<PRE>
</PRE>
</LI>
<LI><CODE>"Create"</CODE>, the script will be run and will create and
parameterise new objects. After running the script, the newly
created object(s) will automatically be moved into the internal data
structure of the Script object. The Script object will look like
and act as an object of the type that the script created.
If the script creates e.g.&nbsp;a NCurve object, the Script object may
be used as parameter object of a tool object that needs a NCurve,
e.g.&nbsp;a Sweep:
<BLOCKQUOTE><CODE>
<PRE>
+-Sweep
  |-Cross_Section(Script)
  \-Path(NCurve)
</PRE>
</CODE></BLOCKQUOTE>

If the newly created object has to be selected by the script code
for further parameterisation purposes, the selection should be done
using the scripting interface command <CODE>"sL"</CODE> (which performs
a hidden selection in the safe interpreter context).
Consequently, the most simple example script for a Script object
of type <CODE>"Create"</CODE> looks like this:
<BLOCKQUOTE><CODE>
<PRE>
crtOb NCurve
</PRE>
</CODE></BLOCKQUOTE>

or, with further parameterisation:
<BLOCKQUOTE><CODE>
<PRE>
crtOb NCurve
sL
setProperty NCurveAttr(Order) 2
</PRE>
</CODE></BLOCKQUOTE>

</LI>
<LI><CODE>"Modify"</CODE>, if the Script object has child objects,
these child objects will be temporarily moved into the internal data
structure of the Script object. A copy of all child objects will be
created as new children of the Script object. A selection of the
new child objects will be established, then the script will be run.
Usually, the script modifies one of the selected objects (moves control
points, adds tags, or does something similar). Afterwards, the two sets
of objects will be exchanged, the modified objects will be moved to
the internal data structure of the Script object while
the unmodified original child objects will again be child objects of the
Script object. The modified objects will henceforth be provided upstream to
potential parents.
If certain actions in the script shall be restricted to
one of the child objects of the Script object, the
<CODE>"withOb"</CODE> command may be used to accomplish this easily.
The Script object will look like and act as an object of the type
of the first child object of the Script object.
If the Script object has e.g.&nbsp;a NCurve object as first child, the
Script object may be used as parameter object of a tool object that
needs a NCurve, e.g.&nbsp;a Sweep:
<BLOCKQUOTE><CODE>
<PRE>
+-Sweep
  +-Cross_Section(Script)
  | \-NCurve
  \-Path(NCurve)
</PRE>
</CODE></BLOCKQUOTE>

A simple example script for a Script object of type <CODE>"Modify"</CODE> that
needs a single NURBS curve as child object may look like this:
<BLOCKQUOTE><CODE>
<PRE>
revertC
</PRE>
</CODE></BLOCKQUOTE>

Note: In order to make this work for objects that are not supported by
the <CODE>revertC</CODE> command directly but provide NURBS curves
(e.g.&nbsp;ExtrNC objects or instances of NURBS curves) the code has to
look like this:
<BLOCKQUOTE><CODE>
<PRE>
convOb -inplace; revertC
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>

</LI>
<LI><CODE>"Script"</CODE> is the script code.
<A NAME="scobjcontm"></A> 
The corresponding widget
is a standard Tcl text widget that allows to directly edit the code.
It is also possible to edit the code in an external editor and
copy it to the Script object using the operating system clipboard
and the <CODE>"Paste (Replace)"</CODE> context menu entry of the text widget.
In contrast to the other property GUI elements, the text widget has
a resize handle in the lower left corner, see also the image below.</LI>
</UL>

<CENTER>
<IMG SRC="pics/scriptpg.gif" HEIGHT=235 WIDTH=412  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Script Property GUI with Context Menu and Resize Handle</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> Script Parameters and Property GUIs</H4>

<P>If the script has a property GUI it is important to save the property
data array between multiple copies of a Script object (to make
them truly unique and not operating on the same set of parameters)
and to scene files.</P>
<P>This can be accomplished using a comment in the first line of the script.
If it looks like this:
<HR>
<PRE>
# Ayam, save array: &lt;arrayname&gt;
</PRE>
<HR>

then the global Tcl array <CODE>&lt;arrayname&gt;</CODE> will be saved with
the Script object to Ayam scene files.
The array must contain an entry <CODE>"SP"</CODE> that lists all individual
parameters of the Script object. Note that only parameters from this
list will be saved to Ayam scene files.
Note also, that <CODE>"SP"</CODE> must <EM>never</EM> contain <CODE>"SP"</CODE>. All copies
of a Script object must share the same set of individual vs.&nbsp;shared
parameters. If Script objects need to store differing/individual
amounts of parameter data, lists can be used as individual parameters.</P>

<H4><A NAME="s3"></A> Scripts in Foreign Languages</H4>

<P>Script objects may also use arbitrary, plugin provided,
scripting languages.<SMALL TITLE="Since 1.18."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
To switch to a different language, the first line
of the script must be a comment (in the syntax of the other language)
with the keyword <CODE>"use:"</CODE> followed by the language name, as
provided by the corresponding plugin, e.g.&nbsp;for JavaScript the first line
should look like this:
<HR>
<PRE>
/* Ayam, use: JavaScript */
</PRE>
<HR>

The special comments for saving of array items and language switching
can be used in conjunction like this:
<HR>
<PRE>
/* Ayam, use: JavaScript, save array: MyArr */
</PRE>
<HR>
</P>

<H4><A NAME="s3"></A> <A NAME="safeinterp"></A> Safe Interpreter</H4>

<P>In Ayam versions prior to 1.16 Script object scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
Script objects scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state. Direct access
to Tk is also completely blocked, but Script objects still can have their
own property GUIs (refer to the examples below).</P>
<P>In particular, the following Tcl commands are <EM>not</EM> available in the
safe interpreter:
<CODE>cd</CODE>, <CODE>encoding</CODE>, <CODE>exec</CODE>, <CODE>exit</CODE>, <CODE>fconfigure</CODE>, <CODE>file</CODE>,
<CODE>glob</CODE>, <CODE>load</CODE>, <CODE>open</CODE>, <CODE>pwd</CODE>, <CODE>socket</CODE>,
<CODE>source</CODE>, <CODE>unload</CODE>; <CODE>auto_exec_ok</CODE>, <CODE>auto_import</CODE>, <CODE>auto_load</CODE>,
<CODE>auto_load_index</CODE>, <CODE>auto_qualify</CODE>, <CODE>unknown</CODE>
(the missing unknown and autoloading facilities
lead to further unavailability of commands normally available via
autoloading, like e.g.&nbsp;<CODE>parray</CODE>, <CODE>history</CODE>).<BR>
The <CODE>puts</CODE> command is available in a limited fashion: only access to
the stdout and stderr channels is allowed.</P>
<P>Ayam scripting interface commands that directly manipulate the user
interface are also not available (<CODE>uS</CODE>, <CODE>rV</CODE> etc.). Please refer to the
documentation of the scripting interface commands about their availability
in the safe interpreter
(see section
<A HREF="ayam-6.html#sccomm">Procedures and Commands</A>).</P>
<P>In addition, access to global variables deserving protection like
<CODE>env</CODE>, <CODE>ay</CODE>, <CODE>ayprefs</CODE> is not allowed. In fact, the safe
interpreter has a completely separate set of variables. Transfer of
data between both interpreters must be arranged manually from the
Ayam interpreter (i.e.&nbsp;with scripts that run in the Ayam console).</P>
<P>With the help of scripts, that run in the Ayam interpreter, more commands
may be transferred to or made available in the safe interpreter.
But this may, of course, open security holes again.</P>
<P>Full access from Script objects to the complete scripting interface
may be re-enabled by recompiling Ayam.
If this is enabled and scene files containing Script
objects are loaded, Ayam will raise a warning dialog, offering to
temporarily disable all Script objects that will be read. The Script
objects will be disabled using their <CODE>"Active"</CODE> Script object property
and may be enabled again after careful inspection of the script code
manually or using the main menu entry <CODE>"Special/Enable Scripts"</CODE>.</P>

<H4><A NAME="s3"></A> Transformation Support</H4>

<P>Even though, initially, Script objects do not show and use the
Transformations property, they can support transformations under
certain circumstances.
To enable this support, a NP tag with the value <CODE>"Transformations"</CODE>
must be added to the Script object (i.e.&nbsp;the Transformations property
must be visible in order to be effective).<BR>
Now, the result(s) of the script can, additionally, be manipulated by
the standard interactive modelling actions, like move or scale.</P>
<P>Note, that upon provide or conversion the transformations from the
Script object will be added to the transformations of the objects
created by the script in the same way as by the delegate
transformations tool, which fails for complex setups (e.g.&nbsp;shear
transformations).
However, if the objects created by the script have editable points,
this problem can be avoided by using the <CODE>"applyTrafo"</CODE> command
in the script.</P>



<H4><A NAME="s3"></A> Conversion Support</H4>

<P>Script objects convert to the objects they create/modify
using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>When converting in place, some special rules are in effect:
<OL>
<LI>If there is just one created/modified object, its tags
are appended to the tags of the Script object and its material
setting only takes precedence if there is actually a material set.</LI>
<LI>If there are multiple created/modified objects, the
Script object is transformed into a Level object, keeping its tags
and material settings.</LI>
<LI>The created/modified objects will become children of the new
Level object (with tags and material properties unchanged).</LI>
<LI>The current children of the Script object will be removed prior
to conversion. If this fails (e.g.&nbsp;due to references), they may end
up in the object clipboard.</LI>
</OL>
</P>
<P>If the script created a master object and instances of this master, normal
conversion will <EM>not</EM> be able to duplicate this relationship
(due to the copy semantics of instance objects, see also section
<A HREF="#instclip">Instances and the Object Clipboard</A>).
To get around this, just copy the Script object and then use
in place conversion on the copy.</P>

<H4><A NAME="s3"></A> Caps and Bevels</H4>

<P>Script objects of type <CODE>"Create"</CODE> and <CODE>"Modify"</CODE> support the standard
caps as lined out in section
<A HREF="#capsprop">Caps Property</A>
and the standard bevels as lined out in section
<A HREF="#bevelsprop">Bevels Property</A>.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>The boundary names are <CODE>U0</CODE>, <CODE>U1</CODE>, <CODE>V0</CODE>, and <CODE>V1</CODE>.</P>
<P>By default, the corresponding properties are not available. To make
them visible, <CODE>NP</CODE> tags need to be added to the Script object.</P>
<P>The caps and bevels from the Script object will be added to all
created/modified objects that do not possess own caps and bevels already
and that support caps and bevels.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Script objects will be exported to RIB files as the objects
they create/modify.</P>



<H4><A NAME="s3"></A> <A NAME="scriptobjex"></A> Parametric Line Example</H4>


<P>This section illustrates the development of a
Script object for parametric lines, otherwise unavailable in Ayam.</P>
<P>We start with a simple version, that first creates a NURBS curve object with
two control points and then places the control points each at +/&minus;
half the
desired line length on the X-axis. Just copy the following code to the
Script property of a Script object of type <CODE>"Create"</CODE>, and activate it.
<HR>
<PRE>
set length 1
crtOb NCurve -length 2
sL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</PRE>
<HR>
</P>
<P>
<CENTER>
<IMG SRC="pics/scriptex1.gif" HEIGHT=222 WIDTH=724  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Simple Script for Parametric Line Primitive</FONT></CENTER><P><CENTER>
</CENTER>
</P>


<P>This code works, but if lines of a different length than 1 are needed,
the user must edit the script which is not very convenient and error
prone.<BR>
A complete, easy to use, and safe GUI for the length parameter
can be added by changing the script code to:
<HR>
<PRE>
addScriptProperty LineAttr {{Length 2.0 length}}
crtOb NCurve -length 2
sL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</PRE>
<HR>

resulting in a new clickable
graphical user interface as can be seen in the following image:</P>
<P>
<CENTER>
<IMG SRC="pics/scriptex2.gif" HEIGHT=220 WIDTH=724  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Parametric Line Primitive with Parameter GUI</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<P>The newly inserted call to <CODE>addScriptProperty</CODE> does quite a bit
of complicated setup/management code, which is also all too easy
to do wrong, given that there are actually two interpreters involved
and certain things must&thinsp;/&thinsp;must not be done on the first
script run (e.g.&nbsp;after being read from a scene file).<BR>
The GUIs created this way are, however, limited to four basic
GUI element types and all members of the respective data arrays
will be saved to scene files.
See also section 
<A HREF="ayam-6.html#scaddscriptproperty">addScriptProperty</A>.</P>
<P>The manual but more flexible way of creating/managing a property GUI
would look like this:
<HR>
<PRE>
# Ayam, save array: LineAttrData
if { ![info exists ::LineAttrData] } {
    array set ::LineAttrData {
        Length 1
        SP {Length}
    }
}
if { ![info exists ::LineAttrGUI] } {
    set w [addPropertyGUI LineAttr]
    addParam $w LineAttrData Length
}
set length $::LineAttrData(Length)
crtOb NCurve -length 2
sL
setPnt 0 [expr {-$length/2.0}] 0.0 0.0 1.0
setPnt 1 [expr {$length/2.0}] 0.0 0.0 1.0
</PRE>
<HR>
</P>
<P>To actually see the property GUI, a <CODE>"NP"</CODE> (new property) tag
with the value <CODE>"LineAttr"</CODE> would also have to be added to the
Script object.</P>
<P>The manual GUI setup code first creates a Tcl array essential to manage the
data of an Ayam object property (LineAttrData). Then, the LineAttr
property GUI is created and a GUI element is added to the GUI using
<CODE>"addParam"</CODE>.
Note that the <CODE>"addPropertyGUI"</CODE> command expects for a property
named <CODE>"SomePropertyName"</CODE> a corresponding property data array
named <CODE>"SomePropertyNameData"</CODE> to exist.
The GUI setup code should just run once, therefore it checks for the
presence of the variable <CODE>"LineAttrGUI"</CODE> (which is created on the first
run of <CODE>"addPropertyGUI"</CODE>) first.
See also sections
<A HREF="ayam-6.html#scaddpropertygui">Property GUI Management</A>
and
<A HREF="ayam-6.html#ayproparr">Global Property Management and Data Arrays</A>
for more information about property GUIs and the Ayam scripting interface.</P>
<P>Finally, to enable saving of the parameter value in the new property
<CODE>"LineAttr"</CODE> to scene files, a comment must be prepended to the
script (<CODE>"Ayam, save array: LineAttrData"</CODE>), and to enable
multiple and individually parameterised copies of this
Script object, a <CODE>"SP"</CODE> entry needs to be added to the
<CODE>"LineAttrData"</CODE> array as well.</P>
<P>The complete script is also available as example script file
<CODE>"scripts/crtlinegui.tcl"</CODE> in the Ayam distribution.</P>

<H4><A NAME="s3"></A> Hierarchy Building Example</H4>


<P>This example script demonstrates the scene traversal and
hierarchy building capabilities available to Script objects since
Ayam 1.16.</P>
<P>Create a Script object, and add two children to it, a box and a
NURBS curve (order 2, knot type: chordal works best). Then add the following
script to the Script object:
<HR>
<PRE>
# this script needs object type "Modify" and two children:
# a box/sphere and a curve
withOb 1 {estlenNC len}
cutOb
crtOb Clone
goDown -1
pasOb -move
goUp
sL
getProp
set CloneAttrData(NumClones) [expr round($len)]
setProp
</PRE>
<HR>

This little script first determines the length of the curve,
then it creates a Clone object and moves the children of the Script
object to it (via the object clipboard). Finally, the Clone object
is parameterised, so that the trajectory is completely filled (assuming
that each copy of the first child needs one length unit on the trajectory)
with objects.
The curve can now be modified using interactive modelling actions,
or its length can be changed, and the trajectory will always be completely
filled with an appropriate number of box objects.
See example image below (compare the Clone configurations from
the two different trajectory curves):</P>
<P>
<CENTER>
<IMG SRC="pics/scriptex3.gif" HEIGHT=300 WIDTH=601  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Hierarchy Building Script Object Example</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="customobj"></A> Custom Objects Management</H3>

<P>Custom objects are plugins that extend the Ayam capabilities by
defining entirely new types of e.g.&nbsp;geometric objects. This may
be done easily, because the Ayam core is written in a modelling
paradigm independent way.</P>
<P>Custom objects may also define own modelling tools. Those can
usually be found in the <CODE>"Custom"</CODE> main menu.</P>
<P>Unlike other modelling helper plugins, custom object plugins
will be loaded automatically with the scene files that contain
such objects. Note, that this only works properly if the preference
option <CODE>"Main/Plugins"</CODE> is correctly set.</P>
<P>Several custom object plugins are already distributed with Ayam. Those
are documented in the next sections.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sfcurveobj"></A> SfCurve (Superformula Curve) Object</H3>

<P>The SfCurve object creates a superformula curve from four parameters
named <CODE>m</CODE>, <CODE>n1</CODE>, <CODE>n2</CODE>, and <CODE>n3</CODE> (see also the image below).
The superformula is a generalization of the superellipse; in polar
coordinates it is defined as:</P>







<P>
<BLOCKQUOTE><CODE>
<DM>
 r(t) = (cos((m&times;t)/4)<SUP>n2</SUP> + sin((m&times;t)/4)<SUP>n3</SUP>)<SUP>-(1/n1)</SUP> 
</DM>
</CODE></BLOCKQUOTE>
</P>
<P>where r is the radius and t the angle. The SfCurve object allows
to specify start and end values for t as well as the number of
sample points in between.<BR>
The generated NURBS curve is always closed, but the order may be configured
freely.</P>
<P>
<CENTER>
<IMG SRC="pics/sfcurve.gif" HEIGHT=358 WIDTH=358  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Superformula Curve from Parameters 10, 22, -11, 3</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The following table briefly lists some capabilities of the SfCurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
SfCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>No*
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">SfCurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sfcurveattrprop"></A> SfCurveAttr Property</H4>

<P>The SfCurve object provides the following parameters:
<UL>
<LI>The parameters <CODE>"M"</CODE>, <CODE>"N1"</CODE>, <CODE>"N2"</CODE>, and <CODE>"N3"</CODE>
control the superformula.
</LI>
<LI><CODE>"TMin"</CODE> is the start angle.</LI>
<LI><CODE>"TMax"</CODE> is the end angle.

<P>Note that the angle defined by <CODE>"TMin"</CODE> and <CODE>"TMax"</CODE> may
actually be larger than 360, as can be seen in the image below:</P>
<P>
<CENTER>
<IMG SRC="pics/sfcurvetmax.gif" HEIGHT=313 WIDTH=312  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Superformula Curve with TMax 1440</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Also note that e.g.&nbsp;setting <CODE>"TMin"</CODE> to 1 and <CODE>"TMax"</CODE> to 361
may deliver better results than using the default values.</P>

</LI>
<LI><CODE>"Sections"</CODE> is the number of sample points.
Curves with sharp features may need high values of about 100.
</LI>
<LI><CODE>"Order"</CODE> is the desired order of the curve.
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Operation Support</H4>

<P>The superformula curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>Furthermore, the superformula curve fully supports the revert, refine, and
coarsen operations.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>SfCurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bcurveobj"></A> BCurve (Basis Curve) Object</H3>

<P>The BCurve (basis curve) object creates a cubic parametric curve from a
number of rational control points and a basis (which is a 4 by 4
matrix).<SMALL TITLE="Since 1.25."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
The basis defines the interpretation of the control points, similar to the
bicubic patch mesh primitive of the RenderMan interface, see also
section 
<A HREF="#patchmeshobj">PatchMesh Object</A>.
The BCurve therefore represents a range of parametric curves
like B-Spline, Bezier, Catmull-Rom, and Hermite splines.</P>
<P>
<CENTER>
<IMG SRC="pics/bcurve.gif" HEIGHT=258 WIDTH=437  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">BCurves of Basis Types <EM>Bezier</EM> (ul), <EM>B-Spline</EM> (ur), <EM>Catmull-Rom</EM> (ll), and <EM>Hermite</EM> (lr)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>See also the image above depicting simple example curves of some
basis types.</P>
<P>The following table briefly lists some capabilities of the BCurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
BCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">BCurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="bcurveattrprop"></A> BCurveAttr Property</H4>

<P>The BCurve object provides the following parameters:
<UL>
<LI><CODE>"Closed"</CODE> determines whether the curve is closed.
</LI>
<LI><CODE>"Length"</CODE> is the number of control points, valid values depend
on the basis type&thinsp;/&thinsp;step below, see also the corresponding
discussion in section
<A HREF="#pmattr">PatchMeshAttr Property</A>.<BR>
The arrow buttons of this entry field add/subtract the current
step size of the curve to/from the respective value when the
<CODE>&lt;Control&gt;</CODE> key is held down.
</LI>
<LI><CODE>"BType"</CODE> is the basis type. The following basis types are available:
<CODE>"Bezier"</CODE>, <CODE>"B-Spline"</CODE>, <CODE>"Catmull-Rom"</CODE>,
<CODE>"Hermite"</CODE>, <CODE>"Power"</CODE>, and <CODE>"Custom"</CODE>.
</LI>
<LI><CODE>"Basis"</CODE> is the basis.
</LI>
<LI><CODE>"BStep"</CODE> is the step size, this value must be 1, 2, 3, or 4.
</LI>
<LI>See section 
<A HREF="#ncattr">NCurveAttr</A> for a description
of the parameters: <CODE>"Tolerance"</CODE> and <CODE>"DisplayMode"</CODE>.</LI>
</UL>
</P>
<P>The entries <CODE>"Basis"</CODE> and <CODE>"BStep"</CODE> are only visible, if the
basis type is <CODE>"Custom"</CODE>.</P>



<H4><A NAME="s3"></A> Operation Support</H4>

<P>The basis curve may be converted to an ordinary NURBS curve using the
main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>Furthermore, the basis curve fully supports the revert, open, close, refine,
and coarsen operations.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>BCurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>

<H4><A NAME="s3"></A> Scripting Interface</H4>

<P>The BCurve object plugin defines a scripting interface command to convert
BCurve objects to a different basis,
see also section 
<A HREF="ayam-6.html#sctobasisbc">tobasisBC</A>.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sdcurveobj"></A> SDCurve (Subdivision Curve) Object</H3>

<P>The SDCurve (subdivision curve) object creates a curve from a
number of non-rational control points.<SMALL TITLE="Since 1.26."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Subdivision curves are similar to subdivision surfaces, but a polygon is
subdivided to a limit curve instead of a polygonal mesh to a limit surface,
see also section 
<A HREF="#sdmeshobj">SDMesh Object</A>.</P>
<P>
<CENTER>
<IMG SRC="pics/sdcurves.gif" HEIGHT=326 WIDTH=351  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">SDCurve Examples of Level 4 (Chaikin: u, Cubic: l)</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>See also the image above depicting four simple example curves.</P>
<P>The following table briefly lists some capabilities of the SDCurve object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
SDCurve</TD><TD>No</TD><TD>No</TD><TD>NCurve</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">SDCurve Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sdcurveattr"></A> SDCurveAttr Property</H4>

<P>The SDCurve object provides the following parameters:
<UL>
<LI><CODE>"Closed"</CODE> determines whether the curve is closed.
</LI>
<LI><CODE>"Length"</CODE> is the number of control points.
</LI>
<LI><CODE>"Type"</CODE> is the subdivision method to use, the currently
implemented methods are <CODE>"Chaikin"</CODE> and <CODE>"Cubic"</CODE>.<BR>
For each iteration, the <CODE>"Chaikin"</CODE> method inserts two new points
into each section of the original control polygon, all old points are
removed.<BR>
The <CODE>"Cubic"</CODE> method inserts one new point into each section of the
original control polygon, the original points will not be deleted but
rather moved to the barycenter of the two surrounding new points and
the original point.
</LI>
<LI><CODE>"Level"</CODE> determines the number of iterations of the subdivision
algorithm to carry out.
</LI>
<LI><CODE>"SLength"</CODE> is the number of points generated by the
subdivision algorithm.</LI>
</UL>
</P>



<H4><A NAME="s3"></A> Operation Support</H4>

<P>The subdivision curve may be converted to an ordinary NURBS curve of
order 2 using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>
<P>Arbitrary curve objects can also be converted to subdivision curves using
the provided conversion tool that is accessible via the main menu entry
<CODE>"Custom/SDCurve/From Curve"</CODE>. This tool supports NCurve, ICurve,
and ACurve objects directly, all other curve objects need just to provide
their points to be supported.</P>
<P>Furthermore, the subdivision curve fully supports the revert, open,
close, refine, and coarsen operations.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>SDCurve objects never directly appear in RIB output (only indirectly as trim
curve).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="metacompobj"></A> <A NAME="metaobjobj"></A> Metaball Object</H3>

<P>
<CENTER>
<IMG SRC="pics/meta.gif" HEIGHT=226 WIDTH=308  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">A Metaball Object from Six Meta Components</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>A metaball object is a custom object (see also section
<A HREF="#customobj">Custom Object</A>).
It allows you to model with implicit surfaces in realtime.</P>
<P>To start modelling you should first create a <CODE>"MetaObj"</CODE> object
using the menu entry
<CODE>"Create/Custom Object/MetaObj"</CODE> (if this menu entry is not
available, you have to load the <CODE>"metaobj"</CODE> plugin using the menu entry
<CODE>"File/Load Plugin"</CODE> first).
<CODE>"Create/Custom Object/MetaObj"</CODE> creates a so called meta world with a
single meta component (a sphere) in it. The meta world is represented
by a <CODE>"MetaObj"</CODE> object and the component by a <CODE>"MetaComp"</CODE>
object which is a child of the <CODE>"MetaObj"</CODE> object.</P>
<P>The complete template for the MetaObj object hierarchy, consequently,
looks like this:
<BLOCKQUOTE><CODE>
<PRE>
+-MetaWorld(MetaObj)
  |-C1(MetaComp)
  |-[...
  \-Cn(MetaComp)]
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>The following table briefly lists some capabilities of the MetaObj and
MetaComp objects.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
MetaObj</TD><TD>MetaComp<SUP>+</SUP></TD><TD>Yes</TD><TD>PolyMesh</TD><TD>No</TD></TR><TR><TD>
MetaComp</TD><TD>No</TD><TD>No</TD><TD>N/A</TD><TD>No
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">MetaObj/MetaComp Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>Meta components live only in a meta world, therefore it makes no sense
to create <CODE>"MetaComp"</CODE> objects in other places except as a
child of a <CODE>"MetaObj"</CODE> object. Type, parameters, and
transformation attributes of the meta components define the function
of an implicit surface. The <CODE>"MetaObj"</CODE> object, that represents
the meta world, evaluates this function on a regular three-dimensional
grid and creates a polygonal representation for a specific function
value (the so called threshold value).</P>



<H4><A NAME="s3"></A> <A NAME="metaobjattrprop"></A> <A NAME="moattr"></A> MetaObjAttr Property</H4>

<P>The following attributes control the creation of the implicit surface:
<UL>
<LI>With the parameter <CODE>"NumSamples"</CODE> you specify the resolution of the
three-dimensional regular grid, on which the implicit function is
evaluated, in each dimension.
A higher number of samples results in better quality but more polygons
are created and more CPU power and memory are needed. For modelling
you should set this to a lower value of about 40. For final rendering
you may increase this to about 160.
</LI>
<LI><CODE>"IsoLevel"</CODE>, defines the threshold value for that a polygonal
representation of the implicit function should be created. Normally, you
should not need to change this value.
</LI>
<LI>To show the actual bounds of the meta world, you may enable
the <CODE>"ShowWorld"</CODE> parameter.</LI>
</UL>
</P>
<P>New in Ayam 1.5 is an adaptive calculation mode of the implicit
surface. It may be switched on using the new attribute
<CODE>"Adaptive"</CODE>. In the adaptive calculation mode, Ayam tries
to vary the resolution of the resulting polygonal mesh according to
the features of the implicit surface in order
to capture fine details, even though a coarse grid is used.
This is not done using a successively refined grid but by a
refinement of the triangles created by the original algorithm
(see also XXXX).
You may control the adaptation process using three parameters:
<CODE>"Flatness"</CODE>, <CODE>"Epsilon"</CODE>, and <CODE>"StepSize"</CODE>.
If <CODE>"Adaptive"</CODE> is set to <CODE>"automatic"</CODE>, Ayam will
not use the adaptive calculation while a modelling action is in
progress. This mode has been introduced, because the adaptive mode
may consume a considerable amount of CPU resources.</P>
<P>While modelling with meta balls you may add other <CODE>"MetaComp"</CODE> objects
to the <CODE>"MetaObj"</CODE> object and parameterise them.
A <CODE>"MetaComp"</CODE> object has the following properties.</P>

<H4><A NAME="s3"></A> <A NAME="metacompattrprop"></A> <A NAME="mcattr"></A> MetaCompAttr Property</H4>

<P>
<UL>
<LI><CODE>"Formula"</CODE> specifies the type of the meta component.
The following types are available: Metaball, Torus, Cube, Heart, and
Custom. The latter gives you the possibility to use your own formulas.
</LI>
<LI>With the parameter <CODE>"Negative"</CODE> you define a component with a
negative effect on the implicit function value.
Negative components are not visible on their own but they are useful
for modelling holes. Just try it.</LI>
</UL>
</P>
<P>The other parameter are specific to the type of the component:</P>

<H4><A NAME="s3"></A> <A NAME="mbcp"></A> Metaball</H4>

<P>
<UL>
<LI><CODE>"Radius"</CODE> sets the radius of the metaball</LI>
<LI><CODE>"EnergyCoeffA"</CODE>, <CODE>"EnergyCoeffB"</CODE>, and <CODE>"EnergyCoeffC"</CODE>
are some parameters for the metaball formula.
Usually you can leave those parameters at their default values.
If you change them, be careful.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> <A NAME="mtcp"></A> Torus</H4>

<P>
<UL>
<LI><CODE>"Ri"</CODE> is the inner radius of the torus,</LI>
<LI><CODE>"Ro"</CODE> is the outer radius of the torus,</LI>
<LI><CODE>"Rotate"</CODE> rotates the torus about 90 degree.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> <A NAME="mucp"></A> Cube</H4>

<P>
<UL>
<LI><CODE>"EdgeX"</CODE>, <CODE>"EdgeY"</CODE>, and <CODE>"EdgeZ"</CODE>, let you define the
sharpness of the edges of the cube.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> <A NAME="cucp"></A> Custom</H4>

<P>
<UL>
<LI><CODE>"Expression"</CODE> is a piece of Tcl script, that represents your
own custom formula for a meta component. The expression may call any
Tcl commands to calculate a field value from the current grid position,
which is given in the global variables <CODE>"x"</CODE>, <CODE>"y"</CODE>, and
<CODE>"z"</CODE>.
The expression simply has to return the calculated field
value.<SMALL TITLE="Since 1.27."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>

Here is an example for a custom expression:
<HR>
<PRE>
expr {pow($x,4)+pow($y,4)+pow($z,4)}
</PRE>
<HR>

Note that those expressions are called many times
and since they are programmed in Tcl, this can be quite slow.
You should use any tricks (like the curly braces
in the expr-statement above) to speed up the expression.<BR>
Also note that in former versions of Ayam, the global variable
<CODE>"f"</CODE> had to be set to return the field value. This is no longer
the case, but old expression code that ends with
<CODE>set f [expr ...]</CODE> is still valid.</LI>
</UL>
</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>Metaball objects may be converted to PolyMesh
objects using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>Metaball objects will be exported as RiPointsGeneralPolygons primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.&nbsp;a RiGeneralPolygon).</P>
<P>PV tags are currently not supported.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sdnpatchobj"></A> SDNPatch Object</H3>

<P>
<CENTER>
<IMG SRC="pics/sdnpatch.gif" HEIGHT=215 WIDTH=590  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">SDNPatches, l: control mesh, m: subdivided mesh with knot, r: subdivided mesh without knot</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The SDNPatch custom object is available since Ayam 1.16 and
allows to model with Subdivision NURBS, which extend the traditional
subdivision scheme with knot values and rational coordinates. See also
the image above, where in the middle mesh a knot value has been set in
the left hand side of the mesh.
The SDNPatch plugin is based on libsnurbs by Tom Cashman.</P>
<P>There are some special modelling actions for Subdivision NURBS
defined (see below) and there are PLY import/export facilities.
Furthermore, there are two conversion operations that convert
NURBS patch and PolyMesh objects to SDNPatch objects.
Thus, also SDMesh objects may be converted to SDNPatch
objects in two steps: first to a PolyMesh then to the SDNPatch.</P>
<P>Please note that the plugin is still in experimental state,
there is limited error checking and crashes may occur, if
the special modelling actions are used.</P>
<P>The following table briefly lists some capabilities of the SDNPatch object.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Type</B></TD><TD><B>Parent of</B></TD><TD><B>Material</B></TD><TD><B>Converts to&thinsp;/&thinsp;Provides</B></TD><TD><B>Point Edit</B></TD></TR><TR><TD>
SDNPatch</TD><TD>No</TD><TD>Yes</TD><TD>PolyMesh</TD><TD>Yes
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">SDNPatch Object Capabilities</FONT></CENTER><P><CENTER>
</CENTER>
</P>

<H4><A NAME="s3"></A> <A NAME="sdnpatchattrprop"></A> <A NAME="sdnpattr"></A> SDNPatchAttr Property</H4>

<P>The SDNPatchAttr property allows to set the following SDNPatch specific
attributes:
<UL>
<LI><CODE>"Degree"</CODE> is the degree of the subdivision NURBS surface,
the only valid values are currently 3, 5, and 7.</LI>
<LI><CODE>"Level"</CODE> is the subdivision level, a high level leads to
many polygons and a smooth surface; useful values range from 0 to 5.</LI>
<LI><CODE>"IsRat"</CODE> informs, whether the patch
is rational (has any weight values different from
1.0).</LI>
<LI><CODE>"NPolys"</CODE> is the number of polygons generated by the
subdivision algorithm.</LI>
</UL>
</P>



<H4><A NAME="s3"></A> <A NAME="sdnpact"></A> SDNPatch Modelling Actions</H4>

<P>This section, briefly, explains the special modelling actions defined
for the SDNPatch custom object. In order to select a face or edge for
such an operation, just select all the control points defining the face
or edge.
All modelling actions can be started via the <CODE>"Custom/SDNPatch"</CODE>
main menu.
<UL>
<LI><CODE>"Face Extrude"</CODE>, new faces are inserted in the mesh at all
edges of the selected faces, the selected faces themselves are displaced
along their respective normals. If this operation is picking the wrong
direction, try to revert all faces first, see below.
Since Ayam 1.17 this operation has two parameters that control the
offset of the extrusion operation (parameter <CODE>"Length"</CODE>) and a
scaling factor applied to the new displaced set of control points
(parameter <CODE>"Scale"</CODE>). The Length parameter may be negative,
to revert the direction of the extrusion.</LI>
<LI><CODE>"Face Remove"</CODE>, the selected face is removed from the mesh.</LI>
<LI><CODE>"Face Merge"</CODE>, the first two selected faces are removed
from the mesh, the neighboring patches of the second face are connected
to the neighboring faces of the first face.
The decision, which vertices of the faces will actually be connected,
depends on the relative vertex distances: you need to move the two
faces near each other to make clear, how the new connection shall be
established.</LI>
<LI><CODE>"Face Connect"</CODE>, the first two selected faces are removed
from the mesh, the neighboring patches of the second face are connected
to the neighboring faces of the first face via a set of new faces.
The decision, between which vertices of the faces the new faces are built,
depends on the relative vertex distances: you need to move the two
faces near each other to make clear, how the new connection shall be
established.</LI>
<LI><CODE>"Reset All Knots"</CODE>, set all knot values to 1.0 (the default).</LI>
<LI><CODE>"Set Knot"</CODE>, set the knot value of the selected edge.</LI>
<LI><CODE>"Revert"</CODE>, reverts all faces.</LI>
<LI><CODE>"Merge"</CODE>, merges multiple SDNPatch objects into one new.</LI>
<LI><CODE>"Import PLY"</CODE>, import a PLY file.</LI>
<LI><CODE>"Export PLY"</CODE>, export the currently selected SDNPatch object
to a PLY file.</LI>
</UL>
</P>
<P>In addition, there are two conversion operations that convert
NURBS patch objects (or NURBS patch providing objects) and PolyMesh
objects (or PolyMesh providing objects) to SDNPatch objects.</P>
<P>Note that the PolyMesh to SDNPatch conversion only accepts closed
quadrilateral polygon meshes (triangles are omitted) and expects
an optimized mesh (i.e.&nbsp;adjacent faces should share the same vertices).</P>

<H4><A NAME="s3"></A> Conversion Support</H4>

<P>SDNPatch objects may be converted to PolyMesh
objects using the main menu entry <CODE>"Tools/Convert"</CODE>.</P>

<H4><A NAME="s3"></A> RIB Export</H4>

<P>SDNPatch objects will be exported as <CODE>RiPointsGeneralPolygons</CODE> primitives
(regardless of whether the actual configuration would fit into a simpler
polygonal primitive of the RenderMan interface, e.g.&nbsp;a <CODE>RiGeneralPolygon</CODE>).</P>
<P>PV tags are currently not supported.</P>


<H2><A NAME="stdprop"></A> <A NAME="ss4.10">4.10</A> <A HREF="ayam.html#toc4.10">Standard Properties</A>
</H2>

<P>Most Ayam objects have standard properties. They are used
to control transformations and common attributes of objects.
The following sections describe the standard properties
<CODE>"Transformations"</CODE>, <CODE>"Attributes"</CODE>, <CODE>"Material"</CODE>, <CODE>"Shaders"</CODE>,
and <CODE>"Tags"</CODE>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="transformationsprop"></A> <A NAME="trap"></A> Transformations Property</H3>

<P>Use the <CODE>"Transformations"</CODE> property to edit the location, orientation,
and size of an object.</P>
<P>The corresponding property GUI contains the following elements:
<UL>
<LI><CODE>"Reset All!"</CODE> immediately resets all transformation
attributes to the default values.
</LI>
<LI><CODE>"Translate_X (_Y, _Z)"</CODE> is the displacement of the
object from the world origin in X (Y, Z) direction.
</LI>
<LI><CODE>"Rotate_X (_Y, _Z)"</CODE> is the angle (in degrees)
of the rotation of the object around the X (Y, Z) axis.
See below for more information on how to use these
entries.</LI>
<LI><CODE>"Quaternion"</CODE> the quaternion that is used to determine
the orientation of the object in space.
</LI>
<LI><CODE>"Scale_X (_Y, _Z)"</CODE> determines a scale factor that will be
applied to the object in the direction of the local X (Y, Z) axis.</LI>
</UL>
</P>
<P>The transformations are applied to the object in the following order:
Scale, Rotation, Translation.</P>
<P>How to use the rotation attributes?
<A NAME="gimb"></A> </P>
<P>The orientation of an object in space may be expressed using
so called Euler angles. This notation (simply three angles determining
a rotation about the principal axes of the coordinate system)
suffers from a phenomenon called <EM>gimbal lock</EM>.</P>
<P>To avoid gimbal locks, Ayam internally holds the orientation
of an object in a quaternion.
This quaternion not only holds information about the angles
but also about the order in which partial rotations occurred.</P>
<P>It is important to know, that the values of the angles of
the rotation property must not be read in a way that
the object will first be rotated around X by x-angle degrees
then around Y by y-angle degrees then around Z by z-angle degrees.
In fact, no information about the order in which partial
rotations occurred may be derived from that three values.
This implies, that e.g.&nbsp;the values 0 0 45 may actually denote
a different orientation than the very same values 0 0 45.</P>
<P>Rotating an object is easy, simply <EM>add</EM> the amount about
which the object shall be rotated to the value currently
displayed in the appropriate entry.</P>
<P>For example, if an object is to be rotated 45 degrees about X and the
x-angle entry displays a 30, enter 75.
Then press the apply button.<BR>
If multiple entries are changed the rotations made will be
in the order X (if changed) then Y (if changed) then Z (if changed).
Do not change more than one entry at once unless you exactly
know what you are doing.</P>
<P>Undoing a single rotation works in the same way, just use a subtraction
instead of an addition.</P>
<P>Undoing all rotations (resetting the object to its original orientation)
is simple too: enter 0 for all three entries at once,
then press apply.</P>
<P>To copy just the orientation of an object to other objects
using the property clipboard, all Translate and Scale
property elements should be marked/selected via double clicks,
then <CODE>"Edit/Copy Property"</CODE> can be used.
Just marking the Rotate elements and then using
<CODE>"Edit/Copy Marked Prop"</CODE>
will <EM>not</EM> work, because then the quaternion will not be copied
properly.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="attributesprop"></A> <A NAME="attrs"></A> Attributes Property</H3>

<P>The <CODE>"Attributes"</CODE> property of an object contains currently:
<UL>
<LI><CODE>"Objectname"</CODE>, the name of the object. It is also displayed
in the object listbox or tree and may be written to RIB streams.
</LI>
<LI><CODE>"Hide"</CODE>, if this attribute is set this object is not drawn.
It may also be excluded from RIB export.
</LI>
<LI><CODE>"HideChildren"</CODE>, if this attribute is set, the child objects
of this object are not drawn. This attribute is e.g.&nbsp;used by
<CODE>"NPatch"</CODE> objects to prevent the trim curves from being drawn
in normal views.
</LI>
<LI><CODE>"RefCount"</CODE>, just displays how many objects point to this
object e.g.&nbsp;through master-instance or object-material relationships.
Objects with a reference count higher than zero may not be deleted.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="materialprop"></A> <A NAME="matprop"></A> Material Property</H3>

<P>The <CODE>"Material"</CODE> property allows you to connect geometric objects
to material objects (see also section
<A HREF="#materialobj">Material Object</A>).
The material property GUI consist of the following elements:
<UL>
<LI><CODE>"Clear Material!"</CODE> immediately clears any connection
of the current object to its material.
</LI>
<LI><CODE>"Add/Edit Material!"</CODE> adds a material to the
current object (if it has none) and immediately selects
the new material object for editing. If the current object
already has a material, this material object is searched for
and selected for editing.
</LI>
<LI><CODE>"Materialname"</CODE> is the name of the material of this object.
If the name is changed, the object will be disconnected from the
old material and connected to the new material.
An easier way to connect geometric objects to material objects is to simply
drop the geometric objects onto the material object using drag and drop
in the tree view.</LI>
</UL>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="lightshaderprop"></A> <A NAME="exteriorprop"></A> <A NAME="interiorprop"></A> <A NAME="displacementprop"></A> <A NAME="surfaceprop"></A> <A NAME="imagerprop"></A> <A NAME="atmosphereprop"></A> <A NAME="shd"></A> Shader Properties</H3>

<P>Shader properties are used to attach shaders of a certain type to objects.
The name of the property contains the type of the shader, e.g.&nbsp;light
shaders may be attached using a property named <CODE>"LightShader"</CODE> only.
Other types of shaders or shader properties available are: <CODE>"Surface"</CODE>,
<CODE>"Displacement"</CODE>, <CODE>"Interior"</CODE>, <CODE>"Exterior"</CODE>, <CODE>"Atmosphere"</CODE>,
and <CODE>"Imager"</CODE>.</P>
<P>Each shader property GUI, even if no shader is attached to an object,
starts with the <CODE>"Set new shader."</CODE>-button. This button allows
to select a new shader of the appropriate type.
If you press the <CODE>"Set new shader."</CODE>-button, a dialog with a
list of shaders pops up. If this list is empty, Ayam
is probably not set up properly (or you simply do not have
shaders of the appropriate type). Check the preference setting
<CODE>"Main/Shaders"</CODE>.
After a new shader has been set, the arguments of the shader will be
parsed and a GUI will be generated to allow the arguments of the shader
to be filled with values.</P>
<P>The <CODE>"Delete shader."</CODE>-button may be used to
delete the current shader from the selected object.</P>
<P>The <CODE>"Default Values."</CODE>-button resets all arguments
of the shader to the default values.
See also section 
<A HREF="#workshd">Working with Shaders</A> below.</P>
<P>All other elements of the shader property GUI depend on the currently
attached shader, i.e.&nbsp;they represent the arguments of the shader
function.</P>



<P><B>Shader Parsing</B>
<A NAME="parseshd"></A> </P>
<P>Parsing a shader incorporates detecting the type of the shader and
reading the names, types, and default values of all shader arguments.</P>
<P>Shaders will be parsed on the following occasions:
<UL>
<LI>application startup,</LI>
<LI><CODE>"Scan for Shaders!"</CODE> button in preferences dialog,</LI>
<LI><CODE>"Special/Scan Shaders"</CODE> menu entry,</LI>
<LI><CODE>"ScanShaders"</CODE> option in <CODE>"Select Renderer"</CODE> dialog,</LI>
<LI><CODE>"Default Values"</CODE> button in shader property GUI.</LI>
</UL>
</P>
<P>Note that currently, Ayam only works properly with shaders
that have at most two dots in their file name and that Ayam will simply
skip all array arguments (and emit a warning message) while parsing
a shader. Those array arguments consequently never appear in the
shader property GUIs and RIBs exported by Ayam. Also note that
default values for shader arguments of type color will be silently
clamped to the range 0-255.</P>
<P>Some shaders use array arguments to define transformation matrices.
If this is the case and you have access to the shader source code
you may want to modify those shaders to enable working with the
transformation matrix carrying shader arguments. To do this, just
change all definitions of transformation matrix carrying floating
point arrays to real matrices. For instance, if the shader contains a</P>
<P><CODE>"float a_matrix_parameter[16]"</CODE></P>
<P>change this to</P>
<P><CODE>"matrix a_matrix_parameter"</CODE>.</P>
<P>Note that these changes of the shader argument definitions probably
also require changes of the shader source code that uses those arguments.
Ayam is able to deal with matrices because of their fixed size of 16
float values, and because libslcargs is able to deliver the default
values for a matrix (but not for an array!).</P>
<P>If Ayam has been compiled without a shader parsing library
(e.g.&nbsp;without libslcargs), Ayam will parse XML files created
by <CODE>"sl2xml"</CODE> from the K-3D project
(see <CODE>"http://www.k-3d.org/"</CODE>)
instead of compiled shaders.
The <CODE>"Set new shader."</CODE>-button will in this case always
open a file requester, allowing you to select a XML file,
that has been created by sl2xml.
Furthermore, the <CODE>"Default Values."</CODE>-button will not be available;
you have to use <CODE>"Set new shader."</CODE> instead.</P>
<P>From version 1.3 on, Ayam also supports shader parsing plugins to allow
parsing of shaders compiled with different shader compilers, see also
section 
<A HREF="ayam-8.html#spplugins">Shader Parsing Plugins</A>.</P>
<P>Finally, since version 1.25, there is a script that parses shader source
code, see also section 
<A HREF="ayam-6.html#slxmltcl">Shader Parsing</A>.</P>
<P><B>Working with Shaders</B>
<A NAME="workshd"></A> </P>
<P>The <CODE>"Default Values."</CODE>-button resets all arguments of the shader
to the default values.
Additionally, the compiled shader will be parsed again and the property GUI
will be adapted (new shader arguments will appear, removed shader arguments
will disappear).
Therefore, this button is quite handy if you have to deal with
changing shaders: just edit the shader, recompile it, then back
in Ayam just hit the <CODE>"Default Values."</CODE>-button. Note that
this destroys your possibly carefully adjusted shader argument values.</P>
<P>If you want to keep the old shader argument values when a shader
changes, simply copy the shader property using the property clipboard
(main menu: <CODE>"Edit/Copy Property"</CODE>) before
you load the new default values and paste the property
back using <CODE>"Edit/Paste Property"</CODE> after loading of the
new default values.
Beware! This works properly only, if the type of existing shader arguments
does not change and if no shader arguments are removed in
the new version of the shader.</P>
<P>It is also possible to just copy certain parameter values (shader arguments
whose types do not change) by selecting them using double-clicks
on the parameter names in the shader property GUI and then use
e.g.&nbsp;<CODE>"Edit/Copy Marked Prop"</CODE>
(see also the description of the property clipboard in section
<A HREF="ayam-2.html#propgui">Properties</A>).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="capsprop"></A> Caps Property</H3>

<P>Many tool object have a <CODE>"Caps"</CODE> property to easily close the
created surface.</P>
<P>
<CENTER>
<IMG SRC="pics/capprop.gif" HEIGHT=234 WIDTH=402  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Caps Property of NPatch Object</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The exact names of the attributes available in this property are
object type specific as each object types boundary names are different:
the boundary names of a Skin object are e.g.&nbsp;<CODE>"Left"</CODE>, <CODE>"Right"</CODE>,
<CODE>"Start"</CODE>, and <CODE>"End"</CODE>, whereas the boundary names of a NPatch object
are <CODE>"U0"</CODE>, <CODE>"U1"</CODE>, <CODE>"V0"</CODE>, and <CODE>"V1"</CODE> (see also the image
above).</P>
<P>To reduce GUI clutter, initially, the Caps property only contains buttons
that allow to enable/disable the associated cap and control appearance of
further options.</P>
<P>For each enabled cap a menu button will appear that allows to set the
corresponding cap type (see section 
<A HREF="#capp">CapAttr Property</A>
for more information on the available cap types).</P>
<P>In addition, the Caps property allows to create caps that integrate with
the progenitor surface of the corresponding tool object (after the potential
integration of bevels) via the additional parameter <CODE>"Integrate"</CODE>.
However, integration is only supported for the cap types
<CODE>"Simple"</CODE> and <CODE>"Simple3D"</CODE>. If integration is enabled and there
is a bevel that is not integrating with the progenitor surface, the
cap will integrate into the bevel instead.
Integration will change the number of provided objects and the parameters
of the progenitor surface.</P>
<P>Similar to Cap objects, MP tags can be set to object to control the middle
point in both simple modes (see also section
<A HREF="#mptag">MP (Mean Point) Tag</A>).</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bevelsprop"></A> Bevels Property</H3>

<P>Many tool object have a <CODE>"Bevels"</CODE> property to easily round the
otherwise sharp borders of the created surface.</P>
<P>
<CENTER>
<IMG SRC="pics/bevelprop.gif" HEIGHT=261 WIDTH=402  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Bevels Property of NPatch Object</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The exact names of the attributes available in this property are
object type specific as each object types boundary names are different:
the boundary names of a Skin object are e.g.&nbsp;<CODE>"Left"</CODE>, <CODE>"Right"</CODE>,
<CODE>"Start"</CODE>, and <CODE>"End"</CODE>, whereas the boundary names of a NPatch object
are <CODE>"U0"</CODE>, <CODE>"U1"</CODE>, <CODE>"V0"</CODE>, and <CODE>"V1"</CODE> (see also the image
above).</P>
<P>To reduce GUI clutter, initially, the Bevels property only contains buttons
that allow to enable/disable the associated bevel and control appearance of
further options.</P>
<P>Many attributes of the Bevels property are also available for the
Bevel object (see also 
<A HREF="#bevelp">BevelAttr Property</A>).
In addition to those attributes, the Bevels property allows to integrate
the created bevel surface with the progenitor surface of the corresponding
tool object via the additional parameter <CODE>"Integrate"</CODE>.
Integration will change the number of provided objects and the parameters
of the progenitor surface.</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tagsprop"></A> Tags Property</H3>

<P>Use the <CODE>"Tags"</CODE> property to edit the tags of an object.
See also the image below.</P>
<P>
<CENTER>
<IMG SRC="pics/tagcm.gif" HEIGHT=241 WIDTH=377  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Tags Property GUI with Context Menu</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>
<A NAME="tagpropcontm"></A> 
All tag entries have a context menu, where the corresponding tag can
be copied/added to the property
clipboard.<SMALL TITLE="Since 1.21."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Long and multiline tag values will be displayed in abbreviated
fashion (with an ellipsis &ndash; ...).</P>
<P>The tags property GUI also consists of the following standard
elements (see also above image):
<UL>
<LI><CODE>"Remove all Tags!"</CODE> immediately removes all tags
from the object.
</LI>
<LI><CODE>"Remove Tag!"</CODE> is a menu, that allows
to quickly select and remove a single tag from the object.
</LI>
<LI><CODE>"Add Tag!"</CODE> opens a small dialog window, where a new tag type
and value may be entered (see also the image below).
The tag type line has a default value menu, containing the most
important tag types.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL><BR>
After pressing the <CODE>"Ok"</CODE> button, a new entry will be added to the
tags property, displaying the new tag. Just click on the entry to get
back to the dialog, to remove the tag using <CODE>"Clear"</CODE> then <CODE>"Ok"</CODE>,
or to change the type or value of the tag.<BR>
The tag edit dialog supports multiline tag
editing.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Just enlarge the dialog window to switch to multiline editing.
Another way to control multiline mode is to use the keyboard
shortcuts <CODE>&lt;Alt-Down&gt;</CODE> and <CODE>&lt;Alt-Up&gt;</CODE>
respectively.
Note that in multiline mode, the <CODE>&lt;Enter&gt;</CODE>,
<CODE>&lt;Return&gt;</CODE>, and also
<CODE>&lt;Tab&gt;</CODE> key will behave differently.<BR>
The tag value widget also has a context menu, allowing text to be
fetched from the system clipboard or files.

<P>
<CENTER>
<IMG SRC="pics/addmodtag.gif" HEIGHT=99 WIDTH=300  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Add&thinsp;/&thinsp;Edit Tag Dialog</FONT></CENTER><P><CENTER>
</CENTER>
</P>
</LI>
</UL>
</P>
<P>The next sub-sections describe the tag types currently available in Ayam
and the plugins distributed with Ayam.
Note that foreign extensions and plugins may define their own types.</P>



<H2><A NAME="tags"></A> <A NAME="ss4.11">4.11</A> <A HREF="ayam.html#toc4.11">Tags</A>
</H2>

<P>Tags provide an easy way to attach arbitrary information (e.g.&nbsp;additional
RenderMan interface attributes, special attributes for plugins, or even
scripts) to objects. A tag consists of two strings, one defining the type
and one defining the value of the tag.</P>
<P>Tags may be manipulated via the tags property GUI (see
section 
<A HREF="#tagsprop">Tags Property</A>)
or the scripting interface
(see section 
<A HREF="ayam-6.html#scitags">Manipulating Tags</A>).
In addition, there is a corresponding sub menu in the main menu
(see section 
<A HREF="ayam-2.html#mmtags">Tags Menu</A>).</P>
<P>The following two tables contain a compact list of tag names and short
explanations for all tag types that are
known in Ayam and in all accompanying extensions (plugins);
tag types marked with an asterisk (*) are for internal use only.</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Name</B></TD><TD><B>Description</B></TD></TR><TR><TD>
ANS</TD><TD>After Notify Script</TD></TR><TR><TD>
AsWire</TD><TD>X3D export control</TD></TR><TR><TD>
BNS</TD><TD>Before Notify Script</TD></TR><TR><TD>
BP</TD><TD>Bevel Parameter</TD></TR><TR><TD>
CP</TD><TD>Cap Parameter</TD></TR><TR><TD>
CIDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
CCIDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
DANS</TD><TD>Disabled After Notify Script</TD></TR><TR><TD>
DBNS</TD><TD>Disabled Before Notify Script</TD></TR><TR><TD>
DC</TD><TD>Depth Complexity</TD></TR><TR><TD>
HC</TD><TD>Has Children*</TD></TR><TR><TD>
IDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
IIDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
MI</TD><TD>Material ID*</TD></TR><TR><TD>
MN</TD><TD>Mean Normal</TD></TR><TR><TD>
mn</TD><TD>master name*</TD></TR><TR><TD>
MP</TD><TD>Mean Point</TD></TR><TR><TD>
NC</TD><TD>Notify Count*</TD></TR><TR><TD>
NM</TD><TD>Notify Master*</TD></TR><TR><TD>
NO</TD><TD>Notify Object*</TD></TR><TR><TD>
NoExport</TD><TD>Export Control</TD></TR><TR><TD>
NP</TD><TD>New Property</TD></TR><TR><TD>
NT</TD><TD>Normals Tangents
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Tags Overview (1/2), * &ndash; internal</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>
<CENTER>
<TABLE ALIGN="CENTER" BORDER="1" CELLPADDING="3"><TR><TD>
<B>Name</B></TD><TD><B>Description</B></TD></TR><TR><TD>
OI</TD><TD>Object ID*</TD></TR><TR><TD>
PV</TD><TD>Primitive Variable</TD></TR><TR><TD>
RiAttribute</TD><TD>RenderMan Export</TD></TR><TR><TD>
RiDisplay</TD><TD>RenderMan Export</TD></TR><TR><TD>
R3IDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
RIDR</TD><TD>Importance Driven Rendering</TD></TR><TR><TD>
RiHider</TD><TD>RenderMan Export</TD></TR><TR><TD>
RiOption</TD><TD>RenderMan Export</TD></TR><TR><TD>
RP</TD><TD>Remove Property</TD></TR><TR><TD>
SaveMainGeom</TD><TD>Geometry Management</TD></TR><TR><TD>
SavePaneLayout</TD><TD>Geometry Management</TD></TR><TR><TD>
SB</TD><TD>Selected Boundary</TD></TR><TR><TD>
SP</TD><TD>Selected Points</TD></TR><TR><TD>
TC</TD><TD>Texture Coordinates</TD></TR><TR><TD>
TM</TD><TD>Transformation Matrix*</TD></TR><TR><TD>
TP</TD><TD>Tesselation Parameters</TD></TR><TR><TD>
UMM</TD><TD>U Min Max</TD></TR><TR><TD>
VMM</TD><TD>V Min Max</TD></TR><TR><TD>
XML</TD><TD>XML Data
</TD></TR></TABLE>
</CENTER><P><CENTER><FONT SIZE="-1">Tags Overview (2/2), * &ndash; internal</FONT></CENTER><P><CENTER>
</CENTER>
</P>



<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="riatag"></A> RiAttribute Tag</H3>

<P>The tag type <CODE>"RiAttribute"</CODE> can be used to attach
arbitrary RenderMan interface attributes to objects.
This is handy if a renderer with lots of RiAttributes
that differ from the standard RiAttributes is in use.</P>
<P><CODE>"RiAttribute"</CODE> tags attached to a geometric object override
<CODE>"RiAttribute"</CODE> tags possibly attached to the material object of this
geometric object.</P>
<P>In order to create a tag of type RiAttribute, the type string must be
<CODE>"RiAttribute"</CODE>. The syntax of the value string is as following:</P>
<P><CODE>&lt;attrname&gt;,&lt;paramname&gt;,&lt;paramtype&gt;,&lt;param&gt;</CODE></P>
<P>where<BR>
<CODE>&lt;attrname&gt;</CODE> is the name of the attribute (e.g.&nbsp;"render");<BR>
<CODE>&lt;paramname&gt;</CODE> is the name of the parameter
(e.g.&nbsp;"displacementbound");<BR>
<CODE>&lt;paramtype&gt;</CODE> is a single character defining the type of the
parameter (it may be one of
<CODE>f</CODE> &ndash; float, <CODE>g</CODE> &ndash; float pair, <CODE>i</CODE> &ndash; integer,
<CODE>j</CODE> &ndash; integer pair, <CODE>s</CODE> &ndash; string, <CODE>c</CODE> &ndash; color,
<CODE>p</CODE> &ndash; point); and finally<BR>
<CODE>&lt;param&gt;</CODE> is the value of the parameter itself (e.g.&nbsp;a
float: "1.2", an integer value: "3", a string: "on", a color: "1,1,1"
or a point: "0.4,0.5,1.0").</P>
<P><B>Example</B></P>
<P>Some examples for valid RiAttribute tags:
<BLOCKQUOTE><CODE>
<PRE>
RiAttribute
render,truedisplacement,i,1

RiAttribute
dice,numprobes,j,3,3

RiAttribute
radiosity,specularcolor,c,0.5,0.5,0.5
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><B>Notes</B></P>
<P>The <CODE>"RiAttribute"</CODE> tag handles just a single parameter at once.
Also note that <CODE>"RiAttribute"</CODE> tags may be created much more easily
using the menu entry <CODE>"Special/Tags/Add RiAttribute"</CODE>.
The database of RiAttributes for this GUI may be extended
by editing the <EM>ayamrc</EM> file, see section
<A HREF="ayam-8.html#ayamrc">Ayamrc File</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="riotag"></A> RiOption Tag</H3>

<P>The tag type <CODE>"RiOption"</CODE> can be used to attach arbitrary RenderMan
interface options to the scene. This is handy if a renderer with
lots of RiOptions that differ from the standard RiOptions is in use.
However, they will be only used by the RIB exporter if they are attached
to the <CODE>"Root"</CODE> object.
The syntax is similar to the <CODE>"RiAttribute"</CODE> tag type, see above.</P>
<P><B>Example</B></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
RiOption
radiosity,steps,i,16

RiOption
shadow,bias0,f,0.01
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><B>Notes</B></P>
<P>RiOption tags may be created easily using the menu entry
<CODE>"Special/Tags/Add RiOption"</CODE>.
Tags created with this GUI will always be added to the <CODE>"Root"</CODE> object.
It does not have to be selected when the GUI is used.
Furthermore, the database of RiOptions for this GUI may be extended
by editing the <EM>ayamrc</EM> file, see section
<A HREF="ayam-8.html#ayamrc">Ayamrc File</A>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tctag"></A> TC (Texture Coordinates) Tag</H3>

<P>The tag type <CODE>"TC"</CODE> can be used to attach texture coordinates to
objects or materials.</P>
<P>The <CODE>"TC"</CODE> tag always contains a list of eight comma separated
float values, that specify a mapping for four 2D points (a quadrilateral)
in texture space from the default values (0,0), (1,0), (0,1), and (1,1)
to the new specified values.</P>
<P><B>Example</B></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
TC
0,0,10,0,0,10,10,10
</PRE>
</CODE></BLOCKQUOTE>

Changes the texture coordinate space so that more and smaller tiles
of a texture would be displayed on a primitive.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
TC
0,0,0,1,1,0,1,1
</PRE>
</CODE></BLOCKQUOTE>

Flips the texture coordinate space over two corners.
A shader normally generating vertical stripes will create
horizontal stripes now.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
TC
0,1,0,0,1,1,1,0
</PRE>
</CODE></BLOCKQUOTE>

Turns the texture coordinate space by 90 degrees.
A shader normally generating vertical stripes will create
horizontal stripes now.</P>
<P><B>Notes</B></P>
<P><CODE>"TC"</CODE> tags attached to a geometric object override
<CODE>"TC"</CODE> tags possibly attached to the material object of this
geometric object.</P>
<P>The exact behaviour of an object equipped with a <CODE>"TC"</CODE> tag
depends heavily on the shader and its use of the texture coordinates.</P>
<P>Note also that using <CODE>"TC"</CODE> tags, the texture coordinates
of entire primitives are changed. To change the texture coordinates
of sub-primitives (e.g.&nbsp;of single control points of a NURBS patch)
<CODE>"PV"</CODE> (Primitive Variable) tags must be used instead.</P>
<P>To ease setting of <CODE>"TC"</CODE> tag values Ayam provides a special graphical
editor as outlined below.</P>
<P>The texture coordinate editor
<A NAME="tce"></A>  may be opened using the
main menu entry <CODE>"Special/Tags/Edit TexCoords"</CODE> and
lets you edit texture coordinate tags in an intuitive way.</P>
<P>For that, the current texture coordinates are displayed as a black
polygon in a canvas with regard to the original (default) values,
that are displayed in gray.
Small arrows point to positive s and t direction respectively.</P>
<P>
<CENTER>
<IMG SRC="pics/tce.gif" HEIGHT=377 WIDTH=338  loading="lazy">
</CENTER><P><CENTER><FONT SIZE="-1">Texture Coordinate Editor</FONT></CENTER><P><CENTER>
</CENTER>
</P>
<P>The <CODE>"RotateR"</CODE> and <CODE>"RotateL"</CODE> buttons shift the coordinate
values between the four points. This results in a 90 degree
rotation of the texture space.</P>
<P>The <CODE>"FlipS"</CODE> and <CODE>"FlipT"</CODE> buttons flip the texture
coordinate values in s and t direction respectively. This is
useful, if, for example, a texture mapping shall be corrected for
an image that appears upside down.</P>
<P>The next buttons allow to move (using <CODE>"MoveS"</CODE> and <CODE>"MoveT"</CODE>)
and scale (using <CODE>"ScaleS"</CODE> and <CODE>"ScaleT"</CODE>) the texture coordinates
by a specific amount that is given in the first entry field.</P>
<P>The <CODE>"Load"</CODE> and <CODE>"Save"</CODE> menu buttons allow to:
<UL>
<LI>load the default texture coordinate values ((0,0), (1,0), (0,1), (1,1)),
</LI>
<LI>load texture coordinates from a selected BPatch object:
The xy coordinates of the four points of the selected BPatch
will be interpreted as st coordinates.
This allows for more complex transformations of the texture coordinates
e.g.&nbsp;rotations about an angle of 45 degrees. For that just create a
BPatch object, rotate it accordingly, then load the coordinates into
the texture coordinate editor.
</LI>
<LI>load TC tags from the selected object,
</LI>
<LI>save the texture coordinates to a BPatch object,
</LI>
<LI>save TC tags to a selected object. Note that it is not
possible to directly save the TC tag to multiple selected objects.
But the property clipboard can be used to copy the tag after saving
to a single object.</LI>
</UL>

Note that the tag numbers in the menu entries count TC tags only.</P>
<P>The texture coordinate dialog is mode-less, it may stay open
while modeling.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="pvtag"></A> PV (Primitive Variable) Tag</H3>

<P>The tag type <CODE>"PV"</CODE> can be used to attach arbitrary data
to geometric primitives and even sub-primitives.
With the help of primitive variables texture coordinates can be attached
to the vertices of a NURBS patch primitive or distinct
colors to the faces or even to single vertices of a polygonal mesh.
In the latter case, the data is properly interpolated by the RenderMan
renderer before it is handed over to the surface shader.</P>
<P>When rendering, all data defined in a <CODE>"PV"</CODE> tag is handed over
to the surface shader that is attached to the respective geometric primitive
using additional shader parameters.
For RIB export, proper <CODE>"RiDeclare"</CODE> statements will be created
automatically by Ayam.</P>
<P>However, Ayam does not check, whether the shaders actually use the data
from the <CODE>"PV"</CODE> tag.</P>
<P>The syntax of the value string of a PV tag is as following:</P>
<P><CODE>&lt;name&gt;,&lt;detail&gt;,&lt;type&gt;,&lt;ndata&gt;,&lt;data&gt;</CODE></P>
<P>where<BR>
<CODE>&lt;name&gt;</CODE> is the name of the primitive variable;<BR>
<CODE>&lt;detail&gt;</CODE> (or storage class) should be one of
<CODE>"uniform"</CODE>, <CODE>"varying"</CODE>, <CODE>"vertex"</CODE>, or <CODE>"constant"</CODE>;<BR>
<CODE>&lt;type&gt;</CODE> is a single character describing the type of the
data (one of <CODE>"c"</CODE> (color), <CODE>"f"</CODE> (float), <CODE>"g"</CODE> (float[2]),
<CODE>"n"</CODE> (normal), <CODE>"p"</CODE> (point), <CODE>"s"</CODE> (string), or <CODE>"v"</CODE> (vector),
see also the documentation of the <CODE>"RiAttribute"</CODE> tag above);<BR>
<CODE>&lt;ndata&gt;</CODE> is an integer number describing how many data
elements will follow; and<BR>
<CODE>&lt;data&gt;</CODE> is a comma separated list
consisting of <CODE>&lt;ndata&gt;</CODE> elements of type <CODE>&lt;type&gt;</CODE>.</P>
<P><B>Examples</B></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
PV
mycolor,constant,c,1,0,1,0
</PRE>
</CODE></BLOCKQUOTE>

adds a single color value (0,1,0), which is the same all over the primitive,
the respective surface shader should have a parameter <CODE>"color mycolor"</CODE>;
<BLOCKQUOTE><CODE>
<PRE>
PV
mys,varying,f,4,0.1,0.2,0.3,0.4
</PRE>
</CODE></BLOCKQUOTE>

could be used to add a distinct float value to each corner point of a
four point NURBS patch (of order, width, and height 2),
the respective surface shader should have a parameter
<CODE>"varying float mys"</CODE>.</P>
<P><B>Notes</B></P>
<P>The following data types are <EM>not</EM> supported: <CODE>"i"</CODE>, <CODE>"j"</CODE>.
Support for the data types <CODE>"n"</CODE> (normal), and <CODE>"v"</CODE> (vector) was added
in Ayam 1.17.</P>
<P>Not all geometric objects currently honour PV tags
on RIB export. The geometric objects currently supporting PV tags
are: SDMesh, PolyMesh, PatchMesh, NPatch, and BPatch.
Most tool objects that internally create NPatch objects also support PV
tags.<SMALL TITLE="Since 1.20."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
Mind that the same set of tags
will be used for all surfaces that make up the tool object,
e.g.&nbsp;the swept surface, its bevels, and its caps.</P>
<P>Furthermore, the number of data elements, which depends on the
detail or storage class, the type of geometric primitive, and the
configuration of the geometric primitive is <EM>not</EM> checked by Ayam.
Some RIB writing libraries, however, do verify the numbers and silently
omit the primitive variable if there are mismatches. The RIB should be
examined for the presence of the primitive variable after export,
especially, if PV tags were added or edited manually.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="rihtag"></A> RiHider Tag</H3>

<P>The tag type <CODE>"RiHider"</CODE> can be used to choose and parameterise
different algorithms for hidden surface removal when rendering
the exported scene with a RenderMan compliant renderer.
RiHider tags have to be attached to the root object in order to be used.
The syntax of a RiHider tag is quite similar to a RiAttribute tag:
<CODE>"&lt;type&gt;,&lt;parameterlist&gt;"</CODE>
where <CODE>"&lt;type&gt;"</CODE> is the name of an algorithm and
<CODE>"&lt;parameterlist&gt;"</CODE> is a comma separated list
of triplets consisting of name, type, and value of a parameter.</P>
<P><B>Example</B></P>
<P>A RiHider tag could look like this:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
RiHider
hidden,depthfilter,s,midpoint
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ridtag"></A> RiDisplay Tag</H3>

<P>The tag type <CODE>"RiDisplay"</CODE> can be used to add output files of
different type (e.g.&nbsp;containing depth-buffer information)
to the scene or to directly control the output format when rendering
the exported scene with a RenderMan compliant renderer.
RiDisplay tags have to be attached to the Root object in order to be used.
The syntax of a RiDisplay tag is as follows:
<CODE>"&lt;name&gt;,&lt;type&gt;,&lt;mode&gt;,&lt;parameterlist&gt;"</CODE>,
where<BR>
<CODE>"&lt;name&gt;"</CODE> is a file or device name,<BR>
<CODE>"&lt;type&gt;"</CODE> specifies the destination of the image data
(e.g.&nbsp;screen or file),<BR>
<CODE>"&lt;mode&gt;"</CODE> specifies which information should be stored or displayed
(e.g.&nbsp;color values: rgb, or depth values: z), and<BR>
<CODE>"&lt;parameterlist&gt;"</CODE> is a optionally present comma separated list
of triplets consisting of name, type, and value of a parameter.</P>
<P><B>Example</B></P>
<P>A RiDisplay tag to add output of the depth-buffer information to the
file <CODE>"imagez.tif"</CODE> could look like this:
<BLOCKQUOTE><CODE>
<PRE>
RiDisplay
imagez.tif,file,z
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><B>Notes</B></P>
<P>The name will be automatically changed to <CODE>"+name"</CODE> on RIB export
if it does not already start with a plus (except for the very first
RiDisplay statement).</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="aswiretag"></A> AsWire Tag</H3>

<P>The tag type <CODE>"AsWire"</CODE> switches export of certain objects
from surface to wire-frame mode.
The value string of this tag is ignored. All
that counts is the presence of the tag.
Note that only X3D export honours this tag.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="noexporttag"></A> NoExport Tag</H3>

<P>The tag type <CODE>"NoExport"</CODE> can be used to exclude certain objects
from exported RIBs. The value string of this tag is ignored. All
that counts is the presence of the tag. Child objects of objects
with the <CODE>"NoExport"</CODE> tag will also be excluded from the RIB.
Since Ayam 1.6, light objects also honour the <CODE>"NoExport"</CODE> tag.
Note that regardless of potentially present <CODE>"NoExport"</CODE> tags,
RIB archives will be created for all referenced objects all the
time (even if <CODE>"NoExport"</CODE> tags are added to all instances).</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="savemaingeomtag"></A> SaveMainGeom Tag</H3>

<P>The tag type <CODE>"SaveMainGeom"</CODE> can be used to save the geometry
of the main window and the toolbox window (if open) to a scene
file. For that the scene saving code checks for the presence of
a <CODE>"SaveMainGeom"</CODE> tag for the Root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <CODE>"SaveMainGeom"</CODE> tag for the Root object
after replacing a scene and re-establishes the geometries of
main and toolbox window.</P>
<P>This tag is only filled with meaningful data and the geometry
is only restored if Ayam is in multi window GUI mode.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="savepanelayouttag"></A> SavePaneLayout Tag</H3>

<P>The tag type <CODE>"SavePaneLayout"</CODE> can be used to save the relative
sizes of the internal windows of the main window when Ayam runs in
the single window GUI mode to a scene file.
For that the scene saving code checks for the presence of
a <CODE>"SavePaneLayout"</CODE> tag for the Root object and fills it with
the current geometry information. The scene reading code checks
for the presence of a <CODE>"SavePaneLayout"</CODE> tag for the Root object
after replacing a scene and re-establishes the geometries of the
internal windows.</P>
<P>This tag is only filled with meaningful data and the pane layout
is only restored if Ayam is in single window GUI mode.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="tptag"></A> TP (Tesselation Parameter) Tag</H3>

<P>The tag type <CODE>"TP"</CODE> can be used to save tesselation parameters
to objects of type <CODE>"NPatch"</CODE> (and objects that may be converted
to <CODE>"NPatch"</CODE> objects). Those tesselation parameters
will be used when the NPatch object is tesselated for e.g.&nbsp;a
conversion to a PolyMesh object. The syntax of the TP tag is:
<CODE>"&lt;smethod&gt;,&lt;sparamu&gt;,&lt;sparamv&gt;[,&lt;refinetrims&gt;]"</CODE>
where<BR>
<CODE>&lt;smethod&gt;</CODE> is an integer value between 1 and 6,
describing which sampling method to use (1 &ndash; ParametricError,
2 &ndash; PathLength,
3 &ndash; DomainDistance,
4 &ndash; NormalizedDomainDistance,
5 &ndash; AdaptiveDomainDistance, and
6 &ndash; AdaptiveKnotDistance)
and<BR>
<CODE>&lt;sparamu&gt;</CODE> and <CODE>&lt;sparamv&gt;</CODE> are float values
describing the respective parameter value for the chosen sampling
method. The second parameter value is ignored for the sampling methods
1 and 2.</P>
<P>The last value, <CODE>"refinetrims"</CODE>, is an integer between 0 and 5
controlling how many times the trim curves are to be refined before
tesselation for improved tesselation fidelity along trim edges.
The <CODE>"refinetrims"</CODE> value may be omitted and defaults to 0.</P>
<P>Note that the syntax of the <CODE>"TP"</CODE> tag changed in Ayam 1.9,
the old syntax only allowed one parameter.</P>
<P>TP tags may be easily created using the tesselation GUI, that can
be started with the main menu entry <CODE>"Tools/Surface/Tesselate"</CODE>
(see also section 
<A HREF="ayam-5.html#tesst">Tesselation Tool</A>).</P>
<P><B>Example</B></P>
<P>A TP tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
TP
1,0.5,0.6
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="dctag"></A> DC (Depth Complexity) Tag</H3>

<P>The tag type <CODE>"DC"</CODE> is only used by the AyCSG CSG preview plugin
to store the depth complexity of CSG primitives.
The syntax of the DC tag is:
<CODE>"&lt;dcval&gt;"</CODE>
where <CODE>"&lt;dcval&gt;"</CODE> is a positive integer value describing the
depth complexity of the CSG primitive. See also section
<A HREF="ayam-8.html#aycsg">CSG preview using the AyCSG plugin</A>
for more information regarding the depth complexity value.</P>
<P><B>Example</B></P>
<P>A DC tag (valid for e.g.&nbsp;a torus) could look like this:
<BLOCKQUOTE><CODE>
<PRE>
DC
2
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="nptag"></A> NP (New Property) Tag</H3>

<P>The tag type <CODE>"NP"</CODE> (new property) may be used to add new property
GUIs to single objects. The value of the tag is the name of a new
property. The necessary code to manage the property data and the
windows that make up the property GUI itself have to be present in
the Tcl context of Ayam before the user clicks on the new property in the
property list box.</P>
<P><B>Example</B></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
NP
Transformations
</PRE>
</CODE></BLOCKQUOTE>

This tag can e.g.&nbsp;be added to Script objects that create objects.</P>
<P>Any script controlled property GUI of a Script object must also be
enabled using a NP tag like this:
<BLOCKQUOTE><CODE>
<PRE>
NP
MyProperty
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><B>Notes</B></P>
<P>NP tags can be managed more easily using a specialized dialog that
is available in the main menu <CODE>"Special/Tags/Add Property"</CODE>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="rptag"></A> RP (Remove Property) Tag</H3>

<P>The tag type <CODE>"RP"</CODE> (remove property) may be used to remove GUI access
to a property from single objects. The value of the tag is the name of the
property to be removed. The GUI access will be blocked by simply omitting
the property from the property listbox.
Note well: the property is still present and active in the objects themselves
and values may still be set using the scripting interface.</P>
<P><B>Example</B></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
RP
Script
</PRE>
</CODE></BLOCKQUOTE>

removes direct access to the Script property of a Script object.
Ideally, the Script object also has a <CODE>"NP"</CODE> tag, to allow
direct control of script parameters. This way, the user does not
see the script (code), just a clean parameter GUI.</P>
<P>Here is another example: the tag
<BLOCKQUOTE><CODE>
<PRE>
RP
Transformations
</PRE>
</CODE></BLOCKQUOTE>

can be added to Instance objects to turn them into references
(instances without own transformation attributes).</P>
<P><B>Notes</B></P>
<P>RP tags can be managed more easily using a specialized dialog that
is available in the main menu <CODE>"Special/Tags/Remove Property"</CODE>.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bnstag"></A> BNS (Before Notify Script) Tag</H3>

<P>The tag type <CODE>"BNS"</CODE> (before notify script) may be used to add scripts
to an object, that will be run <EM>before</EM> the notification of
that object starts.
A notification, in turn, will be executed because e.g.&nbsp;one of the children
of the object changed (see also section
<A HREF="ayam-8.html#toolobj">The Modelling Concept Tool-Objects</A>).
When the script runs, the respective object with the BNS tag will already
be selected. Current level and selection will be restored when the
script finishes, i.e.&nbsp;neither needs to be done by the script.</P>
<P><B>Example</B></P>
<P>A simple BNS tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
BNS
puts "notify callback about to fire"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>A more useful example (that is also available as example scene
<CODE>"ayam/scn/scripts/bnstag.ay"</CODE>):
<BLOCKQUOTE><CODE>
<PRE>
BNS
getProp;
set ::RevolveAttrData(Sections) [expr int($::RevolveAttrData(ThetaMax)/10)];
setProp
</PRE>
</CODE></BLOCKQUOTE>

This tag computes the number of sections from the ThetaMax value
of a Revolve object. Whenever the ThetaMax is changed, the number
of sections adapt, so that each section always spans the same angle.
The function call <CODE>int()</CODE> is needed because the C code for the
<CODE>setProp</CODE> command of the RevolveAttr property only looks for integer
data in the variable <CODE>Sections</CODE> and without <CODE>int()</CODE> the variable
would contain incompatible floating point data.</P>
<P>A second similar example would be:
<BLOCKQUOTE><CODE>
<PRE>
BNS
getProp;
set ::ACurveAttrData(ALength) [expr int($::ACurveAttrData(Length)/2)];
setProp
</PRE>
</CODE></BLOCKQUOTE>

This tag automatically derives a good value for the <CODE>ALength</CODE> parameter
of a ACurve object from the number of data points to approximate. When this
tag is added to a ACurve object, the interactive insert/delete point actions
can be used more freely.</P>
<P>Here is another shorter example; the BNS tag
<BLOCKQUOTE><CODE>
<PRE>
BNS
applyTrafo -all
</PRE>
</CODE></BLOCKQUOTE>

makes sure, that a NCurve or NPatch object always has the default
transformations, as any changes to the transformation attributes
will immediately be applied to the control points and the transformation
attributes will be reset in the progress.</P>
<P><B>Notes</B></P>
<P>In Ayam versions prior to 1.16 BNS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
BNS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<A HREF="#safeinterp">Safe Interpreter</A>.
Consequently, the warning dialog that appeared when files with
BNS tags were loaded is also gone.</P>
<P>The original functionality can still be re-enabled by recompiling Ayam.
If this is enabled and scene files containing BNS
tags are loaded, Ayam will again raise a warning dialog, offering to
temporarily disable all such tags that will be read for obvious security
reasons.
To disable a BNS tag, Ayam simply changes its type from <CODE>"BNS"</CODE>
to <CODE>"DBNS"</CODE> (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <CODE>"BNS"</CODE>
or by using the main menu entry <CODE>"Special/Enable Scripts"</CODE>.</P>
<P>If the script of a BNS tag fails, the tag will be disabled by
changing the type to DBNS.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Also note that BNS tag scripts must not change the scene hierarchy,
i.e.&nbsp;they must not create or delete objects or use the object clipboard.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="anstag"></A> ANS (After Notify Script) Tag</H3>

<P>The tag type <CODE>"ANS"</CODE> (after notify script) may be used to add scripts
to an object, that will be run <EM>after</EM> the notification of
that object completed.
The notification, in turn, will be executed because e.g.&nbsp;one of the children
of the object changed (see also section
<A HREF="ayam-8.html#toolobj">The Modelling Concept Tool-Objects</A>).
When the script runs, the respective object with the ANS tag will already
be selected. Current level and selection will be restored when the
script finishes, i.e.&nbsp;neither needs to be done by the script.</P>
<P><B>Example</B></P>
<P>A simple ANS tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
ANS
puts "notify callback completed"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><B>Notes</B></P>
<P>In Ayam versions prior to 1.16 ANS tag scripts could use any
functionality of Tcl, Tk, and the Tcl scripting interface of Ayam which
posed a huge security risk. This is no longer the case.
ANS tag scripts now run in a safe interpreter with reduced
instruction set. They can no longer write to the file system, get
onto the network, or confuse the application state, see also section
<A HREF="#safeinterp">Safe Interpreter</A>.
Consequently, the warning dialog that appeared when files with
ANS tags were loaded is also gone.</P>
<P>The original functionality can still be re-enabled by recompiling Ayam.
If this is enabled and scene files containing ANS
tags are loaded, Ayam will again raise a warning dialog, offering to
temporarily disable all such tags that will be read for obvious security
reasons.
To disable a ANS tag, Ayam simply changes its type from <CODE>"ANS"</CODE>
to <CODE>"DANS"</CODE> (disabled before notify script).
It will not be executed then.
Disabled notify script tags may be enabled after careful inspection
by simply changing their type back to <CODE>"ANS"</CODE>
or by using the main menu entry <CODE>"Special/Enable Scripts"</CODE>.</P>
<P>If the script of a ANS tag fails, the tag will be disabled by
changing the type to DANS.<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL></P>
<P>Also note that ANS tag scripts must not change the scene hierarchy,
i.e.&nbsp;they must not create or delete objects or use the object clipboard.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="ummtag"></A> UMM/VMM (U/V Min Max) Tag</H3>

<P>The tag types <CODE>"UMM"</CODE> (u min max) and <CODE>"VMM"</CODE> (v min max) may
be used to store additional parametric domain trimming values to
NURBS curve and NURBS patch objects. Note that the GLU NURBS display
modes do not honor those tags, but some export plugins do (RIB,
Wavefront OBJ, 3DM (Rhino)).
Those tags will also be created by RIB import or Wavefront OBJ import.</P>
<P><B>Example</B></P>
<P>An UMM tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
UMM
0.4,0.6
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="bptag"></A> BP (Bevel Parameters) Tag</H3>

<P>The tag type <CODE>"BP"</CODE> (bevel parameters) is used by all bevel
supporting tool objects to store their bevel parameter information.
See also sections
<A HREF="#bevelsprop">Bevels property</A> and
<A HREF="#bevelp">BevelAttr Property</A>.<BR>
The syntax of the BP tag is:
<BLOCKQUOTE><CODE>
<CODE>"&lt;side&gt;,&lt;type&gt;,&lt;radius&gt;,&lt;revert&gt;"</CODE>
</CODE></BLOCKQUOTE>

where<BR>
<CODE>&lt;side&gt;</CODE> is an integer value from 0 - 3
defining the side of the surface, to add the bevel to,<BR>
<CODE>&lt;type&gt;</CODE> is an integer value defining
the type of the bevel,<BR>
<CODE>&lt;radius&gt;</CODE> is a floating point
value defining the radius of the bevel, and<BR>
<CODE>&lt;revert&gt;</CODE>
is either 0 or 1 and may be used to revert the bevel.</P>
<P><B>Example</B></P>
<P>A BP tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
BP
0,0,0.1,0
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="cptag"></A> CP (Cap Parameters) Tag</H3>

<P>The tag type <CODE>"CP"</CODE> (cap parameters) is used by all cap
supporting tool objects to store their cap parameter information.
See also sections
<A HREF="#capsprop">Caps property</A> and
<A HREF="#capp">CapAttr Property</A>.<BR>
The syntax of the CP tag is:
<BLOCKQUOTE><CODE>
<CODE>"&lt;side&gt;,&lt;type&gt;,&lt;integrate&gt;,&lt;fraction&gt;"</CODE>
</CODE></BLOCKQUOTE>

where<BR>
<CODE>&lt;side&gt;</CODE> is an integer value from 0 - 3
defining the side of the surface, to add the cap to,<BR>
<CODE>&lt;type&gt;</CODE> is an integer value from 0 - 3 defining
the type of the cap,<BR>
<CODE>&lt;integrate&gt;</CODE> determines whether to integrate the cap into the
progenitor surface (0 or 1)<BR>
<CODE>&lt;fraction&gt;</CODE> a floating point parameter value for the Simple3D cap
type.</P>
<P><B>Example</B></P>
<P>A CP tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
CP
0,0,0,0.5
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="mntag"></A> MN (Mean Normal) Tag</H3>

<P>The tag type <CODE>"MN"</CODE> (mean normal) can be added to the Bevel object
to control the mean/target normal of the <CODE>"RoundToNormal"</CODE>
bevel mode.
The tag value is a list of three comma separated floating point numbers,
a 3D vector. The vector does not have to be normalized.</P>
<P><B>Example</B></P>
<P>A MN tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
MN
0.0,1.0,0.1
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="mptag"></A> MP (Mean Point) Tag</H3>

<P>The tag type <CODE>"MP"</CODE> (mean point) can be added to the Cap object
or objects with caps to control the middle point of the <CODE>"Simple"</CODE>
and <CODE>"Simple3D"</CODE> caps. This is useful if e.g.&nbsp;the automatically
calculated mean point of the parameter curve is off.
The tag value is a list of three comma separated floating point numbers,
a 3D vector, followed by an integer value between 0 and 3 designating
the cap. On Cap objects, the cap number may be omitted.</P>
<P><B>Example</B></P>
<P>A MP tag could look like this:
<BLOCKQUOTE><CODE>
<PRE>
MP
0.5,0.25,0.1,0
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="sbtag"></A> SB (Selected Boundary) Tag</H3>

<P>The tag type <CODE>"SB"</CODE> (selected boundary) is used by the
select boundary action(s) to store their results, but it can
also be created manually or by other means.
The tag supports two notations, a simple one, consisting of an
integer value and a complex one, where an object index and a
boundary index are provided. The latter needs to specified for
tool objects that provide multiple NPatch objects.</P>
<P><B>Examples</B></P>
<P>A SB tag in simple notation could look like this:
<BLOCKQUOTE><CODE>
<PRE>
SB
1
</PRE>
</CODE></BLOCKQUOTE>

and in complex notation:
<BLOCKQUOTE><CODE>
<PRE>
SB
o:2b:4
</PRE>
</CODE></BLOCKQUOTE>
</P>

<div style="height: 0.5em">&nbsp;</div>
<H3><A NAME="xmltag"></A> XML Tag</H3>

<P>The tag type <CODE>"XML"</CODE> can be used to enrich XML based export
formats with arbitrary user defined data (attributes and
nodes).<SMALL TITLE="Since 1.24."><SUP>&lsqb;&lowast;&rsqb;</SUP></SMALL>
It can currently only be added to Material and NURBS surface objects
for X3D export
(see also section 
<A HREF="ayam-7.html#expx3d">X3D (Web3D) Export</A>).
The value string of this tag must be a valid XML node hierarchy
where the outer node specifies the target node of the XML data.
Attributes of the outer node will be added to the target XML node
for export, already existing attributes will be overwritten
(i.e.&nbsp;the XML data tag will be processed after the XML export
converted the corresponding Ayam object to a XML node hierarchy).
Likewise, all child nodes of the outer node will be added to the
matching target XML node. CDATA sections are also supported
properly (this is important for GLSL shader source code).</P>
<P><B>Examples</B></P>
<P>XML tags could look like this:
<BLOCKQUOTE><CODE>
<PRE>
XML
&lt;Material shininess='0.7'/&gt;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>to add the shininess attribute to a Material.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
XML
&lt;Appearance&gt;
&lt;ComposedShader language='GLSL'&gt;
...
&lt;/ComposedShader&gt;
&lt;/Appearance&gt;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>to add a GLSL shader to a Material.</P>

<div style="height: 0.5em">&nbsp;</div>
<H3>Internal Tags</H3>

<P>The following tags are used by Ayam internally only; they will <EM>not</EM>
appear in the tags property GUI and they can <EM>not</EM> be deleted or
changed using the scripting interface.
<UL>
<LI>OI (Object ID) Tag
<A NAME="oitt"></A> 

<P>This tag is used by the RIB exporter and the scene storage
facility to establish links between instance objects and
the master objects they are pointing to.</P>

</LI>
<LI>MI (Material ID) Tag
<A NAME="mitt"></A> 

<P>This tag is used by the RIB exporter and the scene storage
facility to establish links between material objects and
the objects they are assigned to.</P>

</LI>
<LI>HC (Has Children) Tag
<A NAME="hctt"></A> 

<P>This tag is used by the scene storage facility.</P>

</LI>
<LI>TM Tag

<P>Internal binary tag to store transformation matrices, used by
the AyCSG plugin.</P>

</LI>
<LI>mdn Tag

<P>Internal tag used by the X3D import/export plugin.
Renamed from mn since Ayam 1.26.</P>

</LI>
<LI>NC Tag

<P>Internal tag used by the notification mechanism.</P>

</LI>
<LI>NO/NM Tags
<A NAME="nott"></A> <A NAME="nmtt"></A> 

<P>These tags are internal binary tags that transport the notification
across the scene.</P>

</LI>
<LI>NT Tag
<A NAME="nttt"></A> 

<P>This tag is an internal binary tag that carries normals and tangents
for curves extracted from surfaces.</P>

</LI>
</UL>
</P>

<HR>
<A HREF="ayam-5.html">Next</A>
<A HREF="ayam-3.html">Previous</A>
<A HREF="ayam.html#toc4">Contents</A>
</BODY>
</HTML>


